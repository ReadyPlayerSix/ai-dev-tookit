{
  "path": "D:\\Projects\\isekaiZen\\machine-learning-optimizer\\benchmarks.old\\models\\src\\utils\\training\\domain_validator.py",
  "imports": [
    {
      "name": "typing.Dict",
      "line": 1
    },
    {
      "name": "typing.List",
      "line": 1
    },
    {
      "name": "typing.Optional",
      "line": 1
    },
    {
      "name": "typing.Any",
      "line": 1
    },
    {
      "name": "numpy",
      "line": 2
    },
    {
      "name": "dataclasses.dataclass",
      "line": 3
    },
    {
      "name": "datetime.datetime",
      "line": 4
    },
    {
      "name": "json",
      "line": 5
    },
    {
      "name": "pathlib.Path",
      "line": 6
    },
    {
      "name": "cortex.pattern_orchestrator.PatternOrchestrator",
      "line": 8
    },
    {
      "name": "cortex.semantic_core.SemanticPatternRegistry",
      "line": 9
    },
    {
      "name": "cortex.semantic_core.SemanticPattern",
      "line": 9
    },
    {
      "name": "cortex.semantic_core.SemanticType",
      "line": 9
    }
  ],
  "classes": {
    "DomainValidationConfig": {
      "start_line": 12,
      "end_line": 18,
      "methods": {},
      "class_variables": [],
      "bases": [],
      "docstring": "Configuration for domain-specific validation"
    },
    "DomainSpecificValidator": {
      "start_line": 18,
      "end_line": 320,
      "methods": {
        "__init__": {
          "start_line": 21,
          "end_line": 74,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "log_dir",
              "type": "str"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "Path",
              "line": 22
            },
            {
              "name": "self.log_dir.mkdir",
              "line": 23
            },
            {
              "name": "DomainValidationConfig",
              "line": 27
            },
            {
              "name": "DomainValidationConfig",
              "line": 38
            },
            {
              "name": "DomainValidationConfig",
              "line": 49
            },
            {
              "name": "self.domain_configs.keys",
              "line": 70
            }
          ],
          "code_snippet": "    \"\"\"Validates patterns within their native domains before testing cross-domain transfer\"\"\"\n    \n    def __init__(self, log_dir: str = \"logs/training_metrics/domain_validation\"):\n        self.log_dir = Path(log_dir)\n        self.log_dir.mkdir(parents=True, exist_ok=True)\n        \n        # Domain-specific validation configs\n        self.domain_configs = {\n            \"emotional\": DomainValidationConfig(\n                feature_ranges={\n                    \"valence\": (-1.0, 1.0),\n                    \"arousal\": (0.0, 1.0),\n                    \"intensity\": (0.0, 1.0)\n                },\n                required_features=[\"valence\", \"arousal\", \"intensity\"],\n                semantic_rules={\n                    \"intensity_arousal_correlation\": 0.6  # Expected correlation\n                }\n            ),\n            \"linguistic\": DomainValidationConfig(\n                feature_ranges={\n                    \"complexity\": (0.0, 1.0),\n                    \"coherence\": (0.0, 1.0),\n                    \"formality\": (0.0, 1.0)\n                },\n                required_features=[\"complexity\", \"coherence\"],\n                semantic_rules={\n                    \"min_coherence\": 0.3  # Minimum coherence threshold\n                }\n            ),\n            \"visual\": DomainValidationConfig(\n                feature_ranges={\n                    \"size\": (0.0, 1.0),\n                    \"centrality\": (0.0, 1.0),\n                    \"contrast\": (0.0, 1.0)\n                },\n                required_features=[\"size\", \"centrality\"],\n                semantic_rules={\n                    \"max_size_centrality_sum\": 1.8  # Size + centrality shouldn't exceed this\n                }\n            )\n        }\n        \n        # Validation metrics\n        self.metrics = {domain: {\n            \"total_patterns\": 0,\n            \"valid_patterns\": 0,\n            \"feature_violations\": 0,\n            \"semantic_violations\": 0,\n            \"cross_domain_attempts\": 0,\n            \"successful_transfers\": 0\n        } for domain in self.domain_configs.keys()}\n        \n        self.validation_history = []\n\n    def validate_pattern_features(self, pattern: Dict[str, Any], domain: str) -> Dict[str, Any]:\n        \"\"\"Validate pattern features against domain-specific rules\"\"\"\n        if domain not in self.domain_configs:"
        },
        "validate_pattern_features": {
          "start_line": 74,
          "end_line": 100,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "pattern"
            },
            {
              "name": "domain",
              "type": "str"
            }
          ],
          "return_type": "complex_type",
          "calls": [
            {
              "name": "....items",
              "line": 89
            },
            {
              "name": "pattern.get",
              "line": 84
            },
            {
              "name": "....append",
              "line": 86
            },
            {
              "name": "pattern.get",
              "line": 89
            },
            {
              "name": "....append",
              "line": 94
            }
          ],
          "docstring": "Validate pattern features against domain-specific rules",
          "code_snippet": "        self.validation_history = []\n\n    def validate_pattern_features(self, pattern: Dict[str, Any], domain: str) -> Dict[str, Any]:\n        \"\"\"Validate pattern features against domain-specific rules\"\"\"\n        if domain not in self.domain_configs:\n            return {\"valid\": False, \"reason\": \"Unknown domain\"}\n            \n        config = self.domain_configs[domain]\n        result = {\"valid\": True, \"violations\": []}\n        \n        # Check required features\n        for feature in config.required_features:\n            if feature not in pattern.get(\"features\", {}):\n                result[\"valid\"] = False\n                result[\"violations\"].append(f\"Missing required feature: {feature}\")\n                \n        # Check feature ranges\n        for feature, value in pattern.get(\"features\", {}).items():\n            if feature in config.feature_ranges:\n                min_val, max_val = config.feature_ranges[feature]\n                if not min_val <= value <= max_val:\n                    result[\"valid\"] = False\n                    result[\"violations\"].append(\n                        f\"Feature {feature} value {value} outside range [{min_val}, {max_val}]\"\n                    )\n        \n        return result\n\n    def validate_semantic_rules(self, pattern: Dict[str, Any], domain: str) -> Dict[str, Any]:\n        \"\"\"Validate pattern against domain-specific semantic rules\"\"\"\n        if domain not in self.domain_configs:"
        },
        "validate_semantic_rules": {
          "start_line": 100,
          "end_line": 133,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "pattern"
            },
            {
              "name": "domain",
              "type": "str"
            }
          ],
          "return_type": "complex_type",
          "calls": [
            {
              "name": "pattern.get",
              "line": 107
            },
            {
              "name": "abs",
              "line": 112
            },
            {
              "name": "....append",
              "line": 115
            },
            {
              "name": "....append",
              "line": 122
            },
            {
              "name": "....append",
              "line": 129
            }
          ],
          "docstring": "Validate pattern against domain-specific semantic rules",
          "code_snippet": "        return result\n\n    def validate_semantic_rules(self, pattern: Dict[str, Any], domain: str) -> Dict[str, Any]:\n        \"\"\"Validate pattern against domain-specific semantic rules\"\"\"\n        if domain not in self.domain_configs:\n            return {\"valid\": False, \"reason\": \"Unknown domain\"}\n            \n        config = self.domain_configs[domain]\n        result = {\"valid\": True, \"violations\": []}\n        features = pattern.get(\"features\", {})\n        \n        if domain == \"emotional\":\n            # Check intensity-arousal correlation\n            if \"intensity\" in features and \"arousal\" in features:\n                correlation = abs(features[\"intensity\"] - features[\"arousal\"])\n                if correlation > config.semantic_rules[\"intensity_arousal_correlation\"]:\n                    result[\"valid\"] = False\n                    result[\"violations\"].append(\"Intensity-arousal correlation violation\")\n                    \n        elif domain == \"linguistic\":\n            # Check coherence threshold\n            if \"coherence\" in features:\n                if features[\"coherence\"] < config.semantic_rules[\"min_coherence\"]:\n                    result[\"valid\"] = False\n                    result[\"violations\"].append(\"Coherence below minimum threshold\")\n                    \n        elif domain == \"visual\":\n            # Check size-centrality relationship\n            if \"size\" in features and \"centrality\" in features:\n                if features[\"size\"] + features[\"centrality\"] > config.semantic_rules[\"max_size_centrality_sum\"]:\n                    result[\"valid\"] = False\n                    result[\"violations\"].append(\"Size-centrality sum exceeds maximum\")\n        \n        return result\n\n    def validate_transfer_compatibility(self, \n                                     source_domain: str, \n                                     target_domain: str, "
        },
        "validate_transfer_compatibility": {
          "start_line": 133,
          "end_line": 205,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "source_domain",
              "type": "str"
            },
            {
              "name": "target_domain",
              "type": "str"
            },
            {
              "name": "pattern"
            }
          ],
          "return_type": "complex_type",
          "calls": [
            {
              "name": "pattern.get",
              "line": 178
            },
            {
              "name": "mapping.items",
              "line": 181
            },
            {
              "name": "self.validate_pattern_features",
              "line": 186
            },
            {
              "name": "....extend",
              "line": 193
            },
            {
              "name": "np.mean",
              "line": 199
            },
            {
              "name": "....append",
              "line": 174
            },
            {
              "name": "len",
              "line": 198
            },
            {
              "name": "len",
              "line": 198
            },
            {
              "name": "....items",
              "line": 171
            },
            {
              "name": "mapped_features.values",
              "line": 199
            }
          ],
          "docstring": "Validate if pattern transfer between domains is semantically valid",
          "code_snippet": "        return result\n\n    def validate_transfer_compatibility(self, \n                                     source_domain: str, \n                                     target_domain: str, \n                                     pattern: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Validate if pattern transfer between domains is semantically valid\"\"\"\n        result = {\n            \"compatible\": True,\n            \"confidence\": 0.0,\n            \"mappings\": {},\n            \"violations\": []\n        }\n        \n        # Define feature mappings between domains\n        feature_mappings = {\n            (\"emotional\", \"visual\"): {\n                \"intensity\": \"contrast\",\n                \"arousal\": \"size\",\n                \"valence\": \"centrality\"\n            },\n            (\"linguistic\", \"visual\"): {\n                \"complexity\": \"size\",\n                \"coherence\": \"contrast\",\n                \"formality\": \"centrality\"\n            },\n            (\"emotional\", \"linguistic\"): {\n                \"intensity\": \"complexity\",\n                \"valence\": \"formality\",\n                \"arousal\": \"coherence\"\n            }\n        }\n        \n        # Get mapping for this transfer\n        domain_pair = (source_domain, target_domain)\n        reverse_pair = (target_domain, source_domain)\n        \n        if domain_pair in feature_mappings:\n            mapping = feature_mappings[domain_pair]\n        elif reverse_pair in feature_mappings:\n            mapping = {v: k for k, v in feature_mappings[reverse_pair].items()}\n        else:\n            result[\"compatible\"] = False\n            result[\"violations\"].append(\"No valid feature mapping between domains\")\n            return result\n            \n        # Check feature mapping validity\n        features = pattern.get(\"features\", {})\n        mapped_features = {}\n        \n        for source_feat, target_feat in mapping.items():\n            if source_feat in features:\n                mapped_features[target_feat] = features[source_feat]\n                \n        # Validate mapped features against target domain rules\n        target_validation = self.validate_pattern_features(\n            {\"features\": mapped_features}, \n            target_domain\n        )\n        \n        if not target_validation[\"valid\"]:\n            result[\"compatible\"] = False\n            result[\"violations\"].extend(target_validation[\"violations\"])\n        \n        # Calculate transfer confidence\n        if result[\"compatible\"]:\n            # Base confidence on feature coverage and value distributions\n            feature_coverage = len(mapped_features) / len(self.domain_configs[target_domain].required_features)\n            value_distribution = np.mean([v for v in mapped_features.values()])\n            result[\"confidence\"] = (feature_coverage * 0.6) + (value_distribution * 0.4)\n            result[\"mappings\"] = mapping\n            \n        return result\n\n    def run_validation(self, patterns: Dict[str, List[Dict[str, Any]]]) -> Dict[str, Any]:\n        \"\"\"Run complete validation across all domains\"\"\"\n        validation_results = {"
        },
        "run_validation": {
          "start_line": 205,
          "end_line": 283,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "patterns"
            }
          ],
          "return_type": "complex_type",
          "calls": [
            {
              "name": "patterns.items",
              "line": 215
            },
            {
              "name": "patterns.keys",
              "line": 241
            },
            {
              "name": "sum",
              "line": 268
            },
            {
              "name": "sum",
              "line": 269
            },
            {
              "name": "sum",
              "line": 270
            },
            {
              "name": "sum",
              "line": 271
            },
            {
              "name": "self.validation_history.append",
              "line": 280
            },
            {
              "name": "....isoformat",
              "line": 208
            },
            {
              "name": "len",
              "line": 216
            },
            {
              "name": "patterns.keys",
              "line": 244
            },
            {
              "name": "self.validate_pattern_features",
              "line": 221
            },
            {
              "name": "self.validate_semantic_rules",
              "line": 222
            },
            {
              "name": "domain_results.append",
              "line": 232
            },
            {
              "name": "datetime.now",
              "line": 208
            },
            {
              "name": "self.metrics.values",
              "line": 268
            },
            {
              "name": "self.metrics.values",
              "line": 269
            },
            {
              "name": "self.metrics.values",
              "line": 270
            },
            {
              "name": "self.metrics.values",
              "line": 271
            },
            {
              "name": "id",
              "line": 233
            },
            {
              "name": "self.validate_transfer_compatibility",
              "line": 251
            },
            {
              "name": "transfer_results.append",
              "line": 260
            },
            {
              "name": "id",
              "line": 261
            }
          ],
          "docstring": "Run complete validation across all domains",
          "code_snippet": "        return result\n\n    def run_validation(self, patterns: Dict[str, List[Dict[str, Any]]]) -> Dict[str, Any]:\n        \"\"\"Run complete validation across all domains\"\"\"\n        validation_results = {\n            \"timestamp\": datetime.now().isoformat(),\n            \"domain_results\": {},\n            \"cross_domain_results\": {},\n            \"summary\": {}\n        }\n        \n        # Validate patterns within their domains\n        for domain, domain_patterns in patterns.items():\n            self.metrics[domain][\"total_patterns\"] = len(domain_patterns)\n            domain_results = []\n            \n            for pattern in domain_patterns:\n                # Validate features\n                feature_validation = self.validate_pattern_features(pattern, domain)\n                semantic_validation = self.validate_semantic_rules(pattern, domain)\n                \n                if not feature_validation[\"valid\"]:\n                    self.metrics[domain][\"feature_violations\"] += 1\n                if not semantic_validation[\"valid\"]:\n                    self.metrics[domain][\"semantic_violations\"] += 1\n                \n                if feature_validation[\"valid\"] and semantic_validation[\"valid\"]:\n                    self.metrics[domain][\"valid_patterns\"] += 1\n                \n                domain_results.append({\n                    \"pattern_id\": id(pattern),\n                    \"feature_validation\": feature_validation,\n                    \"semantic_validation\": semantic_validation\n                })\n            \n            validation_results[\"domain_results\"][domain] = domain_results\n        \n        # Validate cross-domain transfers\n        for source_domain in patterns.keys():\n            validation_results[\"cross_domain_results\"][source_domain] = {}\n            \n            for target_domain in patterns.keys():\n                if source_domain != target_domain:\n                    self.metrics[source_domain][\"cross_domain_attempts\"] += 1\n                    \n                    # Test transfer compatibility for each pattern\n                    transfer_results = []\n                    for pattern in patterns[source_domain]:\n                        compatibility = self.validate_transfer_compatibility(\n                            source_domain,\n                            target_domain,\n                            pattern\n                        )\n                        \n                        if compatibility[\"compatible\"]:\n                            self.metrics[source_domain][\"successful_transfers\"] += 1\n                            \n                        transfer_results.append({\n                            \"pattern_id\": id(pattern),\n                            \"compatibility\": compatibility\n                        })\n                    \n                    validation_results[\"cross_domain_results\"][source_domain][target_domain] = transfer_results\n        \n        # Calculate summary metrics\n        total_patterns = sum(m[\"total_patterns\"] for m in self.metrics.values())\n        total_valid = sum(m[\"valid_patterns\"] for m in self.metrics.values())\n        total_transfers = sum(m[\"successful_transfers\"] for m in self.metrics.values())\n        total_attempts = sum(m[\"cross_domain_attempts\"] for m in self.metrics.values())\n        \n        validation_results[\"summary\"] = {\n            \"total_patterns_validated\": total_patterns,\n            \"valid_pattern_rate\": total_valid / total_patterns if total_patterns > 0 else 0,\n            \"transfer_success_rate\": total_transfers / total_attempts if total_attempts > 0 else 0,\n            \"domain_metrics\": self.metrics\n        }\n        \n        self.validation_history.append(validation_results)\n        return validation_results\n\n    def save_results(self, results: Dict[str, Any]):\n        \"\"\"Save validation results and generate report\"\"\"\n        timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")"
        },
        "save_results": {
          "start_line": 283,
          "end_line": 320,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "results"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "....strftime",
              "line": 285
            },
            {
              "name": "self.metrics.items",
              "line": 300
            },
            {
              "name": "report_lines.extend",
              "line": 311
            },
            {
              "name": "open",
              "line": 289
            },
            {
              "name": "json.dump",
              "line": 290
            },
            {
              "name": "report_lines.extend",
              "line": 301
            },
            {
              "name": "open",
              "line": 317
            },
            {
              "name": "f.write",
              "line": 318
            },
            {
              "name": "datetime.now",
              "line": 285
            },
            {
              "name": "....join",
              "line": 318
            },
            {
              "name": "domain.upper",
              "line": 302
            }
          ],
          "docstring": "Save validation results and generate report",
          "code_snippet": "        return validation_results\n\n    def save_results(self, results: Dict[str, Any]):\n        \"\"\"Save validation results and generate report\"\"\"\n        timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        \n        # Save detailed results\n        results_file = self.log_dir / f\"validation_results_{timestamp}.json\"\n        with open(results_file, 'w') as f:\n            json.dump(results, f, indent=2)\n            \n        # Generate and save report\n        report_file = self.log_dir / f\"validation_report_{timestamp}.txt\"\n        report_lines = [\n            f\"Domain Validation Report - {timestamp}\",\n            \"=\" * 50,\n            \"\\nDomain-Specific Results:\"\n        ]\n        \n        for domain, metrics in self.metrics.items():\n            report_lines.extend([\n                f\"\\n{domain.upper()}:\",\n                f\"Total Patterns: {metrics['total_patterns']}\",\n                f\"Valid Patterns: {metrics['valid_patterns']}\",\n                f\"Feature Violations: {metrics['feature_violations']}\",\n                f\"Semantic Violations: {metrics['semantic_violations']}\",\n                f\"Transfer Success Rate: {metrics['successful_transfers'] / metrics['cross_domain_attempts']:.2%} \"\n                f\"({metrics['successful_transfers']}/{metrics['cross_domain_attempts']})\"\n            ])\n            \n        report_lines.extend([\n            \"\\nSummary:\",\n            f\"Overall Valid Pattern Rate: {results['summary']['valid_pattern_rate']:.2%}\",\n            f\"Overall Transfer Success Rate: {results['summary']['transfer_success_rate']:.2%}\"\n        ])\n        \n        with open(report_file, 'w') as f:\n            f.write('\\n'.join(report_lines))"
        }
      },
      "class_variables": [],
      "bases": [],
      "docstring": "Validates patterns within their native domains before testing cross-domain transfer"
    }
  },
  "functions": {},
  "constants": {}
}