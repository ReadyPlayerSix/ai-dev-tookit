{
  "path": "D:\\Projects\\isekaiZen\\machine-learning-optimizer\\isekaizen\\core\\optimization\\equilibrium.py",
  "imports": [
    {
      "name": "logging",
      "line": 11
    },
    {
      "name": "typing.Dict",
      "line": 12
    },
    {
      "name": "typing.Any",
      "line": 12
    },
    {
      "name": "typing.Optional",
      "line": 12
    },
    {
      "name": "typing.List",
      "line": 12
    },
    {
      "name": "typing.Set",
      "line": 12
    },
    {
      "name": "typing.Tuple",
      "line": 12
    }
  ],
  "classes": {
    "PatternEquilibriumTracker": {
      "start_line": 16,
      "end_line": 332,
      "methods": {
        "__init__": {
          "start_line": 30,
          "end_line": 75,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "pattern_complexities"
            },
            {
              "name": "pattern_distribution"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "set",
              "line": 55
            },
            {
              "name": "set",
              "line": 56
            },
            {
              "name": "self.min_bounds.copy",
              "line": 62
            },
            {
              "name": "self.max_bounds.copy",
              "line": 63
            },
            {
              "name": "logger.info",
              "line": 69
            },
            {
              "name": "logger.info",
              "line": 70
            },
            {
              "name": "logger.info",
              "line": 72
            },
            {
              "name": "self._calculate_equilibrium_bounds",
              "line": 52
            },
            {
              "name": "....join",
              "line": 71
            },
            {
              "name": "....join",
              "line": 73
            },
            {
              "name": "self.min_bounds.items",
              "line": 71
            },
            {
              "name": "self.max_bounds.items",
              "line": 73
            }
          ],
          "docstring": "\n        Initialize the tracker with pattern data and calculate equilibrium bounds.\n        \n        Args:\n            pattern_complexities: Dictionary of pattern types to complexity scores\n            pattern_distribution: Dictionary of pattern types to their prevalence in the dataset\n        ",
          "code_snippet": "        above_max_bound: Set of patterns currently above maximum bounds (potential overfitting)\n    \"\"\"\n    def __init__(self, pattern_complexities=None, pattern_distribution=None):\n        \"\"\"\n        Initialize the tracker with pattern data and calculate equilibrium bounds.\n        \n        Args:\n            pattern_complexities: Dictionary of pattern types to complexity scores\n            pattern_distribution: Dictionary of pattern types to their prevalence in the dataset\n        \"\"\"\n        # Default pattern types\n        self.default_patterns = ['structural', 'statistical', 'temporal']\n        \n        # Initialize bounds containers\n        self.min_bounds = {}  # Minimum acceptable accuracy\n        self.max_bounds = {}  # Maximum expected accuracy (potential overfitting beyond this)\n        \n        # Initialize with default values\n        for pattern in self.default_patterns:\n            self.min_bounds[pattern] = 0.5  # Default minimum\n            self.max_bounds[pattern] = 0.9  # Default maximum\n        \n        # Calculate equilibrium bounds if data is available\n        if pattern_complexities and pattern_distribution:\n            self._calculate_equilibrium_bounds(pattern_complexities, pattern_distribution)\n            \n        # Track patterns outside of bounds\n        self.below_min_bound = set()\n        self.above_max_bound = set()\n        \n        # History tracking\n        self.bound_status_history = {}  # {epoch: {pattern: {'min': bool, 'max': bool}}}\n        \n        # Track original bounds for reference\n        self.original_min_bounds = self.min_bounds.copy()\n        self.original_max_bounds = self.max_bounds.copy()\n        \n        # Add adjustment factor tracking\n        self.bound_adjustment_factors = {}\n        self.last_train_test_ratio = 1.0  # Initialize with balanced ratio\n        \n        logger.info(\"Pattern Equilibrium Tracker initialized\")\n        logger.info(\"Minimum bounds (underfitting threshold): \" + \n                    \", \".join([f\"{p}: {v:.2f}\" for p, v in self.min_bounds.items()]))\n        logger.info(\"Maximum bounds (overfitting threshold): \" + \n                    \", \".join([f\"{p}: {v:.2f}\" for p, v in self.max_bounds.items()]))\n    \n    def _calculate_equilibrium_bounds(self, complexities, distribution):\n        \"\"\"\n        Calculate equilibrium bounds based on pattern complexity and prevalence."
        },
        "_calculate_equilibrium_bounds": {
          "start_line": 75,
          "end_line": 123,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "complexities"
            },
            {
              "name": "distribution"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "max",
              "line": 97
            },
            {
              "name": "max",
              "line": 105
            },
            {
              "name": "max",
              "line": 111
            },
            {
              "name": "min",
              "line": 117
            },
            {
              "name": "min",
              "line": 97
            },
            {
              "name": "len",
              "line": 100
            },
            {
              "name": "min",
              "line": 105
            },
            {
              "name": "min",
              "line": 111
            },
            {
              "name": "max",
              "line": 117
            },
            {
              "name": "isinstance",
              "line": 91
            },
            {
              "name": "max",
              "line": 109
            },
            {
              "name": "isinstance",
              "line": 94
            }
          ],
          "docstring": "\n        Calculate equilibrium bounds based on pattern complexity and prevalence.\n        \n        Args:\n            complexities: Dictionary of pattern types to complexity scores\n            distribution: Dictionary of pattern types to their prevalence\n        ",
          "code_snippet": "                    \", \".join([f\"{p}: {v:.2f}\" for p, v in self.max_bounds.items()]))\n    \n    def _calculate_equilibrium_bounds(self, complexities, distribution):\n        \"\"\"\n        Calculate equilibrium bounds based on pattern complexity and prevalence.\n        \n        Args:\n            complexities: Dictionary of pattern types to complexity scores\n            distribution: Dictionary of pattern types to their prevalence\n        \"\"\"\n        # Base parameters\n        base_min_rate = 0.4  # Base minimum accuracy\n        \n        # Process each pattern\n        for pattern in self.default_patterns:\n            # Extract complexity value\n            complexity = 0.1  # Default low complexity\n            if pattern in complexities:\n                if isinstance(complexities[pattern], dict) and 'avg_complexity' in complexities[pattern]:\n                    complexity = complexities[pattern]['avg_complexity']\n                else:\n                    complexity = complexities[pattern] if isinstance(complexities[pattern], (int, float)) else 0.1\n            \n            # Ensure complexity is in reasonable range (0.05-0.95)\n            complexity = max(0.05, min(0.95, complexity))\n            \n            # Extract prevalence value\n            prevalence = 1.0 / len(self.default_patterns)  # Default equal distribution\n            if pattern in distribution:\n                prevalence = distribution[pattern]\n            \n            # Ensure prevalence is in reasonable range (0.05-0.95)\n            prevalence = max(0.05, min(0.95, prevalence))\n            \n            # Calculate minimum acceptable accuracy\n            # Higher prevalence and lower complexity patterns should have higher minimum accuracy\n            min_accuracy = base_min_rate + (prevalence / max(complexity * 2, 0.1))\n            # Cap at reasonable value\n            min_accuracy = max(0.4, min(0.75, min_accuracy))\n            \n            # Calculate maximum expected accuracy beyond which is likely overfitting\n            # Lower prevalence and higher complexity should have lower maximum accuracy\n            max_accuracy = 1.0 - ((1.0 - prevalence) * complexity)\n            # Ensure reasonable range with safety margin\n            max_accuracy = min(0.98, max(min_accuracy + 0.1, max_accuracy))\n            \n            # Store the calculated bounds\n            self.min_bounds[pattern] = min_accuracy\n            self.max_bounds[pattern] = max_accuracy\n    \n    def update_pattern_statuses(self, epoch: int, pattern_accuracies: Dict[str, float], \n                               train_acc: Optional[float] = None, \n                               test_acc: Optional[float] = None) -> Dict[str, Dict[str, bool]]:"
        },
        "update_pattern_statuses": {
          "start_line": 123,
          "end_line": 185,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "epoch",
              "type": "int"
            },
            {
              "name": "pattern_accuracies"
            },
            {
              "name": "train_acc"
            },
            {
              "name": "test_acc"
            }
          ],
          "return_type": "complex_type",
          "calls": [
            {
              "name": "self.below_min_bound.clear",
              "line": 141
            },
            {
              "name": "self.above_max_bound.clear",
              "line": 142
            },
            {
              "name": "self.min_bounds.keys",
              "line": 150
            },
            {
              "name": "status_map.items",
              "line": 173
            },
            {
              "name": "self.adjust_bounds_for_train_test_ratio",
              "line": 146
            },
            {
              "name": "self.below_min_bound.add",
              "line": 165
            },
            {
              "name": "self.above_max_bound.add",
              "line": 167
            },
            {
              "name": "logger.info",
              "line": 179
            },
            {
              "name": "logger.info",
              "line": 181
            }
          ],
          "docstring": "\n        Update pattern statuses based on current accuracies against bounds.\n        If train_acc and test_acc are provided, dynamically adjusts bounds based on train/test ratio.\n        \n        Args:\n            epoch: Current epoch number\n            pattern_accuracies: Dictionary of pattern types to their accuracies (0.0-1.0)\n            train_acc: Optional overall training accuracy (0-100 scale)\n            test_acc: Optional overall test/validation accuracy (0-100 scale)\n            \n        Returns:\n            Dictionary of pattern types to status indicators {'min': bool, 'max': bool}\n            where 'min': True means above min bound, 'max': True means below max bound\n        ",
          "code_snippet": "            self.max_bounds[pattern] = max_accuracy\n    \n    def update_pattern_statuses(self, epoch: int, pattern_accuracies: Dict[str, float], \n                               train_acc: Optional[float] = None, \n                               test_acc: Optional[float] = None) -> Dict[str, Dict[str, bool]]:\n        \"\"\"\n        Update pattern statuses based on current accuracies against bounds.\n        If train_acc and test_acc are provided, dynamically adjusts bounds based on train/test ratio.\n        \n        Args:\n            epoch: Current epoch number\n            pattern_accuracies: Dictionary of pattern types to their accuracies (0.0-1.0)\n            train_acc: Optional overall training accuracy (0-100 scale)\n            test_acc: Optional overall test/validation accuracy (0-100 scale)\n            \n        Returns:\n            Dictionary of pattern types to status indicators {'min': bool, 'max': bool}\n            where 'min': True means above min bound, 'max': True means below max bound\n        \"\"\"\n        # Clear current sets\n        self.below_min_bound.clear()\n        self.above_max_bound.clear()\n        \n        # Adjust bounds based on train/test ratio if provided\n        if train_acc is not None and test_acc is not None:\n            self.adjust_bounds_for_train_test_ratio(epoch, train_acc, test_acc)\n        \n        # Determine current status\n        status_map = {}\n        for pattern in self.min_bounds.keys():\n            if pattern in pattern_accuracies:\n                accuracy = pattern_accuracies[pattern]\n                \n                # Check bounds\n                above_min = accuracy >= self.min_bounds[pattern]\n                below_max = accuracy <= self.max_bounds[pattern]\n                \n                status_map[pattern] = {\n                    'min': above_min,\n                    'max': below_max\n                }\n                \n                # Track patterns outside of bounds\n                if not above_min:\n                    self.below_min_bound.add(pattern)\n                if not below_max:\n                    self.above_max_bound.add(pattern)\n        \n        # Store in history\n        self.bound_status_history[epoch] = status_map\n        \n        # Log only when patterns cross bounds\n        for pattern, status in status_map.items():\n            if pattern in pattern_accuracies:\n                accuracy = pattern_accuracies[pattern]\n                \n                # Check for bound crossings\n                if not status['min']:\n                    logger.info(f\"Pattern {pattern} below minimum bound: {accuracy:.2f} < {self.min_bounds[pattern]:.2f}\")\n                if not status['max']:\n                    logger.info(f\"Pattern {pattern} above maximum bound: {accuracy:.2f} > {self.max_bounds[pattern]:.2f}\")\n        \n        return status_map\n    \n    def get_patterns_below_min(self) -> Set[str]:\n        \"\"\"\n        Get the set of patterns currently below minimum bounds (underfitting)."
        },
        "get_patterns_below_min": {
          "start_line": 185,
          "end_line": 194,
          "parameters": [
            {
              "name": "self"
            }
          ],
          "return_type": "complex_type",
          "calls": [],
          "docstring": "\n        Get the set of patterns currently below minimum bounds (underfitting).\n        \n        Returns:\n            Set of pattern types below minimum bounds\n        ",
          "code_snippet": "        return status_map\n    \n    def get_patterns_below_min(self) -> Set[str]:\n        \"\"\"\n        Get the set of patterns currently below minimum bounds (underfitting).\n        \n        Returns:\n            Set of pattern types below minimum bounds\n        \"\"\"\n        return self.below_min_bound\n    \n    def get_patterns_above_max(self) -> Set[str]:\n        \"\"\"\n        Get the set of patterns currently above maximum bounds (potential overfitting)."
        },
        "get_patterns_above_max": {
          "start_line": 194,
          "end_line": 203,
          "parameters": [
            {
              "name": "self"
            }
          ],
          "return_type": "complex_type",
          "calls": [],
          "docstring": "\n        Get the set of patterns currently above maximum bounds (potential overfitting).\n        \n        Returns:\n            Set of pattern types above maximum bounds\n        ",
          "code_snippet": "        return self.below_min_bound\n    \n    def get_patterns_above_max(self) -> Set[str]:\n        \"\"\"\n        Get the set of patterns currently above maximum bounds (potential overfitting).\n        \n        Returns:\n            Set of pattern types above maximum bounds\n        \"\"\"\n        return self.above_max_bound\n    \n    def get_bounds_for_pattern(self, pattern_type: str) -> Tuple[float, float]:\n        \"\"\"\n        Get the min and max bounds for a specific pattern."
        },
        "get_bounds_for_pattern": {
          "start_line": 203,
          "end_line": 217,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "pattern_type",
              "type": "str"
            }
          ],
          "return_type": "complex_type",
          "calls": [
            {
              "name": "self.min_bounds.get",
              "line": 213
            },
            {
              "name": "self.max_bounds.get",
              "line": 214
            }
          ],
          "docstring": "\n        Get the min and max bounds for a specific pattern.\n        \n        Args:\n            pattern_type: Pattern type to get bounds for\n            \n        Returns:\n            Tuple of (min_bound, max_bound)\n        ",
          "code_snippet": "        return self.above_max_bound\n    \n    def get_bounds_for_pattern(self, pattern_type: str) -> Tuple[float, float]:\n        \"\"\"\n        Get the min and max bounds for a specific pattern.\n        \n        Args:\n            pattern_type: Pattern type to get bounds for\n            \n        Returns:\n            Tuple of (min_bound, max_bound)\n        \"\"\"\n        min_bound = self.min_bounds.get(pattern_type, 0.5)\n        max_bound = self.max_bounds.get(pattern_type, 0.9)\n        return (min_bound, max_bound)\n    \n    def get_bounds_status_history(self) -> Dict[int, Dict[str, Dict[str, bool]]]:\n        \"\"\"\n        Get the history of bounds statuses for visualization."
        },
        "get_bounds_status_history": {
          "start_line": 217,
          "end_line": 226,
          "parameters": [
            {
              "name": "self"
            }
          ],
          "return_type": "complex_type",
          "calls": [],
          "docstring": "\n        Get the history of bounds statuses for visualization.\n        \n        Returns:\n            Dictionary mapping epochs to pattern status maps\n        ",
          "code_snippet": "        return (min_bound, max_bound)\n    \n    def get_bounds_status_history(self) -> Dict[int, Dict[str, Dict[str, bool]]]:\n        \"\"\"\n        Get the history of bounds statuses for visualization.\n        \n        Returns:\n            Dictionary mapping epochs to pattern status maps\n        \"\"\"\n        return self.bound_status_history\n        \n    def get_bounds_adjustment_history(self) -> Dict[int, float]:\n        \"\"\"\n        Get the history of bound adjustment factors (train/test ratios)."
        },
        "get_bounds_adjustment_history": {
          "start_line": 226,
          "end_line": 235,
          "parameters": [
            {
              "name": "self"
            }
          ],
          "return_type": "complex_type",
          "calls": [],
          "docstring": "\n        Get the history of bound adjustment factors (train/test ratios).\n        \n        Returns:\n            Dictionary mapping epochs to adjustment factors\n        ",
          "code_snippet": "        return self.bound_status_history\n        \n    def get_bounds_adjustment_history(self) -> Dict[int, float]:\n        \"\"\"\n        Get the history of bound adjustment factors (train/test ratios).\n        \n        Returns:\n            Dictionary mapping epochs to adjustment factors\n        \"\"\"\n        return self.bound_adjustment_factors\n        \n    def get_current_bounds(self) -> Dict[str, Dict[str, float]]:\n        \"\"\"\n        Get the current bounds for all patterns with their adjustment status."
        },
        "get_current_bounds": {
          "start_line": 235,
          "end_line": 264,
          "parameters": [
            {
              "name": "self"
            }
          ],
          "return_type": "complex_type",
          "calls": [
            {
              "name": "self.min_bounds.keys",
              "line": 243
            },
            {
              "name": "self.min_bounds.get",
              "line": 245
            },
            {
              "name": "self.max_bounds.get",
              "line": 246
            },
            {
              "name": "self.original_min_bounds.get",
              "line": 247
            },
            {
              "name": "self.original_max_bounds.get",
              "line": 248
            },
            {
              "name": "max",
              "line": 251
            },
            {
              "name": "max",
              "line": 252
            }
          ],
          "docstring": "\n        Get the current bounds for all patterns with their adjustment status.\n        \n        Returns:\n            Dictionary mapping pattern types to bound information\n        ",
          "code_snippet": "        return self.bound_adjustment_factors\n        \n    def get_current_bounds(self) -> Dict[str, Dict[str, float]]:\n        \"\"\"\n        Get the current bounds for all patterns with their adjustment status.\n        \n        Returns:\n            Dictionary mapping pattern types to bound information\n        \"\"\"\n        result = {}\n        for pattern in self.min_bounds.keys():\n            # Get current and original bounds\n            current_min = self.min_bounds.get(pattern, 0.5)\n            current_max = self.max_bounds.get(pattern, 0.9)\n            original_min = self.original_min_bounds.get(pattern, 0.5)\n            original_max = self.original_max_bounds.get(pattern, 0.9)\n            \n            # Calculate adjustment percentages\n            min_adjustment = (current_min - original_min) / max(0.01, original_min) * 100\n            max_adjustment = (current_max - original_max) / max(0.01, original_max) * 100\n            \n            result[pattern] = {\n                'min': current_min,\n                'max': current_max,\n                'original_min': original_min,\n                'original_max': original_max,\n                'min_adjustment_pct': min_adjustment,\n                'max_adjustment_pct': max_adjustment\n            }\n        return result\n        \n    def adjust_bounds_for_train_test_ratio(self, epoch: int, train_acc: float, test_acc: float) -> None:\n        \"\"\"\n        Dynamically adjust equilibrium bounds based on train/test accuracy ratio."
        },
        "adjust_bounds_for_train_test_ratio": {
          "start_line": 264,
          "end_line": 332,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "epoch",
              "type": "int"
            },
            {
              "name": "train_acc",
              "type": "float"
            },
            {
              "name": "test_acc",
              "type": "float"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "max",
              "line": 287
            },
            {
              "name": "self.max_bounds.keys",
              "line": 297
            },
            {
              "name": "logger.info",
              "line": 312
            },
            {
              "name": "logger.info",
              "line": 313
            },
            {
              "name": "logger.info",
              "line": 314
            },
            {
              "name": "min",
              "line": 287
            },
            {
              "name": "self.original_max_bounds.get",
              "line": 299
            },
            {
              "name": "self.min_bounds.get",
              "line": 305
            },
            {
              "name": "max",
              "line": 306
            },
            {
              "name": "self.max_bounds.keys",
              "line": 319
            },
            {
              "name": "logger.info",
              "line": 330
            },
            {
              "name": "....join",
              "line": 315
            },
            {
              "name": "self.original_max_bounds.get",
              "line": 321
            },
            {
              "name": "self.max_bounds.get",
              "line": 322
            },
            {
              "name": "min",
              "line": 328
            },
            {
              "name": "self.max_bounds.items",
              "line": 315
            }
          ],
          "docstring": "\n        Dynamically adjust equilibrium bounds based on train/test accuracy ratio.\n        When train accuracy exceeds test accuracy, tighten the bounds to prevent overfitting.\n        \n        Args:\n            epoch: Current epoch number\n            train_acc: Current training accuracy (0-100 scale)\n            test_acc: Current test/validation accuracy (0-100 scale)\n        ",
          "code_snippet": "        return result\n        \n    def adjust_bounds_for_train_test_ratio(self, epoch: int, train_acc: float, test_acc: float) -> None:\n        \"\"\"\n        Dynamically adjust equilibrium bounds based on train/test accuracy ratio.\n        When train accuracy exceeds test accuracy, tighten the bounds to prevent overfitting.\n        \n        Args:\n            epoch: Current epoch number\n            train_acc: Current training accuracy (0-100 scale)\n            test_acc: Current test/validation accuracy (0-100 scale)\n        \"\"\"\n        # Calculate train/test ratio (ensuring we don't divide by zero)\n        if test_acc < 0.1:\n            test_acc = 0.1  # Floor to prevent division issues\n        \n        train_test_ratio = train_acc / test_acc\n        self.last_train_test_ratio = train_test_ratio\n        \n        # Store adjustment factor for this epoch\n        self.bound_adjustment_factors[epoch] = train_test_ratio\n        \n        # Only tighten bounds when train accuracy exceeds test accuracy\n        if train_test_ratio > 1.0:\n            # Calculate adjustment factor - more aggressive as gap widens\n            adjustment_factor = max(0.0, min(0.3, (train_test_ratio - 1.0) * 1.5))\n            \n            # Apply more aggressive adjustment when the gap is growing\n            if epoch > 0 and epoch-1 in self.bound_adjustment_factors:\n                previous_ratio = self.bound_adjustment_factors[epoch-1]\n                if train_test_ratio > previous_ratio:\n                    # Gap is growing - intensify adjustment\n                    adjustment_factor *= 1.5\n            \n            # Apply adjustment to max bounds (tighten)\n            for pattern in self.max_bounds.keys():\n                # Start from original bounds for stability\n                original_max = self.original_max_bounds.get(pattern, 0.9)\n                \n                # Calculate new max bound - tighter when ratio is higher\n                new_max_bound = original_max - (original_max * adjustment_factor)\n                \n                # Ensure bound doesn't go too low\n                min_bound = self.min_bounds.get(pattern, 0.5)\n                new_max_bound = max(min_bound + 0.05, new_max_bound)  # Ensure at least 5% gap\n                \n                # Update the bound\n                self.max_bounds[pattern] = new_max_bound\n            \n            # Log the adjustment\n            logger.info(f\"Adjusted equilibrium bounds for train/test ratio {train_test_ratio:.3f}\")\n            logger.info(f\"  Applied adjustment factor: {adjustment_factor:.3f}\")\n            logger.info(\"  New maximum bounds: \" + \n                       \", \".join([f\"{p}: {v:.2f}\" for p, v in self.max_bounds.items()]))\n        elif train_test_ratio < 0.8:  # Allow slight relaxation when test significantly exceeds train\n            # When test accuracy is higher than train, we can relax bounds slightly\n            # This promotes more exploration without the risk of overfitting\n            for pattern in self.max_bounds.keys():\n                # Relax bound slightly toward original\n                original_max = self.original_max_bounds.get(pattern, 0.9)\n                current_max = self.max_bounds.get(pattern, original_max)\n                \n                # Move 10% back toward original bound\n                self.max_bounds[pattern] = current_max + (original_max - current_max) * 0.1\n                \n                # Cap at original bound\n                self.max_bounds[pattern] = min(self.max_bounds[pattern], original_max)\n            \n            logger.info(f\"Slightly relaxed bounds for good train/test ratio {train_test_ratio:.3f}\")"
        }
      },
      "class_variables": [],
      "bases": [],
      "docstring": "\n    Tracks pattern learning against calculated equilibrium bounds.\n    \n    This class calculates min/max accuracy bounds for each pattern based on\n    complexity and prevalence, then monitors pattern learning against these bounds.\n    The bounds are dynamically adjusted based on train/test accuracy ratios to prevent overfitting.\n    \n    Attributes:\n        min_bounds: Dictionary mapping pattern types to minimum acceptable accuracy\n        max_bounds: Dictionary mapping pattern types to maximum expected accuracy\n        below_min_bound: Set of patterns currently below minimum bounds (underfitting)\n        above_max_bound: Set of patterns currently above maximum bounds (potential overfitting)\n    "
    }
  },
  "functions": {},
  "constants": {}
}