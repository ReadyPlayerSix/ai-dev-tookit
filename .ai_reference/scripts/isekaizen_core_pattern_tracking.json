{
  "path": "D:\\Projects\\isekaiZen\\machine-learning-optimizer\\isekaizen\\core\\pattern\\tracking.py",
  "imports": [
    {
      "name": "logging",
      "line": 11
    },
    {
      "name": "torch",
      "line": 12
    },
    {
      "name": "typing.Dict",
      "line": 13
    },
    {
      "name": "typing.Any",
      "line": 13
    },
    {
      "name": "typing.List",
      "line": 13
    },
    {
      "name": "typing.Optional",
      "line": 13
    },
    {
      "name": "typing.Set",
      "line": 13
    },
    {
      "name": "typing.Tuple",
      "line": 13
    },
    {
      "name": "isekaizen.core.pattern.recognition.recognize_patterns",
      "line": 110
    }
  ],
  "classes": {
    "PatternTracker": {
      "start_line": 47,
      "end_line": 334,
      "methods": {
        "__init__": {
          "start_line": 63,
          "end_line": 90,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "pattern_map"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "logger.debug",
              "line": 88
            },
            {
              "name": "self._initialize_from_pattern_map",
              "line": 86
            }
          ],
          "docstring": "\n        Initialize the pattern tracker.\n        \n        Args:\n            pattern_map: Optional pattern map for pattern type lookup\n        ",
          "code_snippet": "    \"\"\"\n    \n    def __init__(self, pattern_map: Optional[Dict[str, Any]] = None):\n        \"\"\"\n        Initialize the pattern tracker.\n        \n        Args:\n            pattern_map: Optional pattern map for pattern type lookup\n        \"\"\"\n        # Initialize with default pattern types\n        self.pattern_types = ['structural', 'statistical', 'temporal']\n        \n        # Counter dictionaries\n        self.pattern_correct = {p: 0 for p in self.pattern_types}\n        self.pattern_total = {p: 0 for p in self.pattern_types}\n        \n        # Metric dictionaries\n        self.pattern_accuracies = {p: 0.7 for p in self.pattern_types}  # Default initial accuracy\n        self.pattern_risks = {p: 0.3 for p in self.pattern_types}       # Default initial risk\n        \n        # Pattern recognition service\n        self.pattern_service = None\n        \n        # Initialize with pattern map if provided\n        if pattern_map:\n            self._initialize_from_pattern_map(pattern_map)\n            \n        logger.debug(f\"PatternTracker initialized with pattern types: {self.pattern_types}\")\n    \n    def _initialize_from_pattern_map(self, pattern_map: Dict[str, Any]) -> None:\n        \"\"\"\n        Initialize the tracker using the provided pattern map."
        },
        "_initialize_from_pattern_map": {
          "start_line": 90,
          "end_line": 119,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "pattern_map"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "list",
              "line": 99
            },
            {
              "name": "recognize_patterns",
              "line": 114
            },
            {
              "name": "result.get",
              "line": 115
            },
            {
              "name": "....keys",
              "line": 99
            }
          ],
          "docstring": "\n        Initialize the tracker using the provided pattern map.\n        \n        Args:\n            pattern_map: Pattern map containing pattern information\n        ",
          "code_snippet": "        logger.debug(f\"PatternTracker initialized with pattern types: {self.pattern_types}\")\n    \n    def _initialize_from_pattern_map(self, pattern_map: Dict[str, Any]) -> None:\n        \"\"\"\n        Initialize the tracker using the provided pattern map.\n        \n        Args:\n            pattern_map: Pattern map containing pattern information\n        \"\"\"\n        # Check for pattern distribution to get available pattern types\n        if 'pattern_distribution' in pattern_map:\n            pattern_types = list(pattern_map['pattern_distribution'].keys())\n            if pattern_types:\n                self.pattern_types = pattern_types\n                \n                # Reinitialize counters and metrics\n                self.pattern_correct = {p: 0 for p in self.pattern_types}\n                self.pattern_total = {p: 0 for p in self.pattern_types}\n                self.pattern_accuracies = {p: 0.7 for p in self.pattern_types}\n                self.pattern_risks = {p: 0.3 for p in self.pattern_types}\n        \n        # Set up pattern recognition service for index -> pattern type mapping\n        from isekaizen.core.pattern.recognition import recognize_patterns\n        \n        # Create service function\n        def pattern_type_lookup(idx):\n            result = recognize_patterns([idx], pattern_map)\n            return result.get(idx, 'statistical')\n        \n        self.pattern_service = pattern_type_lookup\n    \n    def update_from_batch(self, batch_indices: List[int], correct_mask) -> None:\n        \"\"\"\n        Update pattern tracking with batch recognition results."
        },
        "update_from_batch": {
          "start_line": 119,
          "end_line": 192,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "batch_indices"
            },
            {
              "name": "correct_mask"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "isinstance",
              "line": 133
            },
            {
              "name": "enumerate",
              "line": 155
            },
            {
              "name": "self._recalculate_metrics",
              "line": 190
            },
            {
              "name": "logger.warning",
              "line": 129
            },
            {
              "name": "....tolist",
              "line": 134
            },
            {
              "name": "logger.warning",
              "line": 137
            },
            {
              "name": "len",
              "line": 140
            },
            {
              "name": "len",
              "line": 140
            },
            {
              "name": "logger.warning",
              "line": 141
            },
            {
              "name": "min",
              "line": 144
            },
            {
              "name": "logger.warning",
              "line": 150
            },
            {
              "name": "....join",
              "line": 186
            },
            {
              "name": "logger.debug",
              "line": 187
            },
            {
              "name": "len",
              "line": 144
            },
            {
              "name": "len",
              "line": 144
            },
            {
              "name": "self.pattern_service",
              "line": 158
            },
            {
              "name": "....cpu",
              "line": 134
            },
            {
              "name": "pattern_counts.get",
              "line": 165
            },
            {
              "name": "logger.debug",
              "line": 169
            },
            {
              "name": "self.pattern_types.append",
              "line": 170
            },
            {
              "name": "logger.warning",
              "line": 181
            },
            {
              "name": "len",
              "line": 141
            },
            {
              "name": "len",
              "line": 142
            },
            {
              "name": "pattern_counts.items",
              "line": 186
            },
            {
              "name": "correct_mask.detach",
              "line": 134
            },
            {
              "name": "str",
              "line": 181
            }
          ],
          "docstring": "\n        Update pattern tracking with batch recognition results.\n        \n        Args:\n            batch_indices: List of data indices in the current batch\n            correct_mask: Boolean tensor or list indicating correctness for each index\n        ",
          "code_snippet": "        self.pattern_service = pattern_type_lookup\n    \n    def update_from_batch(self, batch_indices: List[int], correct_mask) -> None:\n        \"\"\"\n        Update pattern tracking with batch recognition results.\n        \n        Args:\n            batch_indices: List of data indices in the current batch\n            correct_mask: Boolean tensor or list indicating correctness for each index\n        \"\"\"\n        # Validate inputs\n        if not batch_indices:\n            logger.warning(\"Empty batch indices received for pattern tracking\")\n            return\n            \n        # Convert tensor to list if needed\n        if isinstance(correct_mask, torch.Tensor):\n            correct_mask = correct_mask.detach().cpu().tolist()\n            \n        if not correct_mask:\n            logger.warning(\"Empty correct mask received for pattern tracking\")\n            return\n        \n        if len(batch_indices) != len(correct_mask):\n            logger.warning(f\"Mismatch between batch indices ({len(batch_indices)}) \"\n                         f\"and correct mask ({len(correct_mask)})\")\n            # Truncate to shorter length\n            length = min(len(batch_indices), len(correct_mask))\n            batch_indices = batch_indices[:length]\n            correct_mask = correct_mask[:length]\n        \n        # Skip tracking if no pattern service available\n        if not self.pattern_service:\n            logger.warning(\"No pattern service available for pattern tracking\")\n            return\n        \n        # Track pattern-specific metrics\n        pattern_counts = {}\n        for i, idx in enumerate(batch_indices):\n            # Get pattern type for this example\n            try:\n                pattern_type = self.pattern_service(idx)\n                \n                # Skip if pattern type is invalid\n                if not pattern_type:\n                    continue\n                    \n                # Track pattern counts\n                pattern_counts[pattern_type] = pattern_counts.get(pattern_type, 0) + 1\n                \n                # Ensure pattern type is tracked\n                if pattern_type not in self.pattern_types:\n                    logger.debug(f\"Adding new pattern type to tracking: {pattern_type}\")\n                    self.pattern_types.append(pattern_type)\n                    self.pattern_correct[pattern_type] = 0\n                    self.pattern_total[pattern_type] = 0\n                    self.pattern_accuracies[pattern_type] = 0.5  # Initial default\n                    self.pattern_risks[pattern_type] = 0.5       # Initial default\n                \n                # Update counters\n                self.pattern_total[pattern_type] += 1\n                if correct_mask[i]:\n                    self.pattern_correct[pattern_type] += 1\n            except Exception as e:\n                logger.warning(f\"Error processing example {idx} for pattern tracking: {str(e)}\")\n                continue\n        \n        # Log pattern distribution in this batch\n        if pattern_counts:\n            pattern_str = \", \".join([f\"{k}: {v}\" for k, v in pattern_counts.items()])\n            logger.debug(f\"Pattern distribution in batch: {pattern_str}\")\n        \n        # Recalculate metrics\n        self._recalculate_metrics()\n    \n    def _recalculate_metrics(self) -> None:\n        \"\"\"Recalculate pattern accuracies and risks from counters.\"\"\"\n        # Check if we have any data"
        },
        "_recalculate_metrics": {
          "start_line": 192,
          "end_line": 227,
          "parameters": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "any",
              "line": 195
            },
            {
              "name": "logger.warning",
              "line": 198
            },
            {
              "name": "max",
              "line": 213
            },
            {
              "name": "logger.debug",
              "line": 216
            },
            {
              "name": "self.pattern_total.get",
              "line": 195
            },
            {
              "name": "min",
              "line": 213
            },
            {
              "name": "logger.warning",
              "line": 223
            }
          ],
          "docstring": "Recalculate pattern accuracies and risks from counters.",
          "code_snippet": "        self._recalculate_metrics()\n    \n    def _recalculate_metrics(self) -> None:\n        \"\"\"Recalculate pattern accuracies and risks from counters.\"\"\"\n        # Check if we have any data\n        has_data = any(self.pattern_total.get(p, 0) > 0 for p in self.pattern_types)\n            \n        if not has_data:\n            logger.warning(\"No pattern recognition data available for metric calculation\")\n            # Set default values\n            for pattern_type in self.pattern_types:\n                self.pattern_accuracies[pattern_type] = 0.7  # Default accuracy\n                self.pattern_risks[pattern_type] = 0.3      # Default risk\n            return\n        \n        # Calculate metrics for each pattern type\n        for pattern_type in self.pattern_types:\n            if pattern_type in self.pattern_total and self.pattern_total[pattern_type] > 0:\n                # Calculate accuracy from recognition metrics\n                accuracy = self.pattern_correct[pattern_type] / self.pattern_total[pattern_type]\n                self.pattern_accuracies[pattern_type] = accuracy\n                \n                # Calculate derived risk\n                self.pattern_risks[pattern_type] = max(0.1, min(0.9, 1.0 - accuracy))\n                \n                # Log updated metrics for debugging\n                logger.debug(f\"Pattern '{pattern_type}': \"\n                           f\"accuracy={accuracy:.4f}, \"\n                           f\"risk={self.pattern_risks[pattern_type]:.4f}, \"\n                           f\"count={self.pattern_total[pattern_type]}\")\n            else:\n                # Ensure we have values\n                if pattern_type not in self.pattern_accuracies or pattern_type not in self.pattern_risks:\n                    logger.warning(f\"No data for pattern '{pattern_type}', using default values\")\n                    self.pattern_accuracies[pattern_type] = 0.7  # Default accuracy\n                    self.pattern_risks[pattern_type] = 0.3      # Default risk\n    \n    def end_epoch(self) -> Dict[str, Dict[str, float]]:\n        \"\"\"\n        Process the end of an epoch and return final metrics."
        },
        "end_epoch": {
          "start_line": 227,
          "end_line": 269,
          "parameters": [
            {
              "name": "self"
            }
          ],
          "return_type": "complex_type",
          "calls": [
            {
              "name": "logger.info",
              "line": 235
            },
            {
              "name": "self._recalculate_metrics",
              "line": 250
            },
            {
              "name": "logger.info",
              "line": 253
            },
            {
              "name": "logger.warning",
              "line": 247
            },
            {
              "name": "self.pattern_accuracies.get",
              "line": 255
            },
            {
              "name": "self.pattern_risks.get",
              "line": 256
            },
            {
              "name": "logger.info",
              "line": 257
            },
            {
              "name": "self.get_pattern_accuracies",
              "line": 266
            },
            {
              "name": "self.get_pattern_risks",
              "line": 267
            },
            {
              "name": "self.pattern_total.get",
              "line": 239
            },
            {
              "name": "self.pattern_total.get",
              "line": 241
            },
            {
              "name": "self.pattern_correct.get",
              "line": 242
            },
            {
              "name": "logger.info",
              "line": 244
            }
          ],
          "docstring": "\n        Process the end of an epoch and return final metrics.\n        \n        Returns:\n            Dictionary with pattern type metrics\n        ",
          "code_snippet": "                    self.pattern_risks[pattern_type] = 0.3      # Default risk\n    \n    def end_epoch(self) -> Dict[str, Dict[str, float]]:\n        \"\"\"\n        Process the end of an epoch and return final metrics.\n        \n        Returns:\n            Dictionary with pattern type metrics\n        \"\"\"\n        # Log current state\n        logger.info(\"Processing end of epoch in pattern tracker\")\n        has_data = False\n        \n        for pattern_type in self.pattern_types:\n            if self.pattern_total.get(pattern_type, 0) > 0:\n                has_data = True\n                total = self.pattern_total.get(pattern_type, 0)\n                correct = self.pattern_correct.get(pattern_type, 0)\n                accuracy_pct = 100.0 * correct / total if total > 0 else 0.0\n                logger.info(f\"  Pattern '{pattern_type}': {correct}/{total} correct ({accuracy_pct:.1f}%)\")\n                \n        if not has_data:\n            logger.warning(\"No pattern data accumulated during epoch\")\n        \n        # Recalculate metrics\n        self._recalculate_metrics()\n        \n        # Log final metrics\n        logger.info(\"Final pattern metrics:\")\n        for pattern_type in self.pattern_types:\n            acc = self.pattern_accuracies.get(pattern_type, 0.0)\n            risk = self.pattern_risks.get(pattern_type, 1.0)\n            logger.info(f\"  '{pattern_type}' - accuracy: {acc:.4f}, risk: {risk:.4f}\")\n        \n        # Reset counters but keep the accumulated metrics\n        for pattern_type in self.pattern_types:\n            self.pattern_correct[pattern_type] = 0\n            self.pattern_total[pattern_type] = 0\n        \n        # Return metrics dictionary\n        return {\n            'accuracies': self.get_pattern_accuracies(),\n            'risks': self.get_pattern_risks()\n        }\n    \n    def get_pattern_accuracies(self) -> Dict[str, float]:\n        \"\"\""
        },
        "get_pattern_accuracies": {
          "start_line": 270,
          "end_line": 279,
          "parameters": [
            {
              "name": "self"
            }
          ],
          "return_type": "complex_type",
          "calls": [],
          "docstring": "\n        Get current pattern-specific accuracies.\n        \n        Returns:\n            Dictionary mapping pattern types to their accuracies\n        ",
          "code_snippet": "        }\n    \n    def get_pattern_accuracies(self) -> Dict[str, float]:\n        \"\"\"\n        Get current pattern-specific accuracies.\n        \n        Returns:\n            Dictionary mapping pattern types to their accuracies\n        \"\"\"\n        return self.pattern_accuracies\n    \n    def get_pattern_risks(self) -> Dict[str, float]:\n        \"\"\"\n        Get current pattern-specific risks."
        },
        "get_pattern_risks": {
          "start_line": 279,
          "end_line": 288,
          "parameters": [
            {
              "name": "self"
            }
          ],
          "return_type": "complex_type",
          "calls": [],
          "docstring": "\n        Get current pattern-specific risks.\n        \n        Returns:\n            Dictionary mapping pattern types to their derived risks\n        ",
          "code_snippet": "        return self.pattern_accuracies\n    \n    def get_pattern_risks(self) -> Dict[str, float]:\n        \"\"\"\n        Get current pattern-specific risks.\n        \n        Returns:\n            Dictionary mapping pattern types to their derived risks\n        \"\"\"\n        return self.pattern_risks\n    \n    def update_accuracy(self, pattern_type: str, accuracy: float, derived_risk: Optional[float] = None) -> None:\n        \"\"\"\n        Update accuracy for a specific pattern type."
        },
        "update_accuracy": {
          "start_line": 288,
          "end_line": 311,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "pattern_type",
              "type": "str"
            },
            {
              "name": "accuracy",
              "type": "float"
            },
            {
              "name": "derived_risk"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "logger.debug",
              "line": 309
            },
            {
              "name": "self.pattern_types.append",
              "line": 298
            },
            {
              "name": "max",
              "line": 306
            },
            {
              "name": "min",
              "line": 306
            }
          ],
          "docstring": "\n        Update accuracy for a specific pattern type.\n        \n        Args:\n            pattern_type: Pattern type to update\n            accuracy: New accuracy value (0.0-1.0)\n            derived_risk: Optional derived risk value (if None, calculated from accuracy)\n        ",
          "code_snippet": "        return self.pattern_risks\n    \n    def update_accuracy(self, pattern_type: str, accuracy: float, derived_risk: Optional[float] = None) -> None:\n        \"\"\"\n        Update accuracy for a specific pattern type.\n        \n        Args:\n            pattern_type: Pattern type to update\n            accuracy: New accuracy value (0.0-1.0)\n            derived_risk: Optional derived risk value (if None, calculated from accuracy)\n        \"\"\"\n        if pattern_type not in self.pattern_types:\n            self.pattern_types.append(pattern_type)\n            self.pattern_correct[pattern_type] = 0\n            self.pattern_total[pattern_type] = 0\n        \n        self.pattern_accuracies[pattern_type] = accuracy\n        \n        # Calculate derived risk if not provided\n        if derived_risk is None:\n            derived_risk = max(0.1, min(0.9, 1.0 - accuracy))\n        \n        self.pattern_risks[pattern_type] = derived_risk\n        logger.debug(f\"Updated pattern '{pattern_type}': accuracy={accuracy:.4f}, risk={derived_risk:.4f}\")\n    \n    def get_unified_risk_accuracy_ratios(self) -> Dict[str, float]:\n        \"\"\"\n        Calculate unified risk/accuracy ratios for each pattern type."
        },
        "get_unified_risk_accuracy_ratios": {
          "start_line": 311,
          "end_line": 334,
          "parameters": [
            {
              "name": "self"
            }
          ],
          "return_type": "complex_type",
          "calls": [
            {
              "name": "self.pattern_accuracies.get",
              "line": 321
            },
            {
              "name": "self.pattern_risks.get",
              "line": 322
            },
            {
              "name": "max",
              "line": 328
            },
            {
              "name": "max",
              "line": 325
            },
            {
              "name": "min",
              "line": 328
            }
          ],
          "docstring": "\n        Calculate unified risk/accuracy ratios for each pattern type.\n        \n        Returns:\n            Dictionary mapping pattern types to their unified ratios\n        ",
          "code_snippet": "        logger.debug(f\"Updated pattern '{pattern_type}': accuracy={accuracy:.4f}, risk={derived_risk:.4f}\")\n    \n    def get_unified_risk_accuracy_ratios(self) -> Dict[str, float]:\n        \"\"\"\n        Calculate unified risk/accuracy ratios for each pattern type.\n        \n        Returns:\n            Dictionary mapping pattern types to their unified ratios\n        \"\"\"\n        ratios = {}\n        \n        for pattern_type in self.pattern_types:\n            accuracy = self.pattern_accuracies.get(pattern_type, 0.5)\n            risk = self.pattern_risks.get(pattern_type, 0.5)\n            \n            # Calculate risk/accuracy ratio\n            ratio = risk / max(0.1, accuracy)  # Prevent division by zero\n            \n            # Normalize to typical range (0.5-2.0)\n            normalized_ratio = max(0.5, min(2.0, ratio * 1.5))\n            \n            ratios[pattern_type] = normalized_ratio\n        \n        return ratios"
        }
      },
      "class_variables": [],
      "bases": [],
      "docstring": "\n    Tracks pattern recognition performance during training.\n    \n    This class maintains counters for correct predictions by pattern type,\n    calculates pattern-specific accuracies, and derives risk values.\n    \n    Attributes:\n        pattern_types: List of pattern types being tracked\n        pattern_correct: Dictionary counting correct predictions per pattern type\n        pattern_total: Dictionary counting total examples per pattern type\n        pattern_accuracies: Dictionary of pattern-specific accuracies\n        pattern_risks: Dictionary of pattern-specific derived risks\n        pattern_service: Service for mapping indices to pattern types\n    "
    }
  },
  "functions": {
    "track_patterns": {
      "start_line": 17,
      "end_line": 46,
      "parameters": [
        {
          "name": "batch_indices"
        },
        {
          "name": "correct_mask"
        },
        {
          "name": "pattern_map"
        }
      ],
      "return_type": "complex_type",
      "calls": [
        {
          "name": "PatternTracker",
          "line": 36
        },
        {
          "name": "tracker.update_from_batch",
          "line": 39
        },
        {
          "name": "tracker.get_pattern_accuracies",
          "line": 43
        },
        {
          "name": "tracker.get_pattern_risks",
          "line": 44
        }
      ],
      "docstring": "\n    Track pattern recognition performance for a batch.\n    \n    Args:\n        batch_indices: List of data indices in the current batch\n        correct_mask: List of boolean values indicating correctness for each index\n        pattern_map: Pattern map containing pattern information\n        \n    Returns:\n        Dictionary with pattern type metrics:\n        {\n            'accuracies': {pattern_type: accuracy},\n            'risks': {pattern_type: risk}\n        }\n    ",
      "code_snippet": "logger = logging.getLogger(__name__)\n\ndef track_patterns(batch_indices: List[int], \n                  correct_mask: List[bool], \n                  pattern_map: Dict[str, Any]) -> Dict[str, Dict[str, float]]:\n    \"\"\"\n    Track pattern recognition performance for a batch.\n    \n    Args:\n        batch_indices: List of data indices in the current batch\n        correct_mask: List of boolean values indicating correctness for each index\n        pattern_map: Pattern map containing pattern information\n        \n    Returns:\n        Dictionary with pattern type metrics:\n        {\n            'accuracies': {pattern_type: accuracy},\n            'risks': {pattern_type: risk}\n        }\n    \"\"\"\n    # Initialize pattern tracker\n    tracker = PatternTracker(pattern_map)\n    \n    # Update with batch data\n    tracker.update_from_batch(batch_indices, correct_mask)\n    \n    # Get metrics\n    return {\n        'accuracies': tracker.get_pattern_accuracies(),\n        'risks': tracker.get_pattern_risks()\n    }\n\nclass PatternTracker:\n    \"\"\""
    }
  },
  "constants": {}
}