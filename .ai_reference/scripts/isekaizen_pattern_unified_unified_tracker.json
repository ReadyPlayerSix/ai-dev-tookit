{
  "path": "D:\\Projects\\isekaiZen\\machine-learning-optimizer\\isekaizen\\pattern\\unified\\unified_tracker.py",
  "imports": [
    {
      "name": "torch",
      "line": 11
    },
    {
      "name": "logging",
      "line": 12
    },
    {
      "name": "time",
      "line": 13
    },
    {
      "name": "collections.defaultdict",
      "line": 14
    },
    {
      "name": "collections.deque",
      "line": 14
    },
    {
      "name": "typing.Dict",
      "line": 15
    },
    {
      "name": "typing.List",
      "line": 15
    },
    {
      "name": "typing.Set",
      "line": 15
    },
    {
      "name": "typing.Optional",
      "line": 15
    },
    {
      "name": "typing.Tuple",
      "line": 15
    },
    {
      "name": "typing.Any",
      "line": 15
    },
    {
      "name": "typing.Union",
      "line": 15
    }
  ],
  "classes": {
    "UnifiedPatternTracker": {
      "start_line": 19,
      "end_line": 591,
      "methods": {
        "__init__": {
          "start_line": 34,
          "end_line": 128,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "pattern_map"
            },
            {
              "name": "history_window"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "defaultdict",
              "line": 48
            },
            {
              "name": "set",
              "line": 57
            },
            {
              "name": "logger.info",
              "line": 125
            },
            {
              "name": "logger.info",
              "line": 64
            },
            {
              "name": "logger.info",
              "line": 106
            },
            {
              "name": "logger.info",
              "line": 116
            },
            {
              "name": "time.time",
              "line": 117
            },
            {
              "name": "....items",
              "line": 118
            },
            {
              "name": "logger.info",
              "line": 123
            },
            {
              "name": "defaultdict",
              "line": 48
            },
            {
              "name": "logger.info",
              "line": 77
            },
            {
              "name": "logger.info",
              "line": 82
            },
            {
              "name": "set",
              "line": 86
            },
            {
              "name": "logger.info",
              "line": 87
            },
            {
              "name": "set",
              "line": 102
            },
            {
              "name": "logger.info",
              "line": 103
            },
            {
              "name": "logger.info",
              "line": 70
            },
            {
              "name": "logger.info",
              "line": 72
            },
            {
              "name": "set",
              "line": 90
            },
            {
              "name": "logger.info",
              "line": 91
            },
            {
              "name": "pattern_map.get",
              "line": 118
            },
            {
              "name": "len",
              "line": 64
            },
            {
              "name": "self.pattern_distribution.keys",
              "line": 90
            },
            {
              "name": "set",
              "line": 94
            },
            {
              "name": "self.pattern_complexities.items",
              "line": 95
            },
            {
              "name": "logger.info",
              "line": 98
            },
            {
              "name": "....join",
              "line": 106
            },
            {
              "name": "int",
              "line": 120
            },
            {
              "name": "len",
              "line": 123
            },
            {
              "name": "pattern_map.keys",
              "line": 64
            },
            {
              "name": "len",
              "line": 77
            },
            {
              "name": "len",
              "line": 82
            },
            {
              "name": "len",
              "line": 87
            },
            {
              "name": "sorted",
              "line": 106
            },
            {
              "name": "time.time",
              "line": 123
            },
            {
              "name": "len",
              "line": 91
            },
            {
              "name": "isinstance",
              "line": 96
            },
            {
              "name": "self.known_patterns.add",
              "line": 97
            },
            {
              "name": "len",
              "line": 98
            }
          ],
          "docstring": "\n        Initialize the unified pattern tracker.\n        \n        Args:\n            pattern_map: Pattern map with sample-to-pattern mappings\n            history_window: Number of epochs of history to maintain\n        ",
          "code_snippet": "    \"\"\"\n    \n    def __init__(self, pattern_map=None, history_window=2):\n        \"\"\"\n        Initialize the unified pattern tracker.\n        \n        Args:\n            pattern_map: Pattern map with sample-to-pattern mappings\n            history_window: Number of epochs of history to maintain\n        \"\"\"\n        self.pattern_map = pattern_map\n        self.history_window = history_window\n        self.current_epoch = 0\n        \n        # Core pattern tracking data structure\n        # {pattern_type: {epoch: {metrics...}}}\n        self.pattern_data = defaultdict(lambda: defaultdict(dict))\n        \n        # Cached metrics to avoid recalculation\n        self._pattern_accuracies = {}\n        self._pattern_risks = {}\n        self._equilibrium_bounds = {}\n        self._pattern_statuses = {}\n        \n        # Track patterns that have been seen\n        self.known_patterns = set()\n        \n        # Extract pattern complexity and distribution from pattern map\n        self.pattern_complexities = {}\n        self.pattern_distribution = {}\n        \n        if pattern_map:\n            logger.info(f\"UnifiedPatternTracker initializing with pattern map containing {len(pattern_map.keys())} keys\")\n            \n            # Check for critical components\n            critical_components = ['pattern_complexities', 'pattern_distribution', 'pattern_types', 'sample_to_pattern']\n            for component in critical_components:\n                if component in pattern_map:\n                    logger.info(f\"  Pattern map contains '{component}'\")\n                else:\n                    logger.info(f\"  Pattern map missing '{component}'\")\n            \n            # Extract pattern complexity data\n            if 'pattern_complexities' in pattern_map:\n                self.pattern_complexities = pattern_map['pattern_complexities']\n                logger.info(f\"  Loaded pattern complexities for {len(self.pattern_complexities)} pattern types\")\n            \n            # Extract pattern distribution data\n            if 'pattern_distribution' in pattern_map:\n                self.pattern_distribution = pattern_map['pattern_distribution']\n                logger.info(f\"  Loaded pattern distribution for {len(self.pattern_distribution)} pattern types\")\n            \n            # Extract known patterns from map if available\n            if 'pattern_types' in pattern_map:\n                self.known_patterns = set(pattern_map['pattern_types'])\n                logger.info(f\"  Loaded {len(self.known_patterns)} known pattern types\")\n            elif self.pattern_distribution:\n                # If pattern_types is missing but we have pattern_distribution, use its keys\n                self.known_patterns = set(self.pattern_distribution.keys())\n                logger.info(f\"  Derived {len(self.known_patterns)} pattern types from pattern_distribution\")\n            elif self.pattern_complexities:\n                # If pattern_types and pattern_distribution are missing but we have pattern_complexities, use their keys\n                self.known_patterns = set()\n                for pattern_type, data in self.pattern_complexities.items():\n                    if isinstance(data, dict) and 'pattern_count' in data:\n                        self.known_patterns.add(pattern_type)\n                logger.info(f\"  Derived {len(self.known_patterns)} pattern types from pattern_complexities\")\n            \n            # If known_patterns is still empty, use the standard three-pattern system\n            if not self.known_patterns:\n                self.known_patterns = set([\"structural\", \"statistical\", \"temporal\"])\n                logger.info(\"  Using default pattern types (structural, statistical, temporal)\")\n            \n            # Log the pattern types we'll be using\n            logger.info(f\"  Pattern types: {', '.join(sorted(self.known_patterns))}\")\n\n        \n        # Cache for sample-to-pattern mapping\n        self._sample_to_pattern_cache = {}\n        \n        # Pre-process pattern map for efficiency - do this once during initialization\n        # rather than waiting for the first batch\n        self._sample_to_pattern_dict = {}\n        if pattern_map and 'sample_to_pattern' in pattern_map:\n            logger.info(\"Pre-processing pattern map for efficient lookups during initialization...\")\n            start_time = time.time()\n            for idx_str, pattern_type in pattern_map.get('sample_to_pattern', {}).items():\n                try:\n                    self._sample_to_pattern_dict[int(idx_str)] = pattern_type\n                except ValueError:\n                    pass\n            logger.info(f\"Pattern map pre-processed with {len(self._sample_to_pattern_dict)} entries in {time.time() - start_time:.2f} seconds\")\n        \n        logger.info(\"UnifiedPatternTracker initialized with history window: %d epochs\", \n                   self.history_window)\n    \n    def update_from_batch(self, batch_indices, correct_mask, epoch=None):\n        \"\"\"\n        Update pattern recognition data from a batch."
        },
        "update_from_batch": {
          "start_line": 128,
          "end_line": 176,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "batch_indices"
            },
            {
              "name": "correct_mask"
            },
            {
              "name": "epoch"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "self._get_patterns_for_samples",
              "line": 149
            },
            {
              "name": "enumerate",
              "line": 152
            },
            {
              "name": "self._clear_cached_metrics",
              "line": 170
            },
            {
              "name": "isinstance",
              "line": 141
            },
            {
              "name": "torch.tensor",
              "line": 142
            },
            {
              "name": "self.known_patterns.add",
              "line": 157
            },
            {
              "name": "self._prune_history",
              "line": 174
            },
            {
              "name": "len",
              "line": 166
            }
          ],
          "docstring": "\n        Update pattern recognition data from a batch.\n        \n        Args:\n            batch_indices: Indices of samples in the batch\n            correct_mask: Boolean mask indicating correct predictions\n            epoch: Current epoch (defaults to self.current_epoch)\n        ",
          "code_snippet": "                   self.history_window)\n    \n    def update_from_batch(self, batch_indices, correct_mask, epoch=None):\n        \"\"\"\n        Update pattern recognition data from a batch.\n        \n        Args:\n            batch_indices: Indices of samples in the batch\n            correct_mask: Boolean mask indicating correct predictions\n            epoch: Current epoch (defaults to self.current_epoch)\n        \"\"\"\n        if epoch is None:\n            epoch = self.current_epoch\n            \n        # Convert to tensors for efficient processing if not already\n        if not isinstance(batch_indices, torch.Tensor):\n            batch_indices = torch.tensor(batch_indices)\n        \n        # Skip if no pattern map available\n        if not self.pattern_map or 'sample_to_pattern' not in self.pattern_map:\n            return\n            \n        # Get pattern types for each sample in batch\n        sample_patterns = self._get_patterns_for_samples(batch_indices)\n        \n        # Update pattern recognition statistics\n        for idx, pattern_type in enumerate(sample_patterns):\n            if pattern_type is None:\n                continue\n                \n            # Add to known patterns set\n            self.known_patterns.add(pattern_type)\n            \n            # Initialize epoch data if needed\n            if 'total' not in self.pattern_data[pattern_type][epoch]:\n                self.pattern_data[pattern_type][epoch]['total'] = 0\n                self.pattern_data[pattern_type][epoch]['correct'] = 0\n            \n            # Update counters\n            self.pattern_data[pattern_type][epoch]['total'] += 1\n            if idx < len(correct_mask) and correct_mask[idx]:\n                self.pattern_data[pattern_type][epoch]['correct'] += 1\n                \n        # Clear cached metrics since data has changed\n        self._clear_cached_metrics()\n        \n        # Clean up old history\n        if epoch > self.history_window:\n            self._prune_history(epoch)\n    \n    def _get_patterns_for_samples(self, indices):\n        \"\"\"\n        Get pattern types for a list of sample indices."
        },
        "_get_patterns_for_samples": {
          "start_line": 176,
          "end_line": 218,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "indices"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "isinstance",
              "line": 187
            },
            {
              "name": "indices.tolist",
              "line": 188
            },
            {
              "name": "logger.info",
              "line": 194
            },
            {
              "name": "self.pattern_map.get",
              "line": 195
            },
            {
              "name": "sample_to_pattern.items",
              "line": 196
            },
            {
              "name": "logger.info",
              "line": 201
            },
            {
              "name": "self._sample_to_pattern_dict.get",
              "line": 204
            },
            {
              "name": "logger.warning",
              "line": 208
            },
            {
              "name": "list",
              "line": 210
            },
            {
              "name": "any",
              "line": 207
            },
            {
              "name": "logger.info",
              "line": 214
            },
            {
              "name": "int",
              "line": 198
            },
            {
              "name": "len",
              "line": 201
            },
            {
              "name": "len",
              "line": 213
            },
            {
              "name": "len",
              "line": 214
            }
          ],
          "docstring": "\n        Get pattern types for a list of sample indices.\n        \n        Args:\n            indices: Sample indices\n            \n        Returns:\n            List of pattern types\n        ",
          "code_snippet": "            self._prune_history(epoch)\n    \n    def _get_patterns_for_samples(self, indices):\n        \"\"\"\n        Get pattern types for a list of sample indices.\n        \n        Args:\n            indices: Sample indices\n            \n        Returns:\n            List of pattern types\n        \"\"\"\n        # Convert to normal Python list for lookup\n        if isinstance(indices, torch.Tensor):\n            indices = indices.tolist()\n        \n        # First check if we have a populated lookup dictionary\n        if not self._sample_to_pattern_dict and self.pattern_map and 'sample_to_pattern' in self.pattern_map:\n            # Late initialization of the sample_to_pattern dictionary\n            # This can happen if the pattern map was reconstructed from components\n            logger.info(\"Performing late initialization of sample_to_pattern dictionary\")\n            sample_to_pattern = self.pattern_map.get('sample_to_pattern', {})\n            for idx_str, pattern_type in sample_to_pattern.items():\n                try:\n                    self._sample_to_pattern_dict[int(idx_str)] = pattern_type\n                except ValueError:\n                    pass\n            logger.info(f\"Sample-to-pattern mapping initialized with {len(self._sample_to_pattern_dict)} entries\")\n        \n        # Try lookup from pre-processed dictionary\n        result = [self._sample_to_pattern_dict.get(idx) for idx in indices]\n        \n        # If no matches at all and we have known patterns, do fallback assignment\n        if not any(result) and self.known_patterns:\n            logger.warning(\"No pattern matches found - using fallback pattern assignment\")\n            # Assign each sample to a pattern type based on modulo of index\n            known_patterns_list = list(self.known_patterns)\n            if known_patterns_list:\n                # Create a fallback pattern assignment\n                result = [known_patterns_list[idx % len(known_patterns_list)] for idx in indices]\n                logger.info(f\"Created fallback pattern assignments for {len(indices)} samples\")\n        \n        return result\n    \n    def _clear_cached_metrics(self):\n        \"\"\"Clear cached metrics when underlying data changes.\"\"\"\n        self._pattern_accuracies = {}"
        },
        "_clear_cached_metrics": {
          "start_line": 218,
          "end_line": 224,
          "parameters": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "calls": [],
          "docstring": "Clear cached metrics when underlying data changes.",
          "code_snippet": "        return result\n    \n    def _clear_cached_metrics(self):\n        \"\"\"Clear cached metrics when underlying data changes.\"\"\"\n        self._pattern_accuracies = {}\n        self._pattern_risks = {}\n        self._pattern_statuses = {}\n    \n    def _prune_history(self, current_epoch):\n        \"\"\"\n        Remove data older than history_window epochs."
        },
        "_prune_history": {
          "start_line": 224,
          "end_line": 241,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "current_epoch"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "list",
              "line": 231
            },
            {
              "name": "self.pattern_data.keys",
              "line": 231
            },
            {
              "name": "....keys",
              "line": 233
            },
            {
              "name": "epochs_to_remove.append",
              "line": 235
            }
          ],
          "docstring": "\n        Remove data older than history_window epochs.\n        \n        Args:\n            current_epoch: Current epoch number\n        ",
          "code_snippet": "        self._pattern_statuses = {}\n    \n    def _prune_history(self, current_epoch):\n        \"\"\"\n        Remove data older than history_window epochs.\n        \n        Args:\n            current_epoch: Current epoch number\n        \"\"\"\n        for pattern in list(self.pattern_data.keys()):\n            epochs_to_remove = []\n            for epoch in self.pattern_data[pattern].keys():\n                if current_epoch - epoch > self.history_window:\n                    epochs_to_remove.append(epoch)\n            \n            # Remove old epochs\n            for epoch in epochs_to_remove:\n                del self.pattern_data[pattern][epoch]\n    \n    def get_pattern_accuracies(self, epoch=None):\n        \"\"\"\n        Get accuracy for each pattern type."
        },
        "get_pattern_accuracies": {
          "start_line": 241,
          "end_line": 272,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "epoch"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "....get",
              "line": 262
            },
            {
              "name": "....get",
              "line": 263
            }
          ],
          "docstring": "\n        Get accuracy for each pattern type.\n        \n        Args:\n            epoch: Epoch to get accuracies for (defaults to current)\n            \n        Returns:\n            Dictionary mapping pattern types to accuracy values\n        ",
          "code_snippet": "                del self.pattern_data[pattern][epoch]\n    \n    def get_pattern_accuracies(self, epoch=None):\n        \"\"\"\n        Get accuracy for each pattern type.\n        \n        Args:\n            epoch: Epoch to get accuracies for (defaults to current)\n            \n        Returns:\n            Dictionary mapping pattern types to accuracy values\n        \"\"\"\n        if epoch is None:\n            epoch = self.current_epoch\n            \n        # Return cached result if available\n        if epoch in self._pattern_accuracies:\n            return self._pattern_accuracies[epoch]\n            \n        # Calculate accuracies\n        accuracies = {}\n        for pattern in self.known_patterns:\n            if pattern in self.pattern_data and epoch in self.pattern_data[pattern]:\n                total = self.pattern_data[pattern][epoch].get('total', 0)\n                correct = self.pattern_data[pattern][epoch].get('correct', 0)\n                \n                if total > 0:\n                    accuracies[pattern] = (correct / total) * 100.0\n            \n        # Cache and return\n        self._pattern_accuracies[epoch] = accuracies\n        return accuracies\n    \n    def calculate_unified_ratio(self, pattern_type, accuracy=None, epoch=None):\n        \"\"\"\n        Calculate unified risk/accuracy ratio for a pattern type."
        },
        "calculate_unified_ratio": {
          "start_line": 272,
          "end_line": 336,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "pattern_type"
            },
            {
              "name": "accuracy"
            },
            {
              "name": "epoch"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "self.pattern_complexities.get",
              "line": 296
            },
            {
              "name": "isinstance",
              "line": 299
            },
            {
              "name": "self.get_pattern_accuracies",
              "line": 289
            },
            {
              "name": "accuracies.get",
              "line": 290
            },
            {
              "name": "isinstance",
              "line": 312
            },
            {
              "name": "complexity_value.items",
              "line": 304
            },
            {
              "name": "isinstance",
              "line": 305
            }
          ],
          "docstring": "\n        Calculate unified risk/accuracy ratio for a pattern type.\n        \n        Args:\n            pattern_type: Pattern type to calculate ratio for\n            accuracy: Pattern accuracy (calculated if None)\n            epoch: Epoch to calculate ratio for (defaults to current)\n            \n        Returns:\n            Unified risk/accuracy ratio\n        ",
          "code_snippet": "        return accuracies\n    \n    def calculate_unified_ratio(self, pattern_type, accuracy=None, epoch=None):\n        \"\"\"\n        Calculate unified risk/accuracy ratio for a pattern type.\n        \n        Args:\n            pattern_type: Pattern type to calculate ratio for\n            accuracy: Pattern accuracy (calculated if None)\n            epoch: Epoch to calculate ratio for (defaults to current)\n            \n        Returns:\n            Unified risk/accuracy ratio\n        \"\"\"\n        if epoch is None:\n            epoch = self.current_epoch\n            \n        # Get pattern accuracy if not provided\n        if accuracy is None:\n            accuracies = self.get_pattern_accuracies(epoch)\n            accuracy = accuracies.get(pattern_type, 50.0)  # Default to 50% if unknown\n            \n        # Convert percentage to decimal\n        accuracy_decimal = accuracy / 100.0\n        \n        # Get pattern complexity\n        complexity_value = self.pattern_complexities.get(pattern_type, 0.5)  # Default medium complexity\n        \n        # Handle the case where complexity is a dictionary (with avg_complexity field)\n        if isinstance(complexity_value, dict):\n            if 'avg_complexity' in complexity_value:\n                complexity_value = complexity_value['avg_complexity']\n            else:\n                # If no avg_complexity field, use the first numeric value or default\n                for key, value in complexity_value.items():\n                    if isinstance(value, (int, float)):\n                        complexity_value = value\n                        break\n                else:\n                    complexity_value = 0.5  # Default if no numeric value found\n        \n        # Ensure we have a numeric value for the calculation\n        if not isinstance(complexity_value, (int, float)):\n            complexity_value = 0.5  # Fall back to default if still not numeric\n            \n        # Calculate derived risk based on accuracy and complexity\n        # Simplified unified ratio formula:\n        # - High accuracy + high complexity = balanced ratio (~1.0)\n        # - Low accuracy + high complexity = high ratio (>1.0)\n        # - High accuracy + low complexity = low ratio (<1.0)\n        risk = (1.0 - accuracy_decimal) * (0.5 + complexity_value * 0.5)\n        \n        # Calculate unified ratio (risk relative to accuracy)\n        # Ensure accuracy is not zero for division\n        if accuracy_decimal < 0.01:\n            accuracy_decimal = 0.01\n            \n        ratio = risk / accuracy_decimal\n        \n        # Store in risk cache\n        if epoch not in self._pattern_risks:\n            self._pattern_risks[epoch] = {}\n        self._pattern_risks[epoch][pattern_type] = risk\n        \n        return ratio\n    \n    def calculate_pattern_ratios(self, epoch=None):\n        \"\"\"\n        Calculate risk/accuracy ratios for all pattern types."
        },
        "calculate_pattern_ratios": {
          "start_line": 336,
          "end_line": 361,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "epoch"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "self.get_pattern_accuracies",
              "line": 350
            },
            {
              "name": "accuracies.get",
              "line": 355
            },
            {
              "name": "self.calculate_unified_ratio",
              "line": 357
            }
          ],
          "docstring": "\n        Calculate risk/accuracy ratios for all pattern types.\n        \n        Args:\n            epoch: Epoch to calculate ratios for (defaults to current)\n            \n        Returns:\n            Dictionary mapping pattern types to risk/accuracy ratios\n        ",
          "code_snippet": "        return ratio\n    \n    def calculate_pattern_ratios(self, epoch=None):\n        \"\"\"\n        Calculate risk/accuracy ratios for all pattern types.\n        \n        Args:\n            epoch: Epoch to calculate ratios for (defaults to current)\n            \n        Returns:\n            Dictionary mapping pattern types to risk/accuracy ratios\n        \"\"\"\n        if epoch is None:\n            epoch = self.current_epoch\n            \n        # Get accuracies\n        accuracies = self.get_pattern_accuracies(epoch)\n        \n        # Calculate ratios\n        ratios = {}\n        for pattern_type in self.known_patterns:\n            accuracy = accuracies.get(pattern_type)\n            if accuracy is not None:\n                ratios[pattern_type] = self.calculate_unified_ratio(pattern_type, accuracy, epoch)\n        \n        return ratios\n    \n    def calculate_equilibrium_bounds(self, pattern_type, train_acc, test_acc, epoch=None):\n        \"\"\"\n        Calculate equilibrium bounds for a pattern type."
        },
        "calculate_equilibrium_bounds": {
          "start_line": 361,
          "end_line": 428,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "pattern_type"
            },
            {
              "name": "train_acc"
            },
            {
              "name": "test_acc"
            },
            {
              "name": "epoch"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "self.pattern_complexities.get",
              "line": 378
            },
            {
              "name": "self.pattern_distribution.get",
              "line": 379
            },
            {
              "name": "isinstance",
              "line": 382
            },
            {
              "name": "max",
              "line": 409
            },
            {
              "name": "min",
              "line": 410
            },
            {
              "name": "isinstance",
              "line": 395
            },
            {
              "name": "complexity_value.items",
              "line": 387
            },
            {
              "name": "isinstance",
              "line": 388
            }
          ],
          "docstring": "\n        Calculate equilibrium bounds for a pattern type.\n        \n        Args:\n            pattern_type: Pattern type to calculate bounds for\n            train_acc: Overall training accuracy\n            test_acc: Overall validation accuracy\n            epoch: Epoch to calculate bounds for (defaults to current)\n            \n        Returns:\n            Tuple of (min_bound, max_bound)\n        ",
          "code_snippet": "        return ratios\n    \n    def calculate_equilibrium_bounds(self, pattern_type, train_acc, test_acc, epoch=None):\n        \"\"\"\n        Calculate equilibrium bounds for a pattern type.\n        \n        Args:\n            pattern_type: Pattern type to calculate bounds for\n            train_acc: Overall training accuracy\n            test_acc: Overall validation accuracy\n            epoch: Epoch to calculate bounds for (defaults to current)\n            \n        Returns:\n            Tuple of (min_bound, max_bound)\n        \"\"\"\n        if epoch is None:\n            epoch = self.current_epoch\n            \n        # Get pattern complexity and distribution\n        complexity_value = self.pattern_complexities.get(pattern_type, 0.5)\n        distribution = self.pattern_distribution.get(pattern_type, 0.33)\n        \n        # Handle the case where complexity is a dictionary (with avg_complexity field)\n        if isinstance(complexity_value, dict):\n            if 'avg_complexity' in complexity_value:\n                complexity_value = complexity_value['avg_complexity']\n            else:\n                # If no avg_complexity field, use the first numeric value or default\n                for key, value in complexity_value.items():\n                    if isinstance(value, (int, float)):\n                        complexity_value = value\n                        break\n                else:\n                    complexity_value = 0.5  # Default if no numeric value found\n        \n        # Ensure we have a numeric value for the calculation\n        if not isinstance(complexity_value, (int, float)):\n            complexity_value = 0.5  # Fall back to default if still not numeric\n            \n        # Calculate train/test ratio with protection against division by zero\n        if test_acc < 0.1:\n            train_test_ratio = 2.0  # Default high ratio\n        else:\n            train_test_ratio = train_acc / test_acc\n            \n        # Adjust base bounds based on complexity and distribution\n        # Higher complexity patterns can have wider bounds\n        complexity_factor = 0.8 + complexity_value * 0.4  # Range: 0.8-1.2\n        \n        # Calculate base bounds (in percentage)\n        base_min = max(10.0, test_acc * 0.5)  # At least 10%\n        base_max = min(95.0, test_acc * 1.5)  # At most 95%\n        \n        # Apply complexity adjustment\n        adjusted_min = base_min * (1.0 - (complexity_factor - 1.0))\n        adjusted_max = base_max * complexity_factor\n        \n        # Apply distribution adjustment (less common patterns can have wider bounds)\n        distribution_factor = 1.0 + (0.3 - distribution) * 0.5  # Range: ~0.85-1.15\n        final_min = adjusted_min * (1.0 / distribution_factor)\n        final_max = adjusted_max * distribution_factor\n        \n        # Cache bounds\n        if epoch not in self._equilibrium_bounds:\n            self._equilibrium_bounds[epoch] = {}\n        self._equilibrium_bounds[epoch][pattern_type] = (final_min, final_max)\n        \n        return final_min, final_max\n    \n    def update_equilibrium_status(self, train_acc, test_acc, epoch=None):\n        \"\"\"\n        Update equilibrium status for all patterns."
        },
        "update_equilibrium_status": {
          "start_line": 428,
          "end_line": 468,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "train_acc"
            },
            {
              "name": "test_acc"
            },
            {
              "name": "epoch"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "self.get_pattern_accuracies",
              "line": 444
            },
            {
              "name": "accuracies.get",
              "line": 449
            },
            {
              "name": "self.calculate_equilibrium_bounds",
              "line": 451
            }
          ],
          "docstring": "\n        Update equilibrium status for all patterns.\n        \n        Args:\n            train_acc: Overall training accuracy\n            test_acc: Overall validation accuracy\n            epoch: Epoch to update (defaults to current)\n            \n        Returns:\n            Dictionary mapping pattern types to equilibrium status\n        ",
          "code_snippet": "        return final_min, final_max\n    \n    def update_equilibrium_status(self, train_acc, test_acc, epoch=None):\n        \"\"\"\n        Update equilibrium status for all patterns.\n        \n        Args:\n            train_acc: Overall training accuracy\n            test_acc: Overall validation accuracy\n            epoch: Epoch to update (defaults to current)\n            \n        Returns:\n            Dictionary mapping pattern types to equilibrium status\n        \"\"\"\n        if epoch is None:\n            epoch = self.current_epoch\n            \n        # Get pattern accuracies\n        accuracies = self.get_pattern_accuracies(epoch)\n        \n        # Calculate equilibrium status for each pattern\n        status_map = {}\n        for pattern in self.known_patterns:\n            accuracy = accuracies.get(pattern)\n            if accuracy is not None:\n                min_bound, max_bound = self.calculate_equilibrium_bounds(\n                    pattern, train_acc, test_acc, epoch)\n                \n                # Check if within bounds\n                status = {\n                    'min': accuracy >= min_bound,  # Above min bound\n                    'max': accuracy <= max_bound,  # Below max bound\n                    'bounds': (min_bound, max_bound),\n                    'accuracy': accuracy\n                }\n                status_map[pattern] = status\n        \n        # Cache status\n        self._pattern_statuses[epoch] = status_map\n        \n        return status_map\n    \n    def get_patterns_outside_equilibrium(self, epoch=None):\n        \"\"\"\n        Get patterns that are outside their equilibrium bounds."
        },
        "get_patterns_outside_equilibrium": {
          "start_line": 468,
          "end_line": 496,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "epoch"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "logger.warning",
              "line": 483
            },
            {
              "name": "status_map.items",
              "line": 489
            },
            {
              "name": "status_map.items",
              "line": 490
            }
          ],
          "docstring": "\n        Get patterns that are outside their equilibrium bounds.\n        \n        Args:\n            epoch: Epoch to check (defaults to current)\n            \n        Returns:\n            Dictionary with 'below_min' and 'above_max' lists\n        ",
          "code_snippet": "        return status_map\n    \n    def get_patterns_outside_equilibrium(self, epoch=None):\n        \"\"\"\n        Get patterns that are outside their equilibrium bounds.\n        \n        Args:\n            epoch: Epoch to check (defaults to current)\n            \n        Returns:\n            Dictionary with 'below_min' and 'above_max' lists\n        \"\"\"\n        if epoch is None:\n            epoch = self.current_epoch\n            \n        # Check cached status or calculate\n        if epoch not in self._pattern_statuses:\n            logger.warning(\"No equilibrium status available for epoch %d\", epoch)\n            return {'below_min': [], 'above_max': []}\n            \n        status_map = self._pattern_statuses[epoch]\n        \n        # Identify patterns outside bounds\n        below_min = [p for p, s in status_map.items() if not s['min']]\n        above_max = [p for p, s in status_map.items() if not s['max']]\n        \n        return {\n            'below_min': below_min,\n            'above_max': above_max\n        }\n    \n    def end_epoch(self, epoch=None):\n        \"\"\""
        },
        "end_epoch": {
          "start_line": 497,
          "end_line": 512,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "epoch"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "self._clear_cached_metrics",
              "line": 510
            }
          ],
          "docstring": "\n        Signal the end of an epoch, updating current epoch counter.\n        \n        Args:\n            epoch: Epoch that just completed (defaults to current+1)\n        ",
          "code_snippet": "        }\n    \n    def end_epoch(self, epoch=None):\n        \"\"\"\n        Signal the end of an epoch, updating current epoch counter.\n        \n        Args:\n            epoch: Epoch that just completed (defaults to current+1)\n        \"\"\"\n        if epoch is not None:\n            self.current_epoch = epoch\n        else:\n            self.current_epoch += 1\n        \n        # Clear cached metrics for the next epoch\n        self._clear_cached_metrics()\n    \n    def update_accuracy(self, pattern_type, accuracy, derived_risk=None, epoch=None):\n        \"\"\"\n        Update accuracy for a specific pattern type."
        },
        "update_accuracy": {
          "start_line": 512,
          "end_line": 572,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "pattern_type"
            },
            {
              "name": "accuracy"
            },
            {
              "name": "derived_risk"
            },
            {
              "name": "epoch"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "self.known_patterns.add",
              "line": 526
            },
            {
              "name": "logger.debug",
              "line": 570
            },
            {
              "name": "self.pattern_complexities.get",
              "line": 539
            },
            {
              "name": "isinstance",
              "line": 542
            },
            {
              "name": "isinstance",
              "line": 555
            },
            {
              "name": "complexity_value.items",
              "line": 547
            },
            {
              "name": "isinstance",
              "line": 548
            }
          ],
          "docstring": "\n        Update accuracy for a specific pattern type.\n        \n        Args:\n            pattern_type: Pattern type to update\n            accuracy: New accuracy value (0-100 scale)\n            derived_risk: Optional derived risk value (if None, calculated from accuracy)\n            epoch: Current epoch (defaults to self.current_epoch)\n        ",
          "code_snippet": "        self._clear_cached_metrics()\n    \n    def update_accuracy(self, pattern_type, accuracy, derived_risk=None, epoch=None):\n        \"\"\"\n        Update accuracy for a specific pattern type.\n        \n        Args:\n            pattern_type: Pattern type to update\n            accuracy: New accuracy value (0-100 scale)\n            derived_risk: Optional derived risk value (if None, calculated from accuracy)\n            epoch: Current epoch (defaults to self.current_epoch)\n        \"\"\"\n        if epoch is None:\n            epoch = self.current_epoch\n            \n        # Add to known patterns set if not already present\n        self.known_patterns.add(pattern_type)\n        \n        # Ensure pattern data structure exists\n        if 'total' not in self.pattern_data[pattern_type][epoch]:\n            self.pattern_data[pattern_type][epoch]['total'] = 0\n            self.pattern_data[pattern_type][epoch]['correct'] = 0\n        \n        # Calculate derived risk if not provided\n        # Convert accuracy to 0-1 scale for calculation\n        accuracy_decimal = accuracy / 100.0 if accuracy > 1.0 else accuracy\n        \n        if derived_risk is None:\n            # Get complexity for this pattern type, handling different possible structures\n            complexity_value = self.pattern_complexities.get(pattern_type, 0.5)  # Default medium complexity\n            \n            # Handle the case where complexity is a dictionary (with avg_complexity field)\n            if isinstance(complexity_value, dict):\n                if 'avg_complexity' in complexity_value:\n                    complexity_value = complexity_value['avg_complexity']\n                else:\n                    # If no avg_complexity field, use the first numeric value or default\n                    for key, value in complexity_value.items():\n                        if isinstance(value, (int, float)):\n                            complexity_value = value\n                            break\n                    else:\n                        complexity_value = 0.5  # Default if no numeric value found\n            \n            # Ensure we have a numeric value for the calculation\n            if not isinstance(complexity_value, (int, float)):\n                complexity_value = 0.5  # Fall back to default if still not numeric\n                \n            derived_risk = (1.0 - accuracy_decimal) * (0.5 + complexity_value * 0.5)\n        \n        # Store directly in risk cache\n        if epoch not in self._pattern_risks:\n            self._pattern_risks[epoch] = {}\n        self._pattern_risks[epoch][pattern_type] = derived_risk\n        \n        # Store directly in accuracy cache\n        if epoch not in self._pattern_accuracies:\n            self._pattern_accuracies[epoch] = {}\n        self._pattern_accuracies[epoch][pattern_type] = accuracy if accuracy > 1.0 else accuracy * 100.0\n        \n        logger.debug(f\"Updated pattern '{pattern_type}': accuracy={(accuracy_decimal * 100.0):.2f}%, risk={derived_risk:.4f}\")\n    \n    def get_risk_levels(self, epoch=None):\n        \"\"\"\n        Get risk levels for all pattern types."
        },
        "get_risk_levels": {
          "start_line": 572,
          "end_line": 591,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "epoch"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "self._pattern_risks.get",
              "line": 589
            },
            {
              "name": "self.calculate_pattern_ratios",
              "line": 587
            }
          ],
          "docstring": "\n        Get risk levels for all pattern types.\n        \n        Args:\n            epoch: Epoch to get risks for (defaults to current)\n            \n        Returns:\n            Dictionary mapping pattern types to risk values\n        ",
          "code_snippet": "        logger.debug(f\"Updated pattern '{pattern_type}': accuracy={(accuracy_decimal * 100.0):.2f}%, risk={derived_risk:.4f}\")\n    \n    def get_risk_levels(self, epoch=None):\n        \"\"\"\n        Get risk levels for all pattern types.\n        \n        Args:\n            epoch: Epoch to get risks for (defaults to current)\n            \n        Returns:\n            Dictionary mapping pattern types to risk values\n        \"\"\"\n        if epoch is None:\n            epoch = self.current_epoch\n            \n        # Calculate ratios if not cached (ratios will update risk cache)\n        if epoch not in self._pattern_risks:\n            self.calculate_pattern_ratios(epoch)\n            \n        return self._pattern_risks.get(epoch, {})"
        }
      },
      "class_variables": [],
      "bases": [],
      "docstring": "\n    Centralized pattern tracking system for isekaiZen framework.\n    \n    This class consolidates pattern recognition, risk assessment, and \n    equilibrium bound tracking in a single component to eliminate redundancy\n    and improve efficiency.\n    \n    Attributes:\n        pattern_map: Pattern map containing pattern type information\n        pattern_data: Dictionary tracking pattern metrics with bounded history\n        history_window: Number of epochs of history to maintain\n        current_epoch: Current training epoch\n    "
    }
  },
  "functions": {},
  "constants": {}
}