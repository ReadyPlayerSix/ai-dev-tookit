{
  "path": "D:\\Projects\\isekaiZen\\machine-learning-optimizer\\isekaizen\\core\\optimizer\\risk_accuracy\\pattern_risk_accuracy_tracker.py",
  "imports": [
    {
      "name": "torch",
      "line": 8
    },
    {
      "name": "logging",
      "line": 9
    },
    {
      "name": "time",
      "line": 10
    },
    {
      "name": "typing.Dict",
      "line": 11
    },
    {
      "name": "typing.List",
      "line": 11
    },
    {
      "name": "typing.Any",
      "line": 11
    },
    {
      "name": "typing.Optional",
      "line": 11
    },
    {
      "name": "typing.Tuple",
      "line": 11
    },
    {
      "name": "typing.Set",
      "line": 11
    },
    {
      "name": "typing.Union",
      "line": 11
    }
  ],
  "classes": {
    "PatternRiskAccuracyTracker": {
      "start_line": 15,
      "end_line": 391,
      "methods": {
        "__init__": {
          "start_line": 23,
          "end_line": 62,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "pattern_map"
            },
            {
              "name": "risk_scale_factor"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "self._extract_pattern_types",
              "line": 35
            },
            {
              "name": "set",
              "line": 51
            },
            {
              "name": "set",
              "line": 52
            },
            {
              "name": "logger.info",
              "line": 59
            },
            {
              "name": "logger.info",
              "line": 60
            },
            {
              "name": "self._extract_pattern_preferences",
              "line": 54
            },
            {
              "name": "len",
              "line": 59
            },
            {
              "name": "....join",
              "line": 60
            }
          ],
          "docstring": "\n        Initialize the pattern risk-accuracy tracker.\n        \n        Args:\n            pattern_map: Pattern map containing pattern information\n            risk_scale_factor: Factor to scale risk values (higher = more risk)\n        ",
          "code_snippet": "    \"\"\"\n    \n    def __init__(self, pattern_map=None, risk_scale_factor=1.0):\n        \"\"\"\n        Initialize the pattern risk-accuracy tracker.\n        \n        Args:\n            pattern_map: Pattern map containing pattern information\n            risk_scale_factor: Factor to scale risk values (higher = more risk)\n        \"\"\"\n        self.pattern_map = pattern_map or {}\n        self.risk_scale_factor = risk_scale_factor\n        \n        # Extract pattern types from map\n        self.pattern_types = self._extract_pattern_types()\n        \n        # Initialize pattern stats\n        self.pattern_stats = {\n            pattern_type: {\n                'correct': 0,\n                'total': 0,\n                'accuracy': 0.0,\n                'risk': 0.5,  # Start with median risk (neutral)\n                'accuracy_history': [],\n                'risk_history': []\n            }\n            for pattern_type in self.pattern_types\n        }\n        \n        # Track preferred/challenging patterns\n        self.preferred_patterns = set()\n        self.challenging_patterns = set()\n        if pattern_map:\n            self._extract_pattern_preferences()\n        \n        # Snapshot history\n        self.snapshots = []\n        \n        logger.info(f\"Pattern Risk-Accuracy Tracker initialized with {len(self.pattern_types)} pattern types\")\n        logger.info(f\"Pattern types: {', '.join(self.pattern_types)}\")\n    \n    def _extract_pattern_types(self) -> Set[str]:\n        \"\"\"\n        Extract pattern types from pattern map."
        },
        "_extract_pattern_types": {
          "start_line": 62,
          "end_line": 85,
          "parameters": [
            {
              "name": "self"
            }
          ],
          "return_type": "complex_type",
          "calls": [
            {
              "name": "set",
              "line": 69
            },
            {
              "name": "set",
              "line": 74
            },
            {
              "name": "pattern_distribution.keys",
              "line": 74
            },
            {
              "name": "set",
              "line": 77
            },
            {
              "name": "pattern_distribution.keys",
              "line": 77
            }
          ],
          "docstring": "\n        Extract pattern types from pattern map.\n        \n        Returns:\n            Set of pattern types\n        ",
          "code_snippet": "        logger.info(f\"Pattern types: {', '.join(self.pattern_types)}\")\n    \n    def _extract_pattern_types(self) -> Set[str]:\n        \"\"\"\n        Extract pattern types from pattern map.\n        \n        Returns:\n            Set of pattern types\n        \"\"\"\n        pattern_types = set()\n        \n        # Extract from pattern distribution if available\n        if 'pattern_map' in self.pattern_map and 'pattern_distribution' in self.pattern_map['pattern_map']:\n            pattern_distribution = self.pattern_map['pattern_map']['pattern_distribution']\n            pattern_types = set(pattern_distribution.keys())\n        elif 'pattern_distribution' in self.pattern_map:\n            pattern_distribution = self.pattern_map['pattern_distribution']\n            pattern_types = set(pattern_distribution.keys())\n        \n        # Fall back to default types if none found\n        if not pattern_types:\n            pattern_types = {\"structure\", \"relationship\", \"intensity\", \"dominance\", \"temporal\"}\n            \n        return pattern_types\n    \n    def _extract_pattern_preferences(self):\n        \"\"\"Extract preferred and challenging patterns from the pattern map.\"\"\"\n        if 'pattern_map' in self.pattern_map and 'pattern_preferences' in self.pattern_map['pattern_map']:"
        },
        "_extract_pattern_preferences": {
          "start_line": 85,
          "end_line": 95,
          "parameters": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "set",
              "line": 89
            },
            {
              "name": "set",
              "line": 90
            },
            {
              "name": "logger.info",
              "line": 92
            },
            {
              "name": "logger.info",
              "line": 93
            },
            {
              "name": "preferences.get",
              "line": 89
            },
            {
              "name": "preferences.get",
              "line": 90
            },
            {
              "name": "....join",
              "line": 92
            },
            {
              "name": "....join",
              "line": 93
            }
          ],
          "docstring": "Extract preferred and challenging patterns from the pattern map.",
          "code_snippet": "        return pattern_types\n    \n    def _extract_pattern_preferences(self):\n        \"\"\"Extract preferred and challenging patterns from the pattern map.\"\"\"\n        if 'pattern_map' in self.pattern_map and 'pattern_preferences' in self.pattern_map['pattern_map']:\n            preferences = self.pattern_map['pattern_map']['pattern_preferences']\n            self.preferred_patterns = set(preferences.get('preferred_patterns', []))\n            self.challenging_patterns = set(preferences.get('challenging_patterns', []))\n            \n            logger.info(f\"Preferred patterns: {', '.join(self.preferred_patterns)}\")\n            logger.info(f\"Challenging patterns: {', '.join(self.challenging_patterns)}\")\n    \n    def _get_pattern_type(self, example_idx: Union[int, str]) -> Optional[str]:\n        \"\"\"\n        Get pattern type for an example from the pattern map."
        },
        "_get_pattern_type": {
          "start_line": 95,
          "end_line": 116,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "example_idx"
            }
          ],
          "return_type": "complex_type",
          "calls": [
            {
              "name": "str",
              "line": 106
            },
            {
              "name": "....get",
              "line": 112
            }
          ],
          "docstring": "\n        Get pattern type for an example from the pattern map.\n        \n        Args:\n            example_idx: Example index\n            \n        Returns:\n            Pattern type or None if not found\n        ",
          "code_snippet": "            logger.info(f\"Challenging patterns: {', '.join(self.challenging_patterns)}\")\n    \n    def _get_pattern_type(self, example_idx: Union[int, str]) -> Optional[str]:\n        \"\"\"\n        Get pattern type for an example from the pattern map.\n        \n        Args:\n            example_idx: Example index\n            \n        Returns:\n            Pattern type or None if not found\n        \"\"\"\n        # Convert to string for lookup\n        idx_str = str(example_idx)\n        \n        # Look up in pattern map\n        if 'pattern_map' in self.pattern_map and 'pattern_map' in self.pattern_map['pattern_map']:\n            pattern_data = self.pattern_map['pattern_map']['pattern_map']\n            if idx_str in pattern_data:\n                return pattern_data[idx_str].get('pattern_type')\n        \n        return None\n    \n    def update_with_batch_results(self, batch_indices, correct_mask):\n        \"\"\"\n        Update pattern stats with batch results."
        },
        "update_with_batch_results": {
          "start_line": 116,
          "end_line": 140,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "batch_indices"
            },
            {
              "name": "correct_mask"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "enumerate",
              "line": 124
            },
            {
              "name": "self._get_pattern_type",
              "line": 126
            },
            {
              "name": "isinstance",
              "line": 125
            },
            {
              "name": "....item",
              "line": 125
            }
          ],
          "docstring": "\n        Update pattern stats with batch results.\n        \n        Args:\n            batch_indices: Indices of examples in the batch\n            correct_mask: Boolean mask of whether each prediction was correct\n        ",
          "code_snippet": "        return None\n    \n    def update_with_batch_results(self, batch_indices, correct_mask):\n        \"\"\"\n        Update pattern stats with batch results.\n        \n        Args:\n            batch_indices: Indices of examples in the batch\n            correct_mask: Boolean mask of whether each prediction was correct\n        \"\"\"\n        for i, example_idx in enumerate(batch_indices):\n            is_correct = correct_mask[i].item() if isinstance(correct_mask[i], torch.Tensor) else correct_mask[i]\n            pattern_type = self._get_pattern_type(example_idx)\n            \n            if pattern_type and pattern_type in self.pattern_stats:\n                # Update accuracy stats\n                self.pattern_stats[pattern_type]['total'] += 1\n                if is_correct:\n                    self.pattern_stats[pattern_type]['correct'] += 1\n                \n                # Update accuracy\n                total = self.pattern_stats[pattern_type]['total']\n                correct = self.pattern_stats[pattern_type]['correct']\n                if total > 0:\n                    self.pattern_stats[pattern_type]['accuracy'] = correct / total\n    \n    def update_with_epoch_results(self, epoch):\n        \"\"\"\n        Update risk based on accuracy changes after an epoch."
        },
        "update_with_epoch_results": {
          "start_line": 140,
          "end_line": 187,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "epoch"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "self.pattern_stats.items",
              "line": 148
            },
            {
              "name": "....append",
              "line": 154
            },
            {
              "name": "min",
              "line": 178
            },
            {
              "name": "....append",
              "line": 179
            },
            {
              "name": "logger.info",
              "line": 181
            },
            {
              "name": "self.take_snapshot",
              "line": 185
            },
            {
              "name": "len",
              "line": 160
            },
            {
              "name": "max",
              "line": 178
            },
            {
              "name": "min",
              "line": 167
            },
            {
              "name": "min",
              "line": 171
            },
            {
              "name": "max",
              "line": 172
            },
            {
              "name": "abs",
              "line": 167
            }
          ],
          "docstring": "\n        Update risk based on accuracy changes after an epoch.\n        \n        Args:\n            epoch: Current epoch number\n        ",
          "code_snippet": "                    self.pattern_stats[pattern_type]['accuracy'] = correct / total\n    \n    def update_with_epoch_results(self, epoch):\n        \"\"\"\n        Update risk based on accuracy changes after an epoch.\n        \n        Args:\n            epoch: Current epoch number\n        \"\"\"\n        # For each pattern type, check accuracy changes\n        for pattern_type, stats in self.pattern_stats.items():\n            if stats['total'] == 0:\n                continue\n                \n            # Record current accuracy\n            current_accuracy = stats['accuracy']\n            stats['accuracy_history'].append(current_accuracy)\n            \n            # Calculate risk directly from accuracy\n            base_risk = 1.0 - current_accuracy  # Inverse of accuracy\n            \n            # If we have history, consider accuracy changes\n            if len(stats['accuracy_history']) > 1:\n                prev_accuracy = stats['accuracy_history'][-2]\n                accuracy_change = current_accuracy - prev_accuracy\n                \n                # If accuracy decreased, increase risk\n                if accuracy_change < 0:\n                    # Scale risk increase based on magnitude of loss\n                    risk_increase = min(0.2, abs(accuracy_change) * 2.0)\n                    base_risk += risk_increase\n                else:\n                    # If accuracy improved, decrease risk gradually\n                    risk_decrease = min(0.1, accuracy_change)\n                    base_risk = max(0.0, base_risk - risk_decrease)\n            \n            # Apply risk scaling factor\n            scaled_risk = base_risk * self.risk_scale_factor\n            \n            # Ensure risk stays in 0-1 range\n            stats['risk'] = min(1.0, max(0.0, scaled_risk))\n            stats['risk_history'].append(stats['risk'])\n            \n            logger.info(f\"Pattern {pattern_type} - Accuracy: {current_accuracy:.2f}, Risk: {stats['risk']:.2f}\")\n        \n        # Take a snapshot every few epochs\n        if epoch % 3 == 0:\n            self.take_snapshot(epoch)\n    \n    def take_snapshot(self, epoch):\n        \"\"\"\n        Take a snapshot of current risk and accuracy metrics."
        },
        "take_snapshot": {
          "start_line": 187,
          "end_line": 217,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "epoch"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "self.pattern_stats.items",
              "line": 206
            },
            {
              "name": "self.snapshots.append",
              "line": 214
            },
            {
              "name": "time.time",
              "line": 199
            },
            {
              "name": "self.get_overall_risk",
              "line": 201
            },
            {
              "name": "self.get_overall_accuracy",
              "line": 202
            }
          ],
          "docstring": "\n        Take a snapshot of current risk and accuracy metrics.\n        \n        Args:\n            epoch: Current epoch number\n        \n        Returns:\n            Snapshot data\n        ",
          "code_snippet": "            self.take_snapshot(epoch)\n    \n    def take_snapshot(self, epoch):\n        \"\"\"\n        Take a snapshot of current risk and accuracy metrics.\n        \n        Args:\n            epoch: Current epoch number\n        \n        Returns:\n            Snapshot data\n        \"\"\"\n        snapshot = {\n            'epoch': epoch,\n            'timestamp': time.time(),\n            'pattern_metrics': {},\n            'overall_risk': self.get_overall_risk(),\n            'overall_accuracy': self.get_overall_accuracy()\n        }\n        \n        # Add pattern-specific metrics\n        for pattern_type, stats in self.pattern_stats.items():\n            if stats['total'] > 0:\n                snapshot['pattern_metrics'][pattern_type] = {\n                    'accuracy': stats['accuracy'],\n                    'risk': stats['risk'],\n                    'total_examples': stats['total']\n                }\n        \n        self.snapshots.append(snapshot)\n        return snapshot\n    \n    def get_pattern_risks(self):\n        \"\"\"\n        Get current risk levels for all patterns."
        },
        "get_pattern_risks": {
          "start_line": 217,
          "end_line": 229,
          "parameters": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "self.pattern_stats.items",
              "line": 226
            }
          ],
          "docstring": "\n        Get current risk levels for all patterns.\n        \n        Returns:\n            Dictionary of pattern types to risk levels\n        ",
          "code_snippet": "        return snapshot\n    \n    def get_pattern_risks(self):\n        \"\"\"\n        Get current risk levels for all patterns.\n        \n        Returns:\n            Dictionary of pattern types to risk levels\n        \"\"\"\n        return {\n            pattern_type: stats['risk']\n            for pattern_type, stats in self.pattern_stats.items()\n            if stats['total'] > 0\n        }\n    \n    def get_pattern_accuracies(self):\n        \"\"\""
        },
        "get_pattern_accuracies": {
          "start_line": 230,
          "end_line": 242,
          "parameters": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "self.pattern_stats.items",
              "line": 239
            }
          ],
          "docstring": "\n        Get current accuracy levels for all patterns.\n        \n        Returns:\n            Dictionary of pattern types to accuracy levels\n        ",
          "code_snippet": "        }\n    \n    def get_pattern_accuracies(self):\n        \"\"\"\n        Get current accuracy levels for all patterns.\n        \n        Returns:\n            Dictionary of pattern types to accuracy levels\n        \"\"\"\n        return {\n            pattern_type: stats['accuracy']\n            for pattern_type, stats in self.pattern_stats.items()\n            if stats['total'] > 0\n        }\n    \n    def get_overall_risk(self):\n        \"\"\""
        },
        "get_overall_risk": {
          "start_line": 243,
          "end_line": 272,
          "parameters": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "self.get_pattern_risks",
              "line": 250
            },
            {
              "name": "pattern_risks.items",
              "line": 256
            },
            {
              "name": "sum",
              "line": 265
            },
            {
              "name": "sum",
              "line": 266
            },
            {
              "name": "weighted_risks.append",
              "line": 262
            }
          ],
          "docstring": "\n        Get overall risk level across all patterns.\n        \n        Returns:\n            Overall risk level (0.0-1.0)\n        ",
          "code_snippet": "        }\n    \n    def get_overall_risk(self):\n        \"\"\"\n        Get overall risk level across all patterns.\n        \n        Returns:\n            Overall risk level (0.0-1.0)\n        \"\"\"\n        pattern_risks = self.get_pattern_risks()\n        if not pattern_risks:\n            return 0.5  # Default to medium risk\n        \n        # Weight risks by their importance\n        weighted_risks = []\n        for pattern_type, risk in pattern_risks.items():\n            # More weight to challenging patterns\n            weight = 2.0 if pattern_type in self.challenging_patterns else 1.0\n            # Even more weight to preferred patterns\n            weight = 3.0 if pattern_type in self.preferred_patterns else weight\n            \n            weighted_risks.append((risk, weight))\n        \n        # Calculate weighted average\n        total_risk = sum(risk * weight for risk, weight in weighted_risks)\n        total_weight = sum(weight for _, weight in weighted_risks)\n        \n        if total_weight > 0:\n            return total_risk / total_weight\n        return 0.5  # Default to medium risk\n    \n    def get_overall_accuracy(self):\n        \"\"\"\n        Get overall accuracy across all patterns."
        },
        "get_overall_accuracy": {
          "start_line": 272,
          "end_line": 301,
          "parameters": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "self.get_pattern_accuracies",
              "line": 279
            },
            {
              "name": "pattern_accuracies.items",
              "line": 285
            },
            {
              "name": "sum",
              "line": 294
            },
            {
              "name": "sum",
              "line": 295
            },
            {
              "name": "weighted_accuracies.append",
              "line": 291
            }
          ],
          "docstring": "\n        Get overall accuracy across all patterns.\n        \n        Returns:\n            Overall accuracy (0.0-1.0)\n        ",
          "code_snippet": "        return 0.5  # Default to medium risk\n    \n    def get_overall_accuracy(self):\n        \"\"\"\n        Get overall accuracy across all patterns.\n        \n        Returns:\n            Overall accuracy (0.0-1.0)\n        \"\"\"\n        pattern_accuracies = self.get_pattern_accuracies()\n        if not pattern_accuracies:\n            return 0.0\n        \n        # Weight accuracies by their importance\n        weighted_accuracies = []\n        for pattern_type, accuracy in pattern_accuracies.items():\n            # More weight to challenging patterns\n            weight = 2.0 if pattern_type in self.challenging_patterns else 1.0\n            # Even more weight to preferred patterns\n            weight = 3.0 if pattern_type in self.preferred_patterns else weight\n            \n            weighted_accuracies.append((accuracy, weight))\n        \n        # Calculate weighted average\n        total_accuracy = sum(acc * weight for acc, weight in weighted_accuracies)\n        total_weight = sum(weight for _, weight in weighted_accuracies)\n        \n        if total_weight > 0:\n            return total_accuracy / total_weight\n        return 0.0\n    \n    def get_preferred_patterns_metrics(self):\n        \"\"\"\n        Get metrics for preferred patterns."
        },
        "get_preferred_patterns_metrics": {
          "start_line": 301,
          "end_line": 337,
          "parameters": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "preferred_accuracies.append",
              "line": 321
            },
            {
              "name": "preferred_risks.append",
              "line": 322
            },
            {
              "name": "sum",
              "line": 333
            },
            {
              "name": "sum",
              "line": 334
            }
          ],
          "docstring": "\n        Get metrics for preferred patterns.\n        \n        Returns:\n            Dictionary with preferred patterns metrics\n        ",
          "code_snippet": "        return 0.0\n    \n    def get_preferred_patterns_metrics(self):\n        \"\"\"\n        Get metrics for preferred patterns.\n        \n        Returns:\n            Dictionary with preferred patterns metrics\n        \"\"\"\n        if not self.preferred_patterns:\n            return {\n                'accuracy': 0.0,\n                'risk': 0.5,\n                'patterns_tracked': 0\n            }\n        \n        preferred_accuracies = []\n        preferred_risks = []\n        patterns_tracked = 0\n        \n        for pattern_type in self.preferred_patterns:\n            if pattern_type in self.pattern_stats and self.pattern_stats[pattern_type]['total'] > 0:\n                preferred_accuracies.append(self.pattern_stats[pattern_type]['accuracy'])\n                preferred_risks.append(self.pattern_stats[pattern_type]['risk'])\n                patterns_tracked += 1\n        \n        if patterns_tracked == 0:\n            return {\n                'accuracy': 0.0,\n                'risk': 0.5,\n                'patterns_tracked': 0\n            }\n        \n        return {\n            'accuracy': sum(preferred_accuracies) / patterns_tracked,\n            'risk': sum(preferred_risks) / patterns_tracked,\n            'patterns_tracked': patterns_tracked\n        }\n    \n    def get_challenging_patterns_metrics(self):\n        \"\"\""
        },
        "get_challenging_patterns_metrics": {
          "start_line": 338,
          "end_line": 374,
          "parameters": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "challenging_accuracies.append",
              "line": 358
            },
            {
              "name": "challenging_risks.append",
              "line": 359
            },
            {
              "name": "sum",
              "line": 370
            },
            {
              "name": "sum",
              "line": 371
            }
          ],
          "docstring": "\n        Get metrics for challenging patterns.\n        \n        Returns:\n            Dictionary with challenging patterns metrics\n        ",
          "code_snippet": "        }\n    \n    def get_challenging_patterns_metrics(self):\n        \"\"\"\n        Get metrics for challenging patterns.\n        \n        Returns:\n            Dictionary with challenging patterns metrics\n        \"\"\"\n        if not self.challenging_patterns:\n            return {\n                'accuracy': 0.0,\n                'risk': 0.5,\n                'patterns_tracked': 0\n            }\n        \n        challenging_accuracies = []\n        challenging_risks = []\n        patterns_tracked = 0\n        \n        for pattern_type in self.challenging_patterns:\n            if pattern_type in self.pattern_stats and self.pattern_stats[pattern_type]['total'] > 0:\n                challenging_accuracies.append(self.pattern_stats[pattern_type]['accuracy'])\n                challenging_risks.append(self.pattern_stats[pattern_type]['risk'])\n                patterns_tracked += 1\n        \n        if patterns_tracked == 0:\n            return {\n                'accuracy': 0.0,\n                'risk': 0.5,\n                'patterns_tracked': 0\n            }\n        \n        return {\n            'accuracy': sum(challenging_accuracies) / patterns_tracked,\n            'risk': sum(challenging_risks) / patterns_tracked,\n            'patterns_tracked': patterns_tracked\n        }\n    \n    def get_status(self):\n        \"\"\""
        },
        "get_status": {
          "start_line": 375,
          "end_line": 391,
          "parameters": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "self.get_overall_risk",
              "line": 383
            },
            {
              "name": "self.get_overall_accuracy",
              "line": 384
            },
            {
              "name": "self.get_pattern_risks",
              "line": 385
            },
            {
              "name": "self.get_pattern_accuracies",
              "line": 386
            },
            {
              "name": "self.get_preferred_patterns_metrics",
              "line": 387
            },
            {
              "name": "self.get_challenging_patterns_metrics",
              "line": 388
            },
            {
              "name": "sum",
              "line": 389
            },
            {
              "name": "self.pattern_stats.values",
              "line": 389
            }
          ],
          "docstring": "\n        Get comprehensive status of the tracker.\n        \n        Returns:\n            Dictionary with status information\n        ",
          "code_snippet": "        }\n    \n    def get_status(self):\n        \"\"\"\n        Get comprehensive status of the tracker.\n        \n        Returns:\n            Dictionary with status information\n        \"\"\"\n        return {\n            'overall_risk': self.get_overall_risk(),\n            'overall_accuracy': self.get_overall_accuracy(),\n            'pattern_risks': self.get_pattern_risks(),\n            'pattern_accuracies': self.get_pattern_accuracies(),\n            'preferred_patterns': self.get_preferred_patterns_metrics(),\n            'challenging_patterns': self.get_challenging_patterns_metrics(),\n            'total_patterns_tracked': sum(1 for stats in self.pattern_stats.values() if stats['total'] > 0)\n        }"
        }
      },
      "class_variables": [],
      "bases": [],
      "docstring": "\n    Unified tracker for pattern risk and accuracy.\n    \n    This class directly links pattern accuracy to risk assessment,\n    viewing them as two sides of the same coin.\n    "
    }
  },
  "functions": {},
  "constants": {}
}