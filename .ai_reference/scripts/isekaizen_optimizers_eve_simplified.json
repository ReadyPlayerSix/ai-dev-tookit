{
  "path": "D:\\Projects\\isekaiZen\\machine-learning-optimizer\\isekaizen\\optimizers\\eve_simplified.py",
  "imports": [
    {
      "name": "math",
      "line": 8
    },
    {
      "name": "torch",
      "line": 9
    },
    {
      "name": "torch.optim.Optimizer",
      "line": 10
    },
    {
      "name": "typing.List",
      "line": 11
    },
    {
      "name": "typing.Optional",
      "line": 11
    },
    {
      "name": "typing.Dict",
      "line": 11
    },
    {
      "name": "typing.Tuple",
      "line": 11
    },
    {
      "name": "logging",
      "line": 12
    },
    {
      "name": "isekaizen.optimizers.eve.EVENaturalWeights",
      "line": 15
    }
  ],
  "classes": {
    "EVESimplifiedRatio": {
      "start_line": 19,
      "end_line": 116,
      "methods": {
        "__init__": {
          "start_line": 28,
          "end_line": 39,
          "parameters": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "....__init__",
              "line": 30
            },
            {
              "name": "logger.info",
              "line": 37
            },
            {
              "name": "super",
              "line": 30
            }
          ],
          "code_snippet": "    \"\"\"\n    \n    def __init__(self, *args, **kwargs):\n        # Initialize with parent class\n        super().__init__(*args, **kwargs)\n        \n        # Initialize ratio tracking\n        self.tt_ratio = 1.0  # Train/Test ratio (1.0 = balanced)\n        self.ra_ratio = 0.0  # Risk/Accuracy ratio (0.0 = no risk)\n        self.ratio_decision = {\"action\": \"none\"}  # Most recent decision\n        \n        logger.info(\"EVESimplifiedRatio initialized with ratio-based decision making\")\n    \n    def update_with_ratios(self, tt_ratio, ra_ratio):\n        \"\"\"\n        Update optimizer based on Train/Test and Risk/Accuracy ratios."
        },
        "update_with_ratios": {
          "start_line": 39,
          "end_line": 88,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "tt_ratio"
            },
            {
              "name": "ra_ratio"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "logger.info",
              "line": 55
            },
            {
              "name": "logger.info",
              "line": 63
            },
            {
              "name": "max",
              "line": 68
            },
            {
              "name": "logger.info",
              "line": 69
            },
            {
              "name": "max",
              "line": 74
            },
            {
              "name": "max",
              "line": 75
            },
            {
              "name": "logger.info",
              "line": 76
            },
            {
              "name": "logger.info",
              "line": 81
            }
          ],
          "docstring": "\n        Update optimizer based on Train/Test and Risk/Accuracy ratios.\n        \n        Args:\n            tt_ratio: Train/Test ratio (> 1 indicates overfitting)\n            ra_ratio: Risk/Accuracy ratio (> 0 indicates pattern issues)\n            \n        Returns:\n            Decision dictionary with action and parameters\n        ",
          "code_snippet": "        logger.info(\"EVESimplifiedRatio initialized with ratio-based decision making\")\n    \n    def update_with_ratios(self, tt_ratio, ra_ratio):\n        \"\"\"\n        Update optimizer based on Train/Test and Risk/Accuracy ratios.\n        \n        Args:\n            tt_ratio: Train/Test ratio (> 1 indicates overfitting)\n            ra_ratio: Risk/Accuracy ratio (> 0 indicates pattern issues)\n            \n        Returns:\n            Decision dictionary with action and parameters\n        \"\"\"\n        # Store the ratios\n        self.tt_ratio = tt_ratio\n        self.ra_ratio = ra_ratio\n        \n        # Log the situation\n        logger.info(f\"Optimizer evaluating - Train/Test Ratio: {tt_ratio:.3f}, Risk/Accuracy Ratio: {ra_ratio:.3f}\")\n        \n        # Decision thresholds\n        tt_threshold = 1.05  # Allow a small amount of overfitting\n        ra_threshold = 0.3   # Fraction of patterns getting worse\n        \n        # Case 1: All good - no changes needed\n        if tt_ratio <= tt_threshold and ra_ratio <= ra_threshold:\n            logger.info(\"All metrics good - continuing with current parameters\")\n            decision = {\"action\": \"none\"}\n            \n        # Case 2: Overfitting but patterns improving - adjust LR\n        elif tt_ratio > tt_threshold and ra_ratio <= ra_threshold:\n            adjustment = max(0.7, 1.0 - (tt_ratio - 1.0) * 0.5)\n            logger.info(f\"Overfitting detected - reducing LR by factor {adjustment:.3f}\")\n            decision = {\"action\": \"adjust_lr\", \"factor\": adjustment}\n            \n        # Case 3: Serious issues - adjust LR and batch size\n        elif tt_ratio > tt_threshold and ra_ratio > ra_threshold:\n            lr_adjustment = max(0.5, 1.0 - (tt_ratio - 1.0) * 0.7)\n            batch_adjustment = max(0.5, 1.0 - ra_ratio * 0.6)\n            logger.info(f\"Serious issues - reducing LR by {lr_adjustment:.3f} and batch size by {batch_adjustment:.3f}\")\n            decision = {\"action\": \"adjust_both\", \"lr_factor\": lr_adjustment, \"batch_factor\": batch_adjustment}\n            \n        # Case 4: Patterns need more examples - augment data\n        else:  # tt_ratio <= tt_threshold and ra_ratio > ra_threshold\n            logger.info(f\"Pattern accuracy issues - triggering data augmentation\")\n            decision = {\"action\": \"augment_data\", \"ratio\": ra_ratio}\n        \n        # Store the decision for access by other components\n        self.ratio_decision = decision\n        return decision\n    \n    def apply_decision(self):\n        \"\"\"\n        Apply the most recent ratio-based decision."
        },
        "apply_decision": {
          "start_line": 88,
          "end_line": 116,
          "parameters": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "self.ratio_decision.get",
              "line": 100
            },
            {
              "name": "hasattr",
              "line": 95
            },
            {
              "name": "self.ratio_decision.get",
              "line": 95
            },
            {
              "name": "logger.info",
              "line": 111
            }
          ],
          "docstring": "\n        Apply the most recent ratio-based decision.\n        \n        Returns:\n            True if changes were made, False otherwise\n        ",
          "code_snippet": "        return decision\n    \n    def apply_decision(self):\n        \"\"\"\n        Apply the most recent ratio-based decision.\n        \n        Returns:\n            True if changes were made, False otherwise\n        \"\"\"\n        if not hasattr(self, 'ratio_decision') or self.ratio_decision.get('action') == 'none':\n            return False\n            \n        # Handle learning rate adjustments\n        if self.ratio_decision['action'] in ['adjust_lr', 'adjust_both']:\n            factor = self.ratio_decision.get('lr_factor', 1.0)\n            \n            if factor < 1.0:\n                # Get current learning rate\n                current_lr = self.param_groups[0]['lr']\n                new_lr = current_lr * factor\n                \n                # Apply the adjustment\n                for param_group in self.param_groups:\n                    param_group['lr'] = new_lr\n                    \n                logger.info(f\"Applied LR adjustment: {current_lr:.6f} \u2192 {new_lr:.6f}\")\n                return True\n                \n        return False"
        }
      },
      "class_variables": [],
      "bases": [
        "EVENaturalWeights"
      ],
      "docstring": "\n    EVE optimizer variant with simplified ratio-based decision making.\n    \n    This class extends EVENaturalWeights with additional methods to make decisions\n    based on Train/Test and Risk/Accuracy ratios, without the computational overhead\n    of detailed pattern tracking.\n    "
    }
  },
  "functions": {},
  "constants": {}
}