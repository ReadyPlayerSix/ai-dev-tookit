{
  "path": "D:\\Projects\\isekaiZen\\machine-learning-optimizer\\benchmarks.old\\models\\src\\utils\\input_translator.py",
  "imports": [
    {
      "name": "src.utils.types.Pattern",
      "line": 4
    },
    {
      "name": "src.utils.types.PatternType",
      "line": 4
    },
    {
      "name": "src.utils.types.DomainType",
      "line": 4
    },
    {
      "name": "src.utils.types.CortexFlowMetadata",
      "line": 4
    },
    {
      "name": "src.utils.types.ProcessingStage",
      "line": 4
    },
    {
      "name": "numpy",
      "line": 5
    },
    {
      "name": "random",
      "line": 6
    },
    {
      "name": "typing.Dict",
      "line": 7
    },
    {
      "name": "typing.Any",
      "line": 7
    },
    {
      "name": "typing.Optional",
      "line": 7
    },
    {
      "name": "datetime.datetime",
      "line": 8
    },
    {
      "name": "time",
      "line": 9
    }
  ],
  "classes": {
    "InputTranslator": {
      "start_line": 11,
      "end_line": 147,
      "methods": {
        "translate_raw_input": {
          "start_line": 13,
          "end_line": 147,
          "parameters": [
            {
              "name": "domain",
              "type": "DomainType"
            },
            {
              "name": "raw_input",
              "type": "dict"
            },
            {
              "name": "flow_metadata"
            }
          ],
          "return_type": "Pattern",
          "calls": [
            {
              "name": "np.random.uniform",
              "line": 34
            },
            {
              "name": "round",
              "line": 37
            },
            {
              "name": "round",
              "line": 38
            },
            {
              "name": "round",
              "line": 39
            },
            {
              "name": "random.choice",
              "line": 42
            },
            {
              "name": "Pattern",
              "line": 45
            },
            {
              "name": "CortexFlowMetadata",
              "line": 21
            },
            {
              "name": "isinstance",
              "line": 30
            },
            {
              "name": "random.uniform",
              "line": 37
            },
            {
              "name": "random.uniform",
              "line": 38
            },
            {
              "name": "random.uniform",
              "line": 39
            },
            {
              "name": "raw_input.get",
              "line": 63
            },
            {
              "name": "np.array",
              "line": 65
            },
            {
              "name": "Pattern",
              "line": 66
            },
            {
              "name": "raw_input.get",
              "line": 82
            },
            {
              "name": "raw_input.get",
              "line": 83
            },
            {
              "name": "np.array",
              "line": 84
            },
            {
              "name": "Pattern",
              "line": 85
            },
            {
              "name": "str",
              "line": 22
            },
            {
              "name": "datetime.now",
              "line": 23
            },
            {
              "name": "raw_input.get",
              "line": 64
            },
            {
              "name": "raw_input.get",
              "line": 64
            },
            {
              "name": "dict",
              "line": 78
            },
            {
              "name": "raw_input.get",
              "line": 101
            },
            {
              "name": "raw_input.get",
              "line": 102
            },
            {
              "name": "np.array",
              "line": 109
            },
            {
              "name": "dict",
              "line": 112
            },
            {
              "name": "Pattern",
              "line": 116
            },
            {
              "name": "Pattern",
              "line": 133
            },
            {
              "name": "time.time",
              "line": 22
            },
            {
              "name": "dict",
              "line": 97
            },
            {
              "name": "isinstance",
              "line": 104
            },
            {
              "name": "isinstance",
              "line": 113
            },
            {
              "name": "sum",
              "line": 108
            },
            {
              "name": "len",
              "line": 108
            },
            {
              "name": "np.array",
              "line": 134
            },
            {
              "name": "emotion_scores.values",
              "line": 108
            }
          ],
          "docstring": "Translate raw input into a Pattern with flow tracking",
          "code_snippet": "class InputTranslator:\n    @staticmethod\n    def translate_raw_input(\n        domain: DomainType, \n        raw_input: dict,\n        flow_metadata: Optional[CortexFlowMetadata] = None\n    ) -> Pattern:\n        \"\"\"Translate raw input into a Pattern with flow tracking\"\"\"\n        # Create default flow metadata if none provided\n        if flow_metadata is None:\n            flow_metadata = CortexFlowMetadata(\n                flow_id=str(time.time()),\n                creation_time=datetime.now(),\n                source_domain=domain,\n                current_stage=ProcessingStage.INPUT,\n                processing_history=[]\n            )\n\n        # Ensure domain_data is a dictionary\n        if not isinstance(raw_input, dict):\n            raw_input = {\"raw_data\": raw_input}\n\n        # Generate signature as a simple random vector of fixed length\n        signature = np.random.uniform(0.0, 1.0, size=3)\n\n        # Assign complexity, weight, and confidence with no domain-specific assumptions\n        weight = round(random.uniform(0.3, 0.7), 2)\n        complexity = round(random.uniform(0.2, 0.8), 2)\n        confidence = round(random.uniform(0.4, 0.6), 2)\n\n        # Assign pattern type randomly to promote diverse initial learning\n        pattern_type = random.choice([PatternType.OPPORTUNITY, PatternType.RISK])\n\n        # Construct and return the Pattern object\n        return Pattern(\n            signature=signature,\n            weight=weight,\n            pattern_type=pattern_type,\n            complexity=complexity,\n            domain=domain,\n            confidence=confidence,\n            preservation_score=1.0,\n            times_encountered=0,\n            xp_value=100.0,\n            power_level=1,\n            batch_size=1,\n            domain_data=raw_input,\n            flow_metadata=flow_metadata\n        )\n\n        batch_size = 1\n        if domain == DomainType.VISUAL:\n            confidence = raw_input.get(\"confidence\", 0.5)\n            complexity = raw_input.get(\"width\", 640) * raw_input.get(\"height\", 480) / 1e6  # proxy for complexity\n            signature = np.array([confidence, complexity])\n            return Pattern(\n                signature=signature,\n                weight=confidence,\n                pattern_type=PatternType.OPPORTUNITY if confidence > 0.7 else PatternType.RISK,\n                complexity=complexity,\n                domain=domain,\n                confidence=confidence,\n                preservation_score=1.0,\n                times_encountered=1,\n                xp_value=100.0,\n                power_level=1,\n                batch_size=batch_size,\n                domain_data=dict(raw_input)  # ensure it's a dict\n            )\n        \n        elif domain == DomainType.LINGUISTIC:\n            confidence = raw_input.get(\"confidence\", 0.5)\n            complexity = raw_input.get(\"grammar_score\", 0.5)\n            signature = np.array([confidence, complexity])\n            return Pattern(\n                signature=signature,\n                weight=confidence,\n                pattern_type=PatternType.OPPORTUNITY if confidence > 0.7 else PatternType.RISK,\n                complexity=complexity,\n                domain=domain,\n                confidence=confidence,\n                preservation_score=1.0,\n                times_encountered=1,\n                xp_value=100.0,\n                power_level=1,\n                batch_size=batch_size,\n                domain_data=dict(raw_input)  # ensure it's a dict\n            )\n        \n        elif domain == DomainType.EMOTIONAL:\n            confidence = raw_input.get(\"confidence\", 0.5)\n            emotion_scores = raw_input.get(\"emotion_scores\", {})\n            # Ensure emotion_scores is a dictionary\n            if not isinstance(emotion_scores, dict):\n                emotion_scores = {\"raw_scores\": emotion_scores}\n\n            # Calculate complexity as the average of the emotion scores\n            complexity = sum(emotion_scores.values()) / len(emotion_scores) if emotion_scores else 0.5\n            signature = np.array([confidence, complexity])\n\n            # Ensure domain_data is a dictionary\n            domain_data = dict(raw_input)\n            if not isinstance(domain_data, dict):\n                domain_data = {\"raw_data\": raw_input}\n            \n            return Pattern(\n                signature=signature,\n                weight=confidence,\n                pattern_type=PatternType.OPPORTUNITY if confidence > 0.7 else PatternType.RISK,\n                complexity=complexity,\n                domain=domain,\n                confidence=confidence,\n                preservation_score=1.0,\n                times_encountered=1,\n                xp_value=100.0,\n                power_level=1,\n                batch_size=batch_size,\n                domain_data=domain_data  # guaranteed dictionary now\n            )\n        \n        else:\n            # Unknown domain fallback\n            return Pattern(\n                signature=np.array([0.5]),\n                weight=0.5,\n                pattern_type=PatternType.RISK,\n                complexity=1.0,\n                domain=domain,\n                confidence=0.5,\n                preservation_score=1.0,\n                times_encountered=1,\n                xp_value=100.0,\n                power_level=1,\n                batch_size=batch_size,\n                domain_data={\"raw_data\": raw_input}  # fallback dict\n            )"
        }
      },
      "class_variables": [],
      "bases": []
    }
  },
  "functions": {},
  "constants": {}
}