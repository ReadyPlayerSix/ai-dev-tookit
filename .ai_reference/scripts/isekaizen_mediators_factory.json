{
  "path": "D:\\Projects\\isekaiZen\\machine-learning-optimizer\\isekaizen\\mediators\\factory.py",
  "imports": [
    {
      "name": "logging",
      "line": 8
    },
    {
      "name": "torch",
      "line": 9
    },
    {
      "name": "typing.Dict",
      "line": 10
    },
    {
      "name": "typing.Any",
      "line": 10
    },
    {
      "name": "typing.Optional",
      "line": 10
    },
    {
      "name": "typing.List",
      "line": 10
    },
    {
      "name": "typing.Union",
      "line": 10
    },
    {
      "name": "isekaizen.mediators.base.Mediator",
      "line": 12
    },
    {
      "name": "isekaizen.mediators.base.MediatorInitializationError",
      "line": 12
    },
    {
      "name": "isekaizen.mediators.pattern.data_mediator.PatternDataMediator",
      "line": 33
    },
    {
      "name": "isekaizen.mediators.augmentation.template_mediator.AugmentationMediator",
      "line": 58
    },
    {
      "name": "isekaizen.mediators.ratio.ratio_tracker.UnifiedRatioTracker",
      "line": 91
    },
    {
      "name": "isekaizen.mediators.ratio.equilibrium_mediator.PatternEquilibriumTracker",
      "line": 116
    },
    {
      "name": "isekaizen.mediators.augmentation.specialized",
      "line": 271
    },
    {
      "name": "isekaizen.mediators.pattern.specialized",
      "line": 281
    },
    {
      "name": "isekaizen.mediators.augmentation.specialized",
      "line": 242
    },
    {
      "name": "isekaizen.mediators.pattern.specialized",
      "line": 247
    }
  ],
  "classes": {},
  "functions": {
    "create_pattern_mediator": {
      "start_line": 16,
      "end_line": 41,
      "parameters": [
        {
          "name": "pattern_map"
        }
      ],
      "return_type": null,
      "calls": [
        {
          "name": "PatternDataMediator",
          "line": 34
        },
        {
          "name": "logger.info",
          "line": 35
        },
        {
          "name": "logger.error",
          "line": 38
        },
        {
          "name": "MediatorInitializationError",
          "line": 39
        },
        {
          "name": "hasattr",
          "line": 35
        },
        {
          "name": "len",
          "line": 35
        },
        {
          "name": "str",
          "line": 38
        },
        {
          "name": "str",
          "line": 39
        },
        {
          "name": "mediator.get_pattern_types",
          "line": 35
        }
      ],
      "docstring": "\n    Create and return a pattern data mediator instance.\n    \n    Args:\n        pattern_map: Pattern map containing pattern information\n        **kwargs: Additional arguments for the mediator\n        \n    Returns:\n        PatternDataMediator instance\n    \n    Raises:\n        MediatorInitializationError: If initialization fails\n    ",
      "code_snippet": "logger = logging.getLogger(__name__)\n\ndef create_pattern_mediator(pattern_map=None, **kwargs):\n    \"\"\"\n    Create and return a pattern data mediator instance.\n    \n    Args:\n        pattern_map: Pattern map containing pattern information\n        **kwargs: Additional arguments for the mediator\n        \n    Returns:\n        PatternDataMediator instance\n    \n    Raises:\n        MediatorInitializationError: If initialization fails\n    \"\"\"\n    try:\n        # Import here to avoid circular imports\n        # Will need to be implemented in pattern/data_mediator.py\n        from isekaizen.mediators.pattern.data_mediator import PatternDataMediator\n        mediator = PatternDataMediator(pattern_map=pattern_map, **kwargs)\n        logger.info(f\"Created PatternDataMediator with {len(mediator.get_pattern_types()) if hasattr(mediator, 'get_pattern_types') else 0} pattern types\")\n        return mediator\n    except Exception as e:\n        logger.error(f\"Failed to create PatternDataMediator: {str(e)}\")\n        raise MediatorInitializationError(f\"Failed to create PatternDataMediator: {str(e)}\") from e\n\ndef create_augmentation_mediator(dataset, pattern_map=None, device=None, **kwargs):\n    \"\"\"\n    Create and return an augmentation mediator instance."
    },
    "create_augmentation_mediator": {
      "start_line": 41,
      "end_line": 75,
      "parameters": [
        {
          "name": "dataset"
        },
        {
          "name": "pattern_map"
        },
        {
          "name": "device"
        }
      ],
      "return_type": null,
      "calls": [
        {
          "name": "AugmentationMediator",
          "line": 64
        },
        {
          "name": "mediator.initialize",
          "line": 67
        },
        {
          "name": "logger.info",
          "line": 69
        },
        {
          "name": "torch.device",
          "line": 62
        },
        {
          "name": "logger.error",
          "line": 72
        },
        {
          "name": "MediatorInitializationError",
          "line": 73
        },
        {
          "name": "torch.cuda.is_available",
          "line": 62
        },
        {
          "name": "len",
          "line": 69
        },
        {
          "name": "str",
          "line": 72
        },
        {
          "name": "str",
          "line": 73
        }
      ],
      "docstring": "\n    Create and return an augmentation mediator instance.\n    \n    Args:\n        dataset: The dataset to augment\n        pattern_map: Pattern map containing pattern information\n        device: Computation device (CPU/GPU)\n        **kwargs: Additional arguments for the mediator\n        \n    Returns:\n        AugmentationMediator instance\n    \n    Raises:\n        MediatorInitializationError: If initialization fails\n    ",
      "code_snippet": "        raise MediatorInitializationError(f\"Failed to create PatternDataMediator: {str(e)}\") from e\n\ndef create_augmentation_mediator(dataset, pattern_map=None, device=None, **kwargs):\n    \"\"\"\n    Create and return an augmentation mediator instance.\n    \n    Args:\n        dataset: The dataset to augment\n        pattern_map: Pattern map containing pattern information\n        device: Computation device (CPU/GPU)\n        **kwargs: Additional arguments for the mediator\n        \n    Returns:\n        AugmentationMediator instance\n    \n    Raises:\n        MediatorInitializationError: If initialization fails\n    \"\"\"\n    try:\n        from isekaizen.mediators.augmentation.template_mediator import AugmentationMediator\n        \n        # Set default device if not provided\n        if device is None:\n            device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')\n        \n        mediator = AugmentationMediator(dataset=dataset, pattern_map=pattern_map, device=device, **kwargs)\n        \n        # Initialize the mediator\n        mediator.initialize()\n        \n        logger.info(f\"Created AugmentationMediator for dataset with {len(dataset) if dataset is not None else 0} examples\")\n        return mediator\n    except Exception as e:\n        logger.error(f\"Failed to create AugmentationMediator: {str(e)}\")\n        raise MediatorInitializationError(f\"Failed to create AugmentationMediator: {str(e)}\") from e\n\ndef create_ratio_tracker(pattern_map=None, **kwargs):\n    \"\"\"\n    Create and return a unified ratio tracker instance."
    },
    "create_ratio_tracker": {
      "start_line": 75,
      "end_line": 99,
      "parameters": [
        {
          "name": "pattern_map"
        }
      ],
      "return_type": null,
      "calls": [
        {
          "name": "UnifiedRatioTracker",
          "line": 92
        },
        {
          "name": "logger.info",
          "line": 93
        },
        {
          "name": "logger.error",
          "line": 96
        },
        {
          "name": "MediatorInitializationError",
          "line": 97
        },
        {
          "name": "str",
          "line": 96
        },
        {
          "name": "str",
          "line": 97
        }
      ],
      "docstring": "\n    Create and return a unified ratio tracker instance.\n    \n    Args:\n        pattern_map: Pattern map containing pattern information\n        **kwargs: Additional arguments for the tracker\n        \n    Returns:\n        UnifiedRatioTracker instance\n    \n    Raises:\n        MediatorInitializationError: If initialization fails\n    ",
      "code_snippet": "        raise MediatorInitializationError(f\"Failed to create AugmentationMediator: {str(e)}\") from e\n\ndef create_ratio_tracker(pattern_map=None, **kwargs):\n    \"\"\"\n    Create and return a unified ratio tracker instance.\n    \n    Args:\n        pattern_map: Pattern map containing pattern information\n        **kwargs: Additional arguments for the tracker\n        \n    Returns:\n        UnifiedRatioTracker instance\n    \n    Raises:\n        MediatorInitializationError: If initialization fails\n    \"\"\"\n    try:\n        # Will need to be implemented in ratio/ratio_tracker.py\n        from isekaizen.mediators.ratio.ratio_tracker import UnifiedRatioTracker\n        tracker = UnifiedRatioTracker(**kwargs)\n        logger.info(\"Created UnifiedRatioTracker\")\n        return tracker\n    except Exception as e:\n        logger.error(f\"Failed to create UnifiedRatioTracker: {str(e)}\")\n        raise MediatorInitializationError(f\"Failed to create UnifiedRatioTracker: {str(e)}\") from e\n\ndef create_equilibrium_tracker(pattern_complexities=None, pattern_distribution=None, **kwargs):\n    \"\"\"\n    Create and return a pattern equilibrium tracker instance."
    },
    "create_equilibrium_tracker": {
      "start_line": 99,
      "end_line": 137,
      "parameters": [
        {
          "name": "pattern_complexities"
        },
        {
          "name": "pattern_distribution"
        }
      ],
      "return_type": null,
      "calls": [
        {
          "name": "kwargs.pop",
          "line": 119
        },
        {
          "name": "PatternEquilibriumTracker",
          "line": 125
        },
        {
          "name": "logger.info",
          "line": 131
        },
        {
          "name": "pattern_map.get",
          "line": 121
        },
        {
          "name": "pattern_map.get",
          "line": 123
        },
        {
          "name": "logger.error",
          "line": 134
        },
        {
          "name": "MediatorInitializationError",
          "line": 135
        },
        {
          "name": "str",
          "line": 134
        },
        {
          "name": "str",
          "line": 135
        }
      ],
      "docstring": "\n    Create and return a pattern equilibrium tracker instance.\n    \n    Args:\n        pattern_complexities: Dictionary of pattern types to complexity scores\n        pattern_distribution: Dictionary of pattern types to distribution values\n        **kwargs: Additional arguments for the tracker\n        \n    Returns:\n        PatternEquilibriumTracker instance\n    \n    Raises:\n        MediatorInitializationError: If initialization fails\n    ",
      "code_snippet": "        raise MediatorInitializationError(f\"Failed to create UnifiedRatioTracker: {str(e)}\") from e\n\ndef create_equilibrium_tracker(pattern_complexities=None, pattern_distribution=None, **kwargs):\n    \"\"\"\n    Create and return a pattern equilibrium tracker instance.\n    \n    Args:\n        pattern_complexities: Dictionary of pattern types to complexity scores\n        pattern_distribution: Dictionary of pattern types to distribution values\n        **kwargs: Additional arguments for the tracker\n        \n    Returns:\n        PatternEquilibriumTracker instance\n    \n    Raises:\n        MediatorInitializationError: If initialization fails\n    \"\"\"\n    try:\n        # Will need to be implemented in ratio/equilibrium_mediator.py\n        from isekaizen.mediators.ratio.equilibrium_mediator import PatternEquilibriumTracker\n        \n        # Extract from pattern map if provided\n        pattern_map = kwargs.pop('pattern_map', None)\n        if pattern_map and not pattern_complexities:\n            pattern_complexities = pattern_map.get('pattern_complexities', None)\n        if pattern_map and not pattern_distribution:\n            pattern_distribution = pattern_map.get('pattern_distribution', None)\n        \n        tracker = PatternEquilibriumTracker(\n            pattern_complexities=pattern_complexities,\n            pattern_distribution=pattern_distribution,\n            **kwargs\n        )\n        \n        logger.info(\"Created PatternEquilibriumTracker\")\n        return tracker\n    except Exception as e:\n        logger.error(f\"Failed to create PatternEquilibriumTracker: {str(e)}\")\n        raise MediatorInitializationError(f\"Failed to create PatternEquilibriumTracker: {str(e)}\") from e\n\ndef get_all_mediator_types() -> List[str]:\n    \"\"\"\n    Get a list of all available mediator types."
    },
    "get_all_mediator_types": {
      "start_line": 137,
      "end_line": 150,
      "parameters": [],
      "return_type": "complex_type",
      "calls": [],
      "docstring": "\n    Get a list of all available mediator types.\n    \n    Returns:\n        List of mediator type names\n    ",
      "code_snippet": "        raise MediatorInitializationError(f\"Failed to create PatternEquilibriumTracker: {str(e)}\") from e\n\ndef get_all_mediator_types() -> List[str]:\n    \"\"\"\n    Get a list of all available mediator types.\n    \n    Returns:\n        List of mediator type names\n    \"\"\"\n    return [\n        \"pattern_mediator\",\n        \"augmentation_mediator\", \n        \"ratio_tracker\",\n        \"equilibrium_tracker\"\n    ]\n\ndef create_mediator(mediator_type: str, **kwargs) -> Mediator:\n    \"\"\""
    },
    "create_mediator": {
      "start_line": 151,
      "end_line": 226,
      "parameters": [
        {
          "name": "mediator_type",
          "type": "str"
        }
      ],
      "return_type": "Mediator",
      "calls": [
        {
          "name": "kwargs.pop",
          "line": 170
        },
        {
          "name": "kwargs.pop",
          "line": 171
        },
        {
          "name": "kwargs.pop",
          "line": 172
        },
        {
          "name": "logger.info",
          "line": 185
        },
        {
          "name": "list",
          "line": 213
        },
        {
          "name": "_get_available_specialized_mediators",
          "line": 214
        },
        {
          "name": "ValueError",
          "line": 217
        },
        {
          "name": "isinstance",
          "line": 220
        },
        {
          "name": "kwargs.update",
          "line": 221
        },
        {
          "name": "_get_specialized_mediator_factory",
          "line": 190
        },
        {
          "name": "_get_specialized_mediator_factory",
          "line": 198
        },
        {
          "name": "_get_specialized_mediator_factory",
          "line": 206
        },
        {
          "name": "mediator_factories.keys",
          "line": 213
        },
        {
          "name": "available_types.extend",
          "line": 216
        },
        {
          "name": "logger.info",
          "line": 192
        },
        {
          "name": "specialized_factory",
          "line": 193
        },
        {
          "name": "logger.info",
          "line": 200
        },
        {
          "name": "model_factory",
          "line": 201
        },
        {
          "name": "logger.info",
          "line": 208
        },
        {
          "name": "dataset_factory",
          "line": 209
        }
      ],
      "docstring": "\n    Create a mediator of the specified type.\n    \n    Args:\n        mediator_type: Type of mediator to create\n        **kwargs: Arguments for the mediator\n            - model_type: Optional model architecture type (e.g., 'resnet', 'transformer')\n            - dataset_type: Optional dataset type (e.g., 'image', 'text', 'tabular')\n            - custom_config: Optional dict with mediator-specific configuration\n        \n    Returns:\n        Mediator instance\n    \n    Raises:\n        ValueError: If mediator_type is invalid\n        MediatorInitializationError: If mediator creation fails\n    ",
      "code_snippet": "    ]\n\ndef create_mediator(mediator_type: str, **kwargs) -> Mediator:\n    \"\"\"\n    Create a mediator of the specified type.\n    \n    Args:\n        mediator_type: Type of mediator to create\n        **kwargs: Arguments for the mediator\n            - model_type: Optional model architecture type (e.g., 'resnet', 'transformer')\n            - dataset_type: Optional dataset type (e.g., 'image', 'text', 'tabular')\n            - custom_config: Optional dict with mediator-specific configuration\n        \n    Returns:\n        Mediator instance\n    \n    Raises:\n        ValueError: If mediator_type is invalid\n        MediatorInitializationError: If mediator creation fails\n    \"\"\"\n    # Extract model and dataset type for specialized mediators\n    model_type = kwargs.pop('model_type', None)\n    dataset_type = kwargs.pop('dataset_type', None)\n    custom_config = kwargs.pop('custom_config', None)\n    \n    # Core mediator factories\n    mediator_factories = {\n        \"pattern_mediator\": create_pattern_mediator,\n        \"augmentation_mediator\": create_augmentation_mediator,\n        \"ratio_tracker\": create_ratio_tracker,\n        \"equilibrium_tracker\": create_equilibrium_tracker\n    }\n    \n    # Check for model-specific or dataset-specific mediator types\n    if model_type or dataset_type:\n        # Log that we're looking for specialized mediators\n        logger.info(f\"Looking for specialized mediator for model_type={model_type}, dataset_type={dataset_type}\")\n        \n        # Try specialized mediator types first (format: \"type_model_dataset\")\n        if model_type and dataset_type:\n            specialized_type = f\"{mediator_type}_{model_type}_{dataset_type}\"\n            specialized_factory = _get_specialized_mediator_factory(specialized_type)\n            if specialized_factory:\n                logger.info(f\"Using specialized mediator: {specialized_type}\")\n                return specialized_factory(**kwargs)\n        \n        # Try model-specific mediators\n        if model_type:\n            model_specialized_type = f\"{mediator_type}_{model_type}\"\n            model_factory = _get_specialized_mediator_factory(model_specialized_type)\n            if model_factory:\n                logger.info(f\"Using model-specific mediator: {model_specialized_type}\")\n                return model_factory(**kwargs)\n                \n        # Try dataset-specific mediators\n        if dataset_type:\n            dataset_specialized_type = f\"{mediator_type}_{dataset_type}\"\n            dataset_factory = _get_specialized_mediator_factory(dataset_specialized_type)\n            if dataset_factory:\n                logger.info(f\"Using dataset-specific mediator: {dataset_specialized_type}\")\n                return dataset_factory(**kwargs)\n    \n    # Fall back to core mediator types\n    if mediator_type not in mediator_factories:\n        available_types = list(mediator_factories.keys())\n        specialized_types = _get_available_specialized_mediators()\n        if specialized_types:\n            available_types.extend(specialized_types)\n        raise ValueError(f\"Unknown mediator type: {mediator_type}. Available types: {available_types}\")\n    \n    # Apply custom configuration if provided\n    if custom_config and isinstance(custom_config, dict):\n        kwargs.update(custom_config)\n    \n    # Create the mediator using the factory\n    return mediator_factories[mediator_type](**kwargs)\n    \ndef _get_specialized_mediator_factory(specialized_type: str):\n    \"\"\"\n    Get a factory function for a specialized mediator type."
    },
    "_get_specialized_mediator_factory": {
      "start_line": 226,
      "end_line": 260,
      "parameters": [
        {
          "name": "specialized_type",
          "type": "str"
        }
      ],
      "return_type": null,
      "calls": [
        {
          "name": "specialized_type.startswith",
          "line": 241
        },
        {
          "name": "getattr",
          "line": 243
        },
        {
          "name": "specialized_type.startswith",
          "line": 246
        },
        {
          "name": "getattr",
          "line": 248
        }
      ],
      "docstring": "\n    Get a factory function for a specialized mediator type.\n    \n    This internal function dynamically checks for specialized mediator factories.\n    \n    Args:\n        specialized_type: Name of the specialized mediator type\n        \n    Returns:\n        Factory function or None if not found\n    ",
      "code_snippet": "    return mediator_factories[mediator_type](**kwargs)\n    \ndef _get_specialized_mediator_factory(specialized_type: str):\n    \"\"\"\n    Get a factory function for a specialized mediator type.\n    \n    This internal function dynamically checks for specialized mediator factories.\n    \n    Args:\n        specialized_type: Name of the specialized mediator type\n        \n    Returns:\n        Factory function or None if not found\n    \"\"\"\n    # Try to dynamically import specialized mediators (for extensibility)\n    try:\n        # For model-specific augmentation mediators\n        if specialized_type.startswith('augmentation_mediator_'):\n            from isekaizen.mediators.augmentation import specialized\n            return getattr(specialized, f\"create_{specialized_type}\", None)\n        \n        # For model-specific pattern mediators\n        elif specialized_type.startswith('pattern_mediator_'):\n            from isekaizen.mediators.pattern import specialized\n            return getattr(specialized, f\"create_{specialized_type}\", None)\n        \n        # For other specialized mediators\n        else:\n            return None\n    except ImportError:\n        # Module doesn't exist yet\n        return None\n    except AttributeError:\n        # Function doesn't exist yet\n        return None\n\ndef _get_available_specialized_mediators() -> List[str]:\n    \"\"\"\n    Get a list of available specialized mediator types."
    },
    "_get_available_specialized_mediators": {
      "start_line": 260,
      "end_line": 291,
      "parameters": [],
      "return_type": "complex_type",
      "calls": [
        {
          "name": "dir",
          "line": 272
        },
        {
          "name": "dir",
          "line": 282
        },
        {
          "name": "attr_name.startswith",
          "line": 273
        },
        {
          "name": "attr_name.startswith",
          "line": 283
        },
        {
          "name": "specialized_types.append",
          "line": 275
        },
        {
          "name": "specialized_types.append",
          "line": 285
        },
        {
          "name": "len",
          "line": 274
        },
        {
          "name": "len",
          "line": 284
        }
      ],
      "docstring": "\n    Get a list of available specialized mediator types.\n    \n    Returns:\n        List of specialized mediator type names\n    ",
      "code_snippet": "        return None\n\ndef _get_available_specialized_mediators() -> List[str]:\n    \"\"\"\n    Get a list of available specialized mediator types.\n    \n    Returns:\n        List of specialized mediator type names\n    \"\"\"\n    specialized_types = []\n    \n    # Check for specialized augmentation mediators\n    try:\n        from isekaizen.mediators.augmentation import specialized\n        for attr_name in dir(specialized):\n            if attr_name.startswith('create_augmentation_mediator_'):\n                mediator_type = attr_name[len('create_'):]\n                specialized_types.append(mediator_type)\n    except ImportError:\n        pass\n    \n    # Check for specialized pattern mediators\n    try:\n        from isekaizen.mediators.pattern import specialized\n        for attr_name in dir(specialized):\n            if attr_name.startswith('create_pattern_mediator_'):\n                mediator_type = attr_name[len('create_'):]\n                specialized_types.append(mediator_type)\n    except ImportError:\n        pass\n    \n    return specialized_types"
    }
  },
  "constants": {}
}