{
  "path": "D:\\Projects\\isekaiZen\\machine-learning-optimizer\\isekaizen\\core\\mathematical_foundation\\cognitive_efficiency.py",
  "imports": [
    {
      "name": "math",
      "line": 12
    }
  ],
  "classes": {},
  "functions": {
    "calculate_cognitive_efficiency": {
      "start_line": 20,
      "end_line": 70,
      "parameters": [
        {
          "name": "available_energy"
        },
        {
          "name": "cognitive_load"
        },
        {
          "name": "parallel_processors"
        },
        {
          "name": "e_total"
        }
      ],
      "return_type": null,
      "calls": [
        {
          "name": "cognitive_load_function",
          "line": 59
        },
        {
          "name": "parallel_processing_penalty",
          "line": 62
        },
        {
          "name": "max",
          "line": 68
        },
        {
          "name": "ValueError",
          "line": 42
        },
        {
          "name": "ValueError",
          "line": 44
        },
        {
          "name": "min",
          "line": 68
        },
        {
          "name": "math.exp",
          "line": 56
        }
      ],
      "docstring": "\n    Calculate cognitive efficiency based on available energy and cognitive load.\n    \n    Implements the formula from Section 1 of the Mathematical Foundation:\n    \u03b7_cognitive(E_available, L) = 0.95 \u00b7 (1 - e^(-E_available/E_total(n,p))) \u00b7 \u03c6(L) \u00b7 \u03c8(p, L)\n    \n    Args:\n        available_energy (float): Available energy for computation\n        cognitive_load (float): Current cognitive load\n        parallel_processors (int, optional): Number of parallel processors. Defaults to 1.\n        e_total (float, optional): Total energy requirement. If None, calculated based on\n                                  cognitive load and parallel processors.\n        \n    Returns:\n        float: Calculated cognitive efficiency value (0.0-1.0)\n        \n    Raises:\n        ValueError: If available_energy is negative or cognitive_load is not in range [0, L_C*2]\n    ",
      "code_snippet": "ALPHA_PAR = 0.22  # Parallel processing overhead\n\ndef calculate_cognitive_efficiency(available_energy, cognitive_load, parallel_processors=1, e_total=None):\n    \"\"\"\n    Calculate cognitive efficiency based on available energy and cognitive load.\n    \n    Implements the formula from Section 1 of the Mathematical Foundation:\n    \u03b7_cognitive(E_available, L) = 0.95 \u00b7 (1 - e^(-E_available/E_total(n,p))) \u00b7 \u03c6(L) \u00b7 \u03c8(p, L)\n    \n    Args:\n        available_energy (float): Available energy for computation\n        cognitive_load (float): Current cognitive load\n        parallel_processors (int, optional): Number of parallel processors. Defaults to 1.\n        e_total (float, optional): Total energy requirement. If None, calculated based on\n                                  cognitive load and parallel processors.\n        \n    Returns:\n        float: Calculated cognitive efficiency value (0.0-1.0)\n        \n    Raises:\n        ValueError: If available_energy is negative or cognitive_load is not in range [0, L_C*2]\n    \"\"\"\n    # Input validation\n    if available_energy < 0:\n        raise ValueError(\"Available energy must be non-negative\")\n    if cognitive_load < 0 or cognitive_load > L_C * 2:\n        raise ValueError(f\"Cognitive load must be in range [0, {L_C * 2}]\")\n    \n    # Calculate total energy requirement if not provided\n    if e_total is None:\n        # Simple model: E_total scales with cognitive load and number of processors\n        e_total = cognitive_load * (1 + 0.1 * (parallel_processors - 1))\n    \n    # Avoid division by zero\n    if e_total == 0:\n        energy_term = 1.0\n    else:\n        # Calculate energy availability term\n        energy_term = 1.0 - math.exp(-available_energy / e_total)\n    \n    # Calculate cognitive load function\n    cl_factor = cognitive_load_function(cognitive_load)\n    \n    # Calculate parallel processing penalty\n    pp_penalty = parallel_processing_penalty(parallel_processors, cognitive_load)\n    \n    # Calculate overall cognitive efficiency\n    efficiency = 0.95 * energy_term * cl_factor * pp_penalty\n    \n    # Ensure result is in valid range [0, 1]\n    return max(0.0, min(1.0, efficiency))\n\ndef cognitive_load_function(cognitive_load):\n    \"\"\"\n    Calculate the cognitive load function that models the relationship between cognitive load and efficiency."
    },
    "cognitive_load_function": {
      "start_line": 70,
      "end_line": 94,
      "parameters": [
        {
          "name": "cognitive_load"
        }
      ],
      "return_type": null,
      "calls": [
        {
          "name": "math.exp",
          "line": 92
        }
      ],
      "docstring": "\n    Calculate the cognitive load function that models the relationship between cognitive load and efficiency.\n    \n    Implements the formula from Section 1.1 of the Mathematical Foundation:\n    \u03c6(L) = 1 / (1 + e^((L-L_c/2)/\u03c3))\n    \n    Args:\n        cognitive_load (float): Current cognitive load\n        \n    Returns:\n        float: Cognitive load factor (0.0-1.0)\n    ",
      "code_snippet": "    return max(0.0, min(1.0, efficiency))\n\ndef cognitive_load_function(cognitive_load):\n    \"\"\"\n    Calculate the cognitive load function that models the relationship between cognitive load and efficiency.\n    \n    Implements the formula from Section 1.1 of the Mathematical Foundation:\n    \u03c6(L) = 1 / (1 + e^((L-L_c/2)/\u03c3))\n    \n    Args:\n        cognitive_load (float): Current cognitive load\n        \n    Returns:\n        float: Cognitive load factor (0.0-1.0)\n    \"\"\"\n    # Calculate cognitive load function\n    exponent = (cognitive_load - L_C / 2) / SIGMA\n    \n    # Handle extreme values to prevent overflow\n    if exponent > 20:\n        return 0.0\n    if exponent < -20:\n        return 1.0\n    \n    return 1.0 / (1.0 + math.exp(exponent))\n\ndef parallel_processing_penalty(parallel_processors, cognitive_load):\n    \"\"\"\n    Calculate the parallel processing penalty that accounts for overhead when distributing cognitive load."
    },
    "parallel_processing_penalty": {
      "start_line": 94,
      "end_line": 138,
      "parameters": [
        {
          "name": "parallel_processors"
        },
        {
          "name": "cognitive_load"
        }
      ],
      "return_type": null,
      "calls": [
        {
          "name": "max",
          "line": 136
        },
        {
          "name": "ValueError",
          "line": 113
        },
        {
          "name": "math.exp",
          "line": 130
        },
        {
          "name": "math.log",
          "line": 127
        },
        {
          "name": "max",
          "line": 127
        },
        {
          "name": "math.sqrt",
          "line": 131
        }
      ],
      "docstring": "\n    Calculate the parallel processing penalty that accounts for overhead when distributing cognitive load.\n    \n    Implements the formula from Section 1.2 of the Mathematical Foundation:\n    \u03c8(p, L) = (1/p)(1 + \u03b1_w(p-1)log(L))(1 - \u03b1_par\u221ap(1 - e^(-L/L_c)))\n    \n    Args:\n        parallel_processors (int): Number of parallel processors\n        cognitive_load (float): Current cognitive load\n        \n    Returns:\n        float: Parallel processing penalty factor (0.0-1.0)\n        \n    Raises:\n        ValueError: If parallel_processors is less than 1\n    ",
      "code_snippet": "    return 1.0 / (1.0 + math.exp(exponent))\n\ndef parallel_processing_penalty(parallel_processors, cognitive_load):\n    \"\"\"\n    Calculate the parallel processing penalty that accounts for overhead when distributing cognitive load.\n    \n    Implements the formula from Section 1.2 of the Mathematical Foundation:\n    \u03c8(p, L) = (1/p)(1 + \u03b1_w(p-1)log(L))(1 - \u03b1_par\u221ap(1 - e^(-L/L_c)))\n    \n    Args:\n        parallel_processors (int): Number of parallel processors\n        cognitive_load (float): Current cognitive load\n        \n    Returns:\n        float: Parallel processing penalty factor (0.0-1.0)\n        \n    Raises:\n        ValueError: If parallel_processors is less than 1\n    \"\"\"\n    # Input validation\n    if parallel_processors < 1:\n        raise ValueError(\"Number of parallel processors must be at least 1\")\n    \n    # If only one processor, no penalty\n    if parallel_processors == 1:\n        return 1.0\n    \n    # Handle edge case with zero cognitive load\n    if cognitive_load <= 0:\n        return 1.0 / parallel_processors\n    \n    # Calculate first term: Baseline inverse scaling with processor count\n    term1 = 1.0 / parallel_processors\n    \n    # Calculate second term: Weight precision impact with additional processors\n    term2 = 1.0 + ALPHA_W * (parallel_processors - 1) * math.log(max(1.0, cognitive_load))\n    \n    # Calculate third term: Overhead reduction as cognitive load approaches critical threshold\n    load_factor = 1.0 - math.exp(-cognitive_load / L_C)\n    term3 = 1.0 - ALPHA_PAR * math.sqrt(parallel_processors) * load_factor\n    \n    # Combine terms and ensure result is non-negative\n    penalty = term1 * term2 * term3\n    \n    return max(0.0, penalty)"
    }
  },
  "constants": {
    "L_C": {
      "line": 15
    },
    "SIGMA": {
      "line": 16
    },
    "ALPHA_W": {
      "line": 17
    },
    "ALPHA_PAR": {
      "line": 18
    }
  }
}