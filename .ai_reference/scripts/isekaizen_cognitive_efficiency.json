{
  "path": "D:\\Projects\\isekaiZen\\machine-learning-optimizer\\isekaizen\\cognitive\\efficiency.py",
  "imports": [
    {
      "name": "numpy",
      "line": 5
    },
    {
      "name": "logging",
      "line": 6
    },
    {
      "name": "typing.Tuple",
      "line": 7
    },
    {
      "name": "typing.List",
      "line": 7
    },
    {
      "name": "typing.Dict",
      "line": 7
    },
    {
      "name": "typing.Any",
      "line": 7
    },
    {
      "name": "typing.Optional",
      "line": 7
    }
  ],
  "classes": {
    "CognitiveEfficiencyCalculator": {
      "start_line": 11,
      "end_line": 101,
      "methods": {
        "__init__": {
          "start_line": 19,
          "end_line": 30,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "critical_threshold",
              "type": "float"
            },
            {
              "name": "transition_sharpness",
              "type": "float"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "logger.info",
              "line": 28
            }
          ],
          "docstring": "\n        Initialize the calculator.\n        \n        Args:\n            critical_threshold: Critical threshold (kept for backward compatibility but not used)\n            transition_sharpness: Transition sharpness (kept for backward compatibility but not used)\n        ",
          "code_snippet": "    \"\"\"\n    \n    def __init__(self, critical_threshold: float = 8.0, transition_sharpness: float = 0.8):\n        \"\"\"\n        Initialize the calculator.\n        \n        Args:\n            critical_threshold: Critical threshold (kept for backward compatibility but not used)\n            transition_sharpness: Transition sharpness (kept for backward compatibility but not used)\n        \"\"\"\n        # Parameters are kept for backward compatibility but not used\n        logger.info(\"Hardware-based batch boundary calculator initialized\")\n        \n    def calculate_optimal_batch_boundaries(self, max_hardware_batch: int, model_complexity: float) -> Tuple[int, int]:\n        \"\"\"\n        Calculate optimal min and max batch sizes based on hardware constraints and model complexity."
        },
        "calculate_optimal_batch_boundaries": {
          "start_line": 30,
          "end_line": 84,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "max_hardware_batch",
              "type": "int"
            },
            {
              "name": "model_complexity",
              "type": "float"
            }
          ],
          "return_type": "complex_type",
          "calls": [
            {
              "name": "min",
              "line": 74
            },
            {
              "name": "logger.info",
              "line": 81
            },
            {
              "name": "logger.info",
              "line": 45
            },
            {
              "name": "max",
              "line": 74
            },
            {
              "name": "min",
              "line": 65
            },
            {
              "name": "int",
              "line": 79
            },
            {
              "name": "max",
              "line": 65
            },
            {
              "name": "min",
              "line": 68
            },
            {
              "name": "min",
              "line": 71
            },
            {
              "name": "np.log2",
              "line": 79
            },
            {
              "name": "int",
              "line": 65
            },
            {
              "name": "max",
              "line": 68
            },
            {
              "name": "max",
              "line": 71
            },
            {
              "name": "int",
              "line": 68
            },
            {
              "name": "int",
              "line": 71
            }
          ],
          "docstring": "\n        Calculate optimal min and max batch sizes based on hardware constraints and model complexity.\n        \n        Args:\n            max_hardware_batch: Maximum batch size allowed by hardware constraints\n            model_complexity: Model complexity in millions of parameters\n            \n        Returns:\n            Tuple of (min_batch, max_batch) representing the batch boundaries\n        ",
          "code_snippet": "        logger.info(\"Hardware-based batch boundary calculator initialized\")\n        \n    def calculate_optimal_batch_boundaries(self, max_hardware_batch: int, model_complexity: float) -> Tuple[int, int]:\n        \"\"\"\n        Calculate optimal min and max batch sizes based on hardware constraints and model complexity.\n        \n        Args:\n            max_hardware_batch: Maximum batch size allowed by hardware constraints\n            model_complexity: Model complexity in millions of parameters\n            \n        Returns:\n            Tuple of (min_batch, max_batch) representing the batch boundaries\n        \"\"\"\n        # If max_hardware_batch is very small, don't restrict it further\n        if max_hardware_batch <= 16:\n            min_batch = 2\n            max_batch = max_hardware_batch\n            logger.info(f\"Hardware-limited batch boundaries: min={min_batch}, max={max_batch}\")\n            return min_batch, max_batch\n        \n        # Set minimum batch size based on model complexity\n        if model_complexity < 1.0:\n            min_batch = 2  # Small models can use smaller batches\n        elif model_complexity < 10.0:\n            min_batch = 4  # Medium models\n        elif model_complexity < 50.0:\n            min_batch = 8  # Larger models\n        else:\n            min_batch = 16  # Very large models\n        \n        # Calculate optimal max batch size based on model complexity and hardware max\n        # For larger models, prefer larger batches for parallelism benefits\n        if model_complexity < 1.0:\n            # Small models can use a wide range of batch sizes\n            max_batch = max_hardware_batch\n        elif model_complexity < 10.0:\n            # Medium-sized models: use up to 90% of hardware max\n            max_batch = min(max_hardware_batch, max(64, int(max_hardware_batch * 0.9)))\n        elif model_complexity < 50.0:\n            # Large models: use up to 80% of hardware max but ensure it's reasonably large\n            max_batch = min(max_hardware_batch, max(128, int(max_hardware_batch * 0.8)))\n        else:\n            # Very large models: use up to 70% of hardware max but ensure it's large enough\n            max_batch = min(max_hardware_batch, max(256, int(max_hardware_batch * 0.7)))\n        \n        # Ensure min_batch is reasonable given the max_batch\n        min_batch = min(min_batch, max(2, max_batch // 8))  # Min shouldn't be more than 1/8 of max\n        \n        # Prefer power-of-2 batch sizes for better GPU performance\n        if max_batch >= 32:\n            # Find the largest power of 2 that is <= max_batch\n            max_batch = 2 ** int(np.log2(max_batch))\n        \n        logger.info(f\"Optimized batch boundaries: min={min_batch}, max={max_batch} (hardware limit: {max_hardware_batch})\")\n        return min_batch, max_batch\n    \n    # For backward compatibility, maintain this function but it now just returns the input range\n    # This should be removed in future versions\n    def calculate_resonance_zone(self, min_batch: int, max_batch: int, model_complexity: float) -> Tuple[int, int]:"
        },
        "calculate_resonance_zone": {
          "start_line": 86,
          "end_line": 101,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "min_batch",
              "type": "int"
            },
            {
              "name": "max_batch",
              "type": "int"
            },
            {
              "name": "model_complexity",
              "type": "float"
            }
          ],
          "return_type": "complex_type",
          "calls": [
            {
              "name": "logger.debug",
              "line": 98
            }
          ],
          "docstring": "\n        Legacy function maintained for backward compatibility only.\n        \n        Args:\n            min_batch: Minimum batch size\n            max_batch: Maximum batch size\n            model_complexity: Model complexity in millions of parameters\n            \n        Returns:\n            Same input tuple to maintain backward compatibility\n        ",
          "code_snippet": "    # For backward compatibility, maintain this function but it now just returns the input range\n    # This should be removed in future versions\n    def calculate_resonance_zone(self, min_batch: int, max_batch: int, model_complexity: float) -> Tuple[int, int]:\n        \"\"\"\n        Legacy function maintained for backward compatibility only.\n        \n        Args:\n            min_batch: Minimum batch size\n            max_batch: Maximum batch size\n            model_complexity: Model complexity in millions of parameters\n            \n        Returns:\n            Same input tuple to maintain backward compatibility\n        \"\"\"\n        logger.debug(\"calculate_resonance_zone is deprecated and will be removed in future versions\")\n        return min_batch, max_batch"
        }
      },
      "class_variables": [],
      "bases": [],
      "docstring": "\n    Simple batch boundaries calculator that uses hardware constraints.\n    \n    This class calculates batch boundaries based solely on hardware constraints,\n    eliminating the previous cognitive efficiency calculations.\n    "
    }
  },
  "functions": {},
  "constants": {}
}