{
  "path": "D:\\Projects\\isekaiZen\\machine-learning-optimizer\\isekaizen\\core\\pattern\\recognition.py",
  "imports": [
    {
      "name": "logging",
      "line": 11
    },
    {
      "name": "typing.Dict",
      "line": 12
    },
    {
      "name": "typing.Any",
      "line": 12
    },
    {
      "name": "typing.List",
      "line": 12
    },
    {
      "name": "typing.Optional",
      "line": 12
    },
    {
      "name": "typing.Union",
      "line": 12
    },
    {
      "name": "typing.Tuple",
      "line": 12
    }
  ],
  "classes": {},
  "functions": {
    "recognize_patterns": {
      "start_line": 16,
      "end_line": 59,
      "parameters": [
        {
          "name": "data_indices"
        },
        {
          "name": "pattern_map"
        }
      ],
      "return_type": "complex_type",
      "calls": [
        {
          "name": "logger.warning",
          "line": 30
        },
        {
          "name": "logger.warning",
          "line": 36
        },
        {
          "name": "str",
          "line": 45
        },
        {
          "name": "isinstance",
          "line": 29
        },
        {
          "name": "isinstance",
          "line": 48
        },
        {
          "name": "isinstance",
          "line": 52
        }
      ],
      "docstring": "\n    Recognize patterns for the given data indices using the pattern map.\n    \n    Args:\n        data_indices: List of data indices to recognize patterns for\n        pattern_map: Pattern map containing pattern information\n        \n    Returns:\n        Dictionary mapping data indices to their pattern types\n    ",
      "code_snippet": "logger = logging.getLogger(__name__)\n\ndef recognize_patterns(data_indices: List[int], pattern_map: Dict[str, Any]) -> Dict[int, str]:\n    \"\"\"\n    Recognize patterns for the given data indices using the pattern map.\n    \n    Args:\n        data_indices: List of data indices to recognize patterns for\n        pattern_map: Pattern map containing pattern information\n        \n    Returns:\n        Dictionary mapping data indices to their pattern types\n    \"\"\"\n    result = {}\n    \n    if not pattern_map or not isinstance(pattern_map, dict):\n        logger.warning(\"Invalid pattern map provided for pattern recognition\")\n        # Return default pattern type for all indices\n        return {idx: 'statistical' for idx in data_indices}\n    \n    # Check if pattern map has required structure\n    if 'pattern_map' not in pattern_map:\n        logger.warning(\"Pattern map missing 'pattern_map' key\")\n        # Return default pattern type for all indices\n        return {idx: 'statistical' for idx in data_indices}\n    \n    # Get the actual pattern mappings\n    pattern_mappings = pattern_map['pattern_map']\n    \n    # Recognize patterns for each index\n    for idx in data_indices:\n        idx_str = str(idx)\n        if idx_str in pattern_mappings:\n            pattern_info = pattern_mappings[idx_str]\n            if isinstance(pattern_info, dict) and 'pattern_type' in pattern_info:\n                result[idx] = pattern_info['pattern_type']\n            else:\n                # Use the pattern info directly if it's a string\n                result[idx] = pattern_info if isinstance(pattern_info, str) else 'statistical'\n        else:\n            # Use default pattern type if not found\n            result[idx] = 'statistical'\n    \n    return result\n\ndef get_pattern_distribution(pattern_map: Dict[str, Any]) -> Dict[str, int]:\n    \"\"\"\n    Get the pattern distribution from the pattern map."
    },
    "get_pattern_distribution": {
      "start_line": 59,
      "end_line": 95,
      "parameters": [
        {
          "name": "pattern_map"
        }
      ],
      "return_type": "complex_type",
      "calls": [
        {
          "name": "logger.warning",
          "line": 70
        },
        {
          "name": "....items",
          "line": 80
        },
        {
          "name": "isinstance",
          "line": 69
        },
        {
          "name": "isinstance",
          "line": 81
        },
        {
          "name": "pattern_counts.get",
          "line": 88
        },
        {
          "name": "isinstance",
          "line": 85
        }
      ],
      "docstring": "\n    Get the pattern distribution from the pattern map.\n    \n    Args:\n        pattern_map: Pattern map containing pattern information\n        \n    Returns:\n        Dictionary mapping pattern types to their counts\n    ",
      "code_snippet": "    return result\n\ndef get_pattern_distribution(pattern_map: Dict[str, Any]) -> Dict[str, int]:\n    \"\"\"\n    Get the pattern distribution from the pattern map.\n    \n    Args:\n        pattern_map: Pattern map containing pattern information\n        \n    Returns:\n        Dictionary mapping pattern types to their counts\n    \"\"\"\n    if not pattern_map or not isinstance(pattern_map, dict):\n        logger.warning(\"Invalid pattern map provided\")\n        return {'structural': 0, 'statistical': 0, 'temporal': 0}\n    \n    # Check if pattern distribution is directly available\n    if 'pattern_distribution' in pattern_map:\n        return pattern_map['pattern_distribution']\n    \n    # Calculate from pattern_map if available\n    if 'pattern_map' in pattern_map:\n        pattern_counts = {}\n        for idx, pattern_info in pattern_map['pattern_map'].items():\n            if isinstance(pattern_info, dict) and 'pattern_type' in pattern_info:\n                pattern_type = pattern_info['pattern_type']\n            else:\n                # Use the pattern info directly if it's a string\n                pattern_type = pattern_info if isinstance(pattern_info, str) else 'statistical'\n            \n            # Count occurrences\n            pattern_counts[pattern_type] = pattern_counts.get(pattern_type, 0) + 1\n        \n        return pattern_counts\n    \n    # Default empty distribution\n    return {'structural': 0, 'statistical': 0, 'temporal': 0}\n\ndef get_pattern_complexities(pattern_map: Dict[str, Any]) -> Dict[str, Dict[str, float]]:\n    \"\"\"\n    Get the pattern complexities from the pattern map."
    },
    "get_pattern_complexities": {
      "start_line": 95,
      "end_line": 123,
      "parameters": [
        {
          "name": "pattern_map"
        }
      ],
      "return_type": "complex_type",
      "calls": [
        {
          "name": "logger.warning",
          "line": 106
        },
        {
          "name": "isinstance",
          "line": 105
        }
      ],
      "docstring": "\n    Get the pattern complexities from the pattern map.\n    \n    Args:\n        pattern_map: Pattern map containing pattern information\n        \n    Returns:\n        Dictionary mapping pattern types to their complexity information\n    ",
      "code_snippet": "    return {'structural': 0, 'statistical': 0, 'temporal': 0}\n\ndef get_pattern_complexities(pattern_map: Dict[str, Any]) -> Dict[str, Dict[str, float]]:\n    \"\"\"\n    Get the pattern complexities from the pattern map.\n    \n    Args:\n        pattern_map: Pattern map containing pattern information\n        \n    Returns:\n        Dictionary mapping pattern types to their complexity information\n    \"\"\"\n    if not pattern_map or not isinstance(pattern_map, dict):\n        logger.warning(\"Invalid pattern map provided\")\n        return {\n            'structural': {'avg_complexity': 0.5, 'min_complexity': 0.3, 'max_complexity': 0.7},\n            'statistical': {'avg_complexity': 0.5, 'min_complexity': 0.3, 'max_complexity': 0.7},\n            'temporal': {'avg_complexity': 0.5, 'min_complexity': 0.3, 'max_complexity': 0.7}\n        }\n    \n    # Check if pattern complexities are directly available\n    if 'pattern_complexities' in pattern_map:\n        return pattern_map['pattern_complexities']\n    \n    # Calculate simple default complexities\n    return {\n        'structural': {'avg_complexity': 0.5, 'min_complexity': 0.3, 'max_complexity': 0.7},\n        'statistical': {'avg_complexity': 0.5, 'min_complexity': 0.3, 'max_complexity': 0.7},\n        'temporal': {'avg_complexity': 0.5, 'min_complexity': 0.3, 'max_complexity': 0.7}\n    }"
    }
  },
  "constants": {}
}