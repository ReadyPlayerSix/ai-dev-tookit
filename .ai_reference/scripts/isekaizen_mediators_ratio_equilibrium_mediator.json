{
  "path": "D:\\Projects\\isekaiZen\\machine-learning-optimizer\\isekaizen\\mediators\\ratio\\equilibrium_mediator.py",
  "imports": [
    {
      "name": "logging",
      "line": 8
    },
    {
      "name": "time",
      "line": 9
    },
    {
      "name": "typing.Dict",
      "line": 10
    },
    {
      "name": "typing.List",
      "line": 10
    },
    {
      "name": "typing.Any",
      "line": 10
    },
    {
      "name": "typing.Optional",
      "line": 10
    },
    {
      "name": "typing.Set",
      "line": 10
    },
    {
      "name": "isekaizen.mediators.base.Mediator",
      "line": 12
    }
  ],
  "classes": {
    "PatternEquilibriumTracker": {
      "start_line": 16,
      "end_line": 341,
      "methods": {
        "__init__": {
          "start_line": 22,
          "end_line": 57,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "pattern_complexities"
            },
            {
              "name": "pattern_distribution"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "....__init__",
              "line": 30
            },
            {
              "name": "super",
              "line": 30
            }
          ],
          "docstring": "\n        Initialize the pattern equilibrium tracker.\n        \n        Args:\n            pattern_complexities: Dictionary mapping pattern types to complexity scores\n            pattern_distribution: Dictionary mapping pattern types to distribution values\n        ",
          "code_snippet": "    \"\"\"\n    \n    def __init__(self, pattern_complexities=None, pattern_distribution=None):\n        \"\"\"\n        Initialize the pattern equilibrium tracker.\n        \n        Args:\n            pattern_complexities: Dictionary mapping pattern types to complexity scores\n            pattern_distribution: Dictionary mapping pattern types to distribution values\n        \"\"\"\n        super().__init__()\n        \n        # Equilibrium bounds by pattern type\n        self.pattern_bounds = {}  # {pattern_type: {'min': min_bound, 'max': max_bound}}\n        \n        # Store pattern information\n        self.pattern_complexities = pattern_complexities or {}\n        self.pattern_distribution = pattern_distribution or {}\n        \n        # Bound violations tracking\n        self.bound_violations = {}  # {epoch: {pattern_type: {'min': bool, 'max': bool}}}\n        \n        # Bound adjustment history\n        self.bound_adjustments = {}  # {epoch: adjustment_ratio}\n        \n        # Current state\n        self.current_epoch = 0\n        \n        # Metrics tracking\n        self.metrics = {\n            \"tracked_epochs\": 0,\n            \"bound_violations\": {\n                \"min\": 0,\n                \"max\": 0\n            },\n            \"memory_usage\": 0\n        }\n    \n    def initialize(self):\n        \"\"\"Initialize the equilibrium tracker with bounds calculation.\"\"\""
        },
        "initialize": {
          "start_line": 58,
          "end_line": 67,
          "parameters": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "self._calculate_initial_bounds",
              "line": 62
            },
            {
              "name": "logger.info",
              "line": 63
            },
            {
              "name": "logger.info",
              "line": 65
            },
            {
              "name": "len",
              "line": 63
            }
          ],
          "docstring": "Initialize the equilibrium tracker with bounds calculation.",
          "code_snippet": "        }\n    \n    def initialize(self):\n        \"\"\"Initialize the equilibrium tracker with bounds calculation.\"\"\"\n        # Calculate initial bounds if we have complexity and distribution data\n        if self.pattern_complexities and self.pattern_distribution:\n            self._calculate_initial_bounds()\n            logger.info(f\"Initialized PatternEquilibriumTracker with bounds for {len(self.pattern_bounds)} pattern types\")\n        else:\n            logger.info(\"Initialized PatternEquilibriumTracker without pattern information\")\n    \n    def _calculate_initial_bounds(self):\n        \"\"\"Calculate initial equilibrium bounds based on complexity and distribution.\"\"\"\n        for pattern_type, complexity in self.pattern_complexities.items():"
        },
        "_calculate_initial_bounds": {
          "start_line": 67,
          "end_line": 102,
          "parameters": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "self.pattern_complexities.items",
              "line": 69
            },
            {
              "name": "self.pattern_distribution.get",
              "line": 71
            },
            {
              "name": "min",
              "line": 89
            },
            {
              "name": "logger.debug",
              "line": 100
            },
            {
              "name": "isinstance",
              "line": 74
            }
          ],
          "docstring": "Calculate initial equilibrium bounds based on complexity and distribution.",
          "code_snippet": "            logger.info(\"Initialized PatternEquilibriumTracker without pattern information\")\n    \n    def _calculate_initial_bounds(self):\n        \"\"\"Calculate initial equilibrium bounds based on complexity and distribution.\"\"\"\n        for pattern_type, complexity in self.pattern_complexities.items():\n            # Get distribution if available\n            distribution = self.pattern_distribution.get(pattern_type, 0.1)\n            \n            # Handle different complexity formats\n            if isinstance(complexity, dict) and 'avg_complexity' in complexity:\n                complexity_value = complexity['avg_complexity']\n            else:\n                complexity_value = complexity\n            \n            # Base bounds calculation\n            # More complex patterns have wider equilibrium range\n            # Patterns with higher distribution have narrower max bound\n            \n            # Min bound - higher for complex patterns\n            min_bound = 0.5 + (complexity_value * 0.2)\n            \n            # Max bound - affected by distribution (higher distribution = tighter upper bound)\n            # We want to avoid overfitting common patterns\n            distribution_factor = 1.0 - (distribution * 0.5)  # Higher distribution = lower factor\n            max_bound = min(0.95, min_bound + (0.3 * distribution_factor))\n            \n            # Store the bounds\n            self.pattern_bounds[pattern_type] = {\n                'min': min_bound,\n                'max': max_bound,\n                'complexity': complexity_value,\n                'distribution': distribution,\n                'max_adjustment_pct': 0.0  # Tracks how much we've adjusted the max bound\n            }\n            \n            logger.debug(f\"Calculated bounds for {pattern_type}: min={min_bound:.2f}, max={max_bound:.2f}\")\n    \n    def update_accuracy(self, pattern_accuracies: Dict[str, float], epoch: Optional[int] = None):\n        \"\"\"\n        Update with pattern accuracies and check for bound violations."
        },
        "update_accuracy": {
          "start_line": 102,
          "end_line": 148,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "pattern_accuracies"
            },
            {
              "name": "epoch"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "pattern_accuracies.items",
              "line": 117
            },
            {
              "name": "len",
              "line": 144
            },
            {
              "name": "logger.debug",
              "line": 146
            },
            {
              "name": "len",
              "line": 146
            }
          ],
          "docstring": "\n        Update with pattern accuracies and check for bound violations.\n        \n        Args:\n            pattern_accuracies: Dictionary mapping pattern types to accuracy values\n            epoch: Epoch number (defaults to current epoch)\n        ",
          "code_snippet": "            logger.debug(f\"Calculated bounds for {pattern_type}: min={min_bound:.2f}, max={max_bound:.2f}\")\n    \n    def update_accuracy(self, pattern_accuracies: Dict[str, float], epoch: Optional[int] = None):\n        \"\"\"\n        Update with pattern accuracies and check for bound violations.\n        \n        Args:\n            pattern_accuracies: Dictionary mapping pattern types to accuracy values\n            epoch: Epoch number (defaults to current epoch)\n        \"\"\"\n        if epoch is None:\n            epoch = self.current_epoch\n        \n        # Initialize bound violations for this epoch\n        self.bound_violations[epoch] = {}\n        \n        # Track violations for each pattern\n        for pattern_type, accuracy in pattern_accuracies.items():\n            # Skip if we don't have bounds for this pattern\n            if pattern_type not in self.pattern_bounds:\n                continue\n            \n            # Get bounds\n            min_bound = self.pattern_bounds[pattern_type]['min']\n            max_bound = self.pattern_bounds[pattern_type]['max']\n            \n            # Check for violations\n            below_min = accuracy < min_bound\n            above_max = accuracy > max_bound\n            \n            # Store violations\n            self.bound_violations[epoch][pattern_type] = {\n                'min': below_min,\n                'max': above_max,\n                'accuracy': accuracy\n            }\n            \n            # Update metrics\n            if below_min:\n                self.metrics[\"bound_violations\"][\"min\"] += 1\n            if above_max:\n                self.metrics[\"bound_violations\"][\"max\"] += 1\n        \n        # Update metrics\n        self.metrics[\"tracked_epochs\"] = len(self.bound_violations)\n        \n        logger.debug(f\"PatternEquilibriumTracker: Updated accuracy for epoch {epoch} with {len(pattern_accuracies)} patterns\")\n    \n    def adjust_bounds(self, train_accuracy: float, test_accuracy: float, epoch: Optional[int] = None):\n        \"\"\"\n        Adjust bounds based on train/test accuracy relationship."
        },
        "adjust_bounds": {
          "start_line": 148,
          "end_line": 197,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "train_accuracy",
              "type": "float"
            },
            {
              "name": "test_accuracy",
              "type": "float"
            },
            {
              "name": "epoch"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "logger.debug",
              "line": 195
            },
            {
              "name": "min",
              "line": 173
            },
            {
              "name": "logger.info",
              "line": 175
            },
            {
              "name": "max",
              "line": 181
            },
            {
              "name": "logger.debug",
              "line": 193
            }
          ],
          "docstring": "\n        Adjust bounds based on train/test accuracy relationship.\n        \n        Args:\n            train_accuracy: Training accuracy value\n            test_accuracy: Testing/validation accuracy value\n            epoch: Epoch number (defaults to current epoch)\n        ",
          "code_snippet": "        logger.debug(f\"PatternEquilibriumTracker: Updated accuracy for epoch {epoch} with {len(pattern_accuracies)} patterns\")\n    \n    def adjust_bounds(self, train_accuracy: float, test_accuracy: float, epoch: Optional[int] = None):\n        \"\"\"\n        Adjust bounds based on train/test accuracy relationship.\n        \n        Args:\n            train_accuracy: Training accuracy value\n            test_accuracy: Testing/validation accuracy value\n            epoch: Epoch number (defaults to current epoch)\n        \"\"\"\n        if epoch is None:\n            epoch = self.current_epoch\n        \n        # Calculate train/test ratio\n        if test_accuracy > 0:\n            train_test_ratio = train_accuracy / test_accuracy\n        else:\n            train_test_ratio = 1.0\n        \n        # Store the adjustment ratio\n        self.bound_adjustments[epoch] = train_test_ratio\n        \n        # Only adjust if we're overfitting (train >> test)\n        if train_test_ratio > 1.05:  # 5% threshold\n            # Calculate adjustment factor - higher ratio = more adjustment\n            adjustment_factor = (train_test_ratio - 1.0) * 0.1  # 10% of the excess\n            adjustment_factor = min(0.05, adjustment_factor)  # Max 5% adjustment\n            \n            logger.info(f\"Adjusting equilibrium bounds by {adjustment_factor:.1%} due to train/test ratio {train_test_ratio:.2f}\")\n            \n            # Adjust max bounds for all patterns\n            for pattern_type in self.pattern_bounds:\n                # Reduce max bound by adjustment factor\n                current_max = self.pattern_bounds[pattern_type]['max']\n                new_max = max(\n                    self.pattern_bounds[pattern_type]['min'] + 0.05,  # At least 5% above min\n                    current_max * (1.0 - adjustment_factor)\n                )\n                \n                # Calculate adjustment percentage\n                adjustment_pct = (current_max - new_max) / current_max * 100.0\n                \n                # Update max bound\n                self.pattern_bounds[pattern_type]['max'] = new_max\n                self.pattern_bounds[pattern_type]['max_adjustment_pct'] = adjustment_pct\n                \n                logger.debug(f\"Adjusted max bound for {pattern_type}: {current_max:.2f} \u2192 {new_max:.2f} ({adjustment_pct:.1f}%)\")\n        \n        logger.debug(f\"PatternEquilibriumTracker: Bound adjustment for epoch {epoch} - ratio: {train_test_ratio:.2f}\")\n    \n    def get_patterns_below_min(self, epoch: Optional[int] = None) -> List[str]:\n        \"\"\"\n        Get list of patterns below minimum bound."
        },
        "get_patterns_below_min": {
          "start_line": 197,
          "end_line": 217,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "epoch"
            }
          ],
          "return_type": "complex_type",
          "calls": [
            {
              "name": "....items",
              "line": 214
            },
            {
              "name": "violations.get",
              "line": 215
            }
          ],
          "docstring": "\n        Get list of patterns below minimum bound.\n        \n        Args:\n            epoch: Epoch number (defaults to current epoch)\n            \n        Returns:\n            List of pattern types below minimum bound\n        ",
          "code_snippet": "        logger.debug(f\"PatternEquilibriumTracker: Bound adjustment for epoch {epoch} - ratio: {train_test_ratio:.2f}\")\n    \n    def get_patterns_below_min(self, epoch: Optional[int] = None) -> List[str]:\n        \"\"\"\n        Get list of patterns below minimum bound.\n        \n        Args:\n            epoch: Epoch number (defaults to current epoch)\n            \n        Returns:\n            List of pattern types below minimum bound\n        \"\"\"\n        if epoch is None:\n            epoch = self.current_epoch\n        \n        if epoch not in self.bound_violations:\n            return []\n        \n        return [\n            pattern_type for pattern_type, violations in self.bound_violations[epoch].items()\n            if violations.get('min', False)\n        ]\n    \n    def get_patterns_above_max(self, epoch: Optional[int] = None) -> List[str]:\n        \"\"\""
        },
        "get_patterns_above_max": {
          "start_line": 218,
          "end_line": 238,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "epoch"
            }
          ],
          "return_type": "complex_type",
          "calls": [
            {
              "name": "....items",
              "line": 235
            },
            {
              "name": "violations.get",
              "line": 236
            }
          ],
          "docstring": "\n        Get list of patterns above maximum bound.\n        \n        Args:\n            epoch: Epoch number (defaults to current epoch)\n            \n        Returns:\n            List of pattern types above maximum bound\n        ",
          "code_snippet": "        ]\n    \n    def get_patterns_above_max(self, epoch: Optional[int] = None) -> List[str]:\n        \"\"\"\n        Get list of patterns above maximum bound.\n        \n        Args:\n            epoch: Epoch number (defaults to current epoch)\n            \n        Returns:\n            List of pattern types above maximum bound\n        \"\"\"\n        if epoch is None:\n            epoch = self.current_epoch\n        \n        if epoch not in self.bound_violations:\n            return []\n        \n        return [\n            pattern_type for pattern_type, violations in self.bound_violations[epoch].items()\n            if violations.get('max', False)\n        ]\n    \n    def get_current_bounds(self) -> Dict[str, Dict[str, float]]:\n        \"\"\""
        },
        "get_current_bounds": {
          "start_line": 239,
          "end_line": 248,
          "parameters": [
            {
              "name": "self"
            }
          ],
          "return_type": "complex_type",
          "calls": [],
          "docstring": "\n        Get current equilibrium bounds for all patterns.\n        \n        Returns:\n            Dictionary mapping pattern types to bound information\n        ",
          "code_snippet": "        ]\n    \n    def get_current_bounds(self) -> Dict[str, Dict[str, float]]:\n        \"\"\"\n        Get current equilibrium bounds for all patterns.\n        \n        Returns:\n            Dictionary mapping pattern types to bound information\n        \"\"\"\n        return self.pattern_bounds\n    \n    def get_bound_status_history(self) -> Dict[int, Dict[str, Dict[str, bool]]]:\n        \"\"\"\n        Get the complete history of bound violations."
        },
        "get_bound_status_history": {
          "start_line": 248,
          "end_line": 257,
          "parameters": [
            {
              "name": "self"
            }
          ],
          "return_type": "complex_type",
          "calls": [],
          "docstring": "\n        Get the complete history of bound violations.\n        \n        Returns:\n            Dictionary mapping epochs to violation information\n        ",
          "code_snippet": "        return self.pattern_bounds\n    \n    def get_bound_status_history(self) -> Dict[int, Dict[str, Dict[str, bool]]]:\n        \"\"\"\n        Get the complete history of bound violations.\n        \n        Returns:\n            Dictionary mapping epochs to violation information\n        \"\"\"\n        return self.bound_violations\n    \n    def get_bound_adjustment_history(self) -> Dict[int, float]:\n        \"\"\"\n        Get the history of bound adjustments."
        },
        "get_bound_adjustment_history": {
          "start_line": 257,
          "end_line": 266,
          "parameters": [
            {
              "name": "self"
            }
          ],
          "return_type": "complex_type",
          "calls": [],
          "docstring": "\n        Get the history of bound adjustments.\n        \n        Returns:\n            Dictionary mapping epochs to adjustment ratios\n        ",
          "code_snippet": "        return self.bound_violations\n    \n    def get_bound_adjustment_history(self) -> Dict[int, float]:\n        \"\"\"\n        Get the history of bound adjustments.\n        \n        Returns:\n            Dictionary mapping epochs to adjustment ratios\n        \"\"\"\n        return self.bound_adjustments\n    \n    def end_epoch(self, epoch: int):\n        \"\"\"\n        Signal the end of an epoch."
        },
        "end_epoch": {
          "start_line": 266,
          "end_line": 281,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "epoch",
              "type": "int"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "self._cleanup_old_epochs",
              "line": 277
            },
            {
              "name": "logger.debug",
              "line": 279
            }
          ],
          "docstring": "\n        Signal the end of an epoch.\n        \n        Args:\n            epoch: The epoch that has ended\n        ",
          "code_snippet": "        return self.bound_adjustments\n    \n    def end_epoch(self, epoch: int):\n        \"\"\"\n        Signal the end of an epoch.\n        \n        Args:\n            epoch: The epoch that has ended\n        \"\"\"\n        # Update current epoch\n        self.current_epoch = epoch + 1\n        \n        # Cleanup old epochs if needed\n        self._cleanup_old_epochs()\n        \n        logger.debug(f\"PatternEquilibriumTracker: End of epoch {epoch}, moving to epoch {self.current_epoch}\")\n    \n    def _cleanup_old_epochs(self):\n        \"\"\"Clean up data from old epochs to save memory.\"\"\"\n        # Keep only the last N epochs"
        },
        "_cleanup_old_epochs": {
          "start_line": 281,
          "end_line": 304,
          "parameters": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "self.bound_violations.keys",
              "line": 288
            },
            {
              "name": "self.bound_adjustments.keys",
              "line": 297
            },
            {
              "name": "epochs_to_remove.append",
              "line": 290
            },
            {
              "name": "epochs_to_remove.append",
              "line": 299
            }
          ],
          "docstring": "Clean up data from old epochs to save memory.",
          "code_snippet": "        logger.debug(f\"PatternEquilibriumTracker: End of epoch {epoch}, moving to epoch {self.current_epoch}\")\n    \n    def _cleanup_old_epochs(self):\n        \"\"\"Clean up data from old epochs to save memory.\"\"\"\n        # Keep only the last N epochs\n        max_epochs_to_keep = 10\n        \n        # Remove old violation data\n        epochs_to_remove = []\n        for epoch in self.bound_violations.keys():\n            if epoch < self.current_epoch - max_epochs_to_keep:\n                epochs_to_remove.append(epoch)\n        \n        for epoch in epochs_to_remove:\n            del self.bound_violations[epoch]\n        \n        # Remove old adjustment data\n        epochs_to_remove = []\n        for epoch in self.bound_adjustments.keys():\n            if epoch < self.current_epoch - max_epochs_to_keep:\n                epochs_to_remove.append(epoch)\n        \n        for epoch in epochs_to_remove:\n            del self.bound_adjustments[epoch]\n    \n    def clear_cache(self):\n        \"\"\"Clear cached data to free memory.\"\"\"\n        # Keep only the current epoch data"
        },
        "clear_cache": {
          "start_line": 304,
          "end_line": 317,
          "parameters": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "list",
              "line": 307
            },
            {
              "name": "list",
              "line": 311
            },
            {
              "name": "logger.info",
              "line": 315
            },
            {
              "name": "self.bound_violations.keys",
              "line": 307
            },
            {
              "name": "self.bound_adjustments.keys",
              "line": 311
            }
          ],
          "docstring": "Clear cached data to free memory.",
          "code_snippet": "            del self.bound_adjustments[epoch]\n    \n    def clear_cache(self):\n        \"\"\"Clear cached data to free memory.\"\"\"\n        # Keep only the current epoch data\n        for epoch in list(self.bound_violations.keys()):\n            if epoch != self.current_epoch:\n                del self.bound_violations[epoch]\n        \n        for epoch in list(self.bound_adjustments.keys()):\n            if epoch != self.current_epoch:\n                del self.bound_adjustments[epoch]\n        \n        logger.info(\"PatternEquilibriumTracker: Cache cleared\")\n    \n    def get_metrics(self) -> Dict[str, Any]:\n        \"\"\"Get current metrics from the mediator.\"\"\"\n        # Update metrics"
        },
        "get_metrics": {
          "start_line": 317,
          "end_line": 341,
          "parameters": [
            {
              "name": "self"
            }
          ],
          "return_type": "complex_type",
          "calls": [
            {
              "name": "len",
              "line": 320
            },
            {
              "name": "dict",
              "line": 323
            },
            {
              "name": "set",
              "line": 326
            },
            {
              "name": "self.bound_violations.values",
              "line": 327
            },
            {
              "name": "len",
              "line": 332
            },
            {
              "name": "epoch_violations.items",
              "line": 328
            },
            {
              "name": "max",
              "line": 337
            },
            {
              "name": "sum",
              "line": 336
            },
            {
              "name": "len",
              "line": 336
            },
            {
              "name": "self.bound_adjustments.values",
              "line": 337
            },
            {
              "name": "violations.get",
              "line": 329
            },
            {
              "name": "violations.get",
              "line": 329
            },
            {
              "name": "all_violated_patterns.add",
              "line": 330
            },
            {
              "name": "self.bound_adjustments.values",
              "line": 336
            }
          ],
          "docstring": "Get current metrics from the mediator.",
          "code_snippet": "        logger.info(\"PatternEquilibriumTracker: Cache cleared\")\n    \n    def get_metrics(self) -> Dict[str, Any]:\n        \"\"\"Get current metrics from the mediator.\"\"\"\n        # Update metrics\n        self.metrics[\"tracked_epochs\"] = len(self.bound_violations)\n        \n        # Add derived metrics\n        metrics = dict(self.metrics)\n        \n        # Add patterns with violations\n        all_violated_patterns = set()\n        for epoch_violations in self.bound_violations.values():\n            for pattern_type, violations in epoch_violations.items():\n                if violations.get('min', False) or violations.get('max', False):\n                    all_violated_patterns.add(pattern_type)\n        \n        metrics[\"patterns_with_violations\"] = len(all_violated_patterns)\n        \n        # Add bound adjustment statistics\n        if self.bound_adjustments:\n            metrics[\"avg_adjustment_ratio\"] = sum(self.bound_adjustments.values()) / len(self.bound_adjustments)\n            metrics[\"max_adjustment_ratio\"] = max(self.bound_adjustments.values())\n        \n        return metrics"
        }
      },
      "class_variables": [],
      "bases": [
        "Mediator"
      ],
      "docstring": "\n    Mediator component that tracks equilibrium bounds for different\n    pattern types and monitors when they go out of bounds.\n    "
    }
  },
  "functions": {},
  "constants": {}
}