{
  "path": "D:\\Projects\\isekaiZen\\machine-learning-optimizer\\isekaizen\\semantic\\matrix_ops.py",
  "imports": [
    {
      "name": "math",
      "line": 8
    },
    {
      "name": "heapq",
      "line": 9
    },
    {
      "name": "typing.List",
      "line": 10
    },
    {
      "name": "typing.Tuple",
      "line": 10
    },
    {
      "name": "typing.Dict",
      "line": 10
    },
    {
      "name": "typing.Any",
      "line": 10
    },
    {
      "name": "typing.Callable",
      "line": 10
    }
  ],
  "classes": {},
  "functions": {
    "calculate_euclidean_distance": {
      "start_line": 12,
      "end_line": 47,
      "parameters": [
        {
          "name": "a"
        },
        {
          "name": "b"
        }
      ],
      "return_type": "float",
      "calls": [
        {
          "name": "len",
          "line": 28
        },
        {
          "name": "math.sqrt",
          "line": 45
        },
        {
          "name": "len",
          "line": 24
        },
        {
          "name": "len",
          "line": 24
        },
        {
          "name": "ValueError",
          "line": 25
        }
      ],
      "docstring": "\n    Calculate Euclidean distance between two vectors\n    Optimized implementation using direct array indexing\n    \n    Args:\n        a: First vector\n        b: Second vector\n        \n    Returns:\n        Euclidean distance\n    ",
      "code_snippet": "from typing import List, Tuple, Dict, Any, Callable\n\ndef calculate_euclidean_distance(a: List[float], b: List[float]) -> float:\n    \"\"\"\n    Calculate Euclidean distance between two vectors\n    Optimized implementation using direct array indexing\n    \n    Args:\n        a: First vector\n        b: Second vector\n        \n    Returns:\n        Euclidean distance\n    \"\"\"\n    if len(a) != len(b):\n        raise ValueError(\"Vectors must have the same length\")\n        \n    # Unrolled loop for better performance on small vectors\n    n = len(a)\n    sum_squared_diff = 0.0\n    i = 0\n    \n    # Process 4 elements at a time if possible\n    while i + 3 < n:\n        sum_squared_diff += (a[i] - b[i])**2\n        sum_squared_diff += (a[i+1] - b[i+1])**2\n        sum_squared_diff += (a[i+2] - b[i+2])**2\n        sum_squared_diff += (a[i+3] - b[i+3])**2\n        i += 4\n    \n    # Process remaining elements\n    while i < n:\n        sum_squared_diff += (a[i] - b[i])**2\n        i += 1\n            \n    return math.sqrt(sum_squared_diff)\n\ndef find_k_nearest_neighbors(features: List[List[float]], index: int, k: int) -> List[int]:\n    \"\"\"\n    Find k nearest neighbors to a point using a heap-based approach"
    },
    "find_k_nearest_neighbors": {
      "start_line": 47,
      "end_line": 89,
      "parameters": [
        {
          "name": "features"
        },
        {
          "name": "index",
          "type": "int"
        },
        {
          "name": "k",
          "type": "int"
        }
      ],
      "return_type": "complex_type",
      "calls": [
        {
          "name": "len",
          "line": 60
        },
        {
          "name": "range",
          "line": 67
        },
        {
          "name": "range",
          "line": 78
        },
        {
          "name": "calculate_euclidean_distance",
          "line": 69
        },
        {
          "name": "calculate_euclidean_distance",
          "line": 80
        },
        {
          "name": "sorted",
          "line": 87
        },
        {
          "name": "heapq.heappush",
          "line": 72
        },
        {
          "name": "heapq.heappushpop",
          "line": 84
        }
      ],
      "docstring": "\n    Find k nearest neighbors to a point using a heap-based approach\n    \n    Args:\n        features: List of feature vectors\n        index: Index of the target point\n        k: Number of neighbors to find\n        \n    Returns:\n        Indices of k nearest neighbors\n    ",
      "code_snippet": "    return math.sqrt(sum_squared_diff)\n\ndef find_k_nearest_neighbors(features: List[List[float]], index: int, k: int) -> List[int]:\n    \"\"\"\n    Find k nearest neighbors to a point using a heap-based approach\n    \n    Args:\n        features: List of feature vectors\n        index: Index of the target point\n        k: Number of neighbors to find\n        \n    Returns:\n        Indices of k nearest neighbors\n    \"\"\"\n    target = features[index]\n    n = len(features)\n    \n    # Use a max heap to keep track of k smallest distances\n    nearest = []\n    \n    # First phase: quickly fill the heap with first k+1 points (excluding self)\n    count = 0\n    for i in range(n):\n        if i != index:  # Skip self\n            dist = calculate_euclidean_distance(target, features[i])\n            # Use negative distance for max heap behavior\n            if count < k:\n                heapq.heappush(nearest, (-dist, i))\n                count += 1\n            else:\n                break\n    \n    # Second phase: process remaining points, replacing if closer\n    for i in range(k+1, n):\n        if i != index:  # Skip self\n            dist = calculate_euclidean_distance(target, features[i])\n            # Only compute and consider if potentially closer than current max\n            if dist < -nearest[0][0]:\n                # Remove the largest and add the new one\n                heapq.heappushpop(nearest, (-dist, i))\n    \n    # Extract the indices (second element of each tuple)\n    return [idx for _, idx in sorted(nearest, key=lambda x: -x[0])]\n\ndef calculate_pairwise_distances(features: List[List[float]]) -> List[List[float]]:\n    \"\"\"\n    Calculate pairwise distances between all points"
    },
    "calculate_pairwise_distances": {
      "start_line": 89,
      "end_line": 112,
      "parameters": [
        {
          "name": "features"
        }
      ],
      "return_type": "complex_type",
      "calls": [
        {
          "name": "len",
          "line": 99
        },
        {
          "name": "range",
          "line": 103
        },
        {
          "name": "range",
          "line": 104
        },
        {
          "name": "range",
          "line": 100
        },
        {
          "name": "calculate_euclidean_distance",
          "line": 105
        },
        {
          "name": "range",
          "line": 100
        }
      ],
      "docstring": "\n    Calculate pairwise distances between all points\n    \n    Args:\n        features: List of feature vectors\n        \n    Returns:\n        Matrix of pairwise distances\n    ",
      "code_snippet": "    return [idx for _, idx in sorted(nearest, key=lambda x: -x[0])]\n\ndef calculate_pairwise_distances(features: List[List[float]]) -> List[List[float]]:\n    \"\"\"\n    Calculate pairwise distances between all points\n    \n    Args:\n        features: List of feature vectors\n        \n    Returns:\n        Matrix of pairwise distances\n    \"\"\"\n    n = len(features)\n    distances = [[0.0 for _ in range(n)] for _ in range(n)]\n    \n    # Only calculate upper triangular part of the distance matrix\n    for i in range(n):\n        for j in range(i+1, n):\n            dist = calculate_euclidean_distance(features[i], features[j])\n            # Store result in both positions (symmetric matrix)\n            distances[i][j] = dist\n            distances[j][i] = dist\n    \n    return distances\n\ndef find_neighbors_from_distance_matrix(distances: List[List[float]], index: int, k: int) -> List[int]:\n    \"\"\"\n    Find k nearest neighbors to a point using a precomputed distance matrix"
    },
    "find_neighbors_from_distance_matrix": {
      "start_line": 112,
      "end_line": 131,
      "parameters": [
        {
          "name": "distances"
        },
        {
          "name": "index",
          "type": "int"
        },
        {
          "name": "k",
          "type": "int"
        }
      ],
      "return_type": "complex_type",
      "calls": [
        {
          "name": "dists.sort",
          "line": 128
        },
        {
          "name": "range",
          "line": 125
        },
        {
          "name": "len",
          "line": 125
        }
      ],
      "docstring": "\n    Find k nearest neighbors to a point using a precomputed distance matrix\n    \n    Args:\n        distances: Pairwise distance matrix\n        index: Index of the target point\n        k: Number of neighbors to find\n        \n    Returns:\n        Indices of k nearest neighbors\n    ",
      "code_snippet": "    return distances\n\ndef find_neighbors_from_distance_matrix(distances: List[List[float]], index: int, k: int) -> List[int]:\n    \"\"\"\n    Find k nearest neighbors to a point using a precomputed distance matrix\n    \n    Args:\n        distances: Pairwise distance matrix\n        index: Index of the target point\n        k: Number of neighbors to find\n        \n    Returns:\n        Indices of k nearest neighbors\n    \"\"\"\n    # Get distances from the target point to all other points\n    dists = [(distances[index][i], i) for i in range(len(distances)) if i != index]\n    \n    # Sort by distance and take k nearest\n    dists.sort()\n    return [idx for _, idx in dists[:k]]\n\ndef batch_find_neighbors(features: List[List[float]], k: int) -> Dict[int, List[int]]:\n    \"\"\"\n    Find k nearest neighbors for all points in a single batch operation"
    },
    "batch_find_neighbors": {
      "start_line": 131,
      "end_line": 152,
      "parameters": [
        {
          "name": "features"
        },
        {
          "name": "k",
          "type": "int"
        }
      ],
      "return_type": "complex_type",
      "calls": [
        {
          "name": "calculate_pairwise_distances",
          "line": 143
        },
        {
          "name": "range",
          "line": 147
        },
        {
          "name": "len",
          "line": 147
        },
        {
          "name": "find_neighbors_from_distance_matrix",
          "line": 148
        }
      ],
      "docstring": "\n    Find k nearest neighbors for all points in a single batch operation\n    \n    Args:\n        features: List of feature vectors\n        k: Number of neighbors to find\n        \n    Returns:\n        Dictionary mapping each point index to its neighbors' indices\n    ",
      "code_snippet": "    return [idx for _, idx in dists[:k]]\n\ndef batch_find_neighbors(features: List[List[float]], k: int) -> Dict[int, List[int]]:\n    \"\"\"\n    Find k nearest neighbors for all points in a single batch operation\n    \n    Args:\n        features: List of feature vectors\n        k: Number of neighbors to find\n        \n    Returns:\n        Dictionary mapping each point index to its neighbors' indices\n    \"\"\"\n    # Calculate all pairwise distances once\n    distances = calculate_pairwise_distances(features)\n    \n    # Find neighbors for each point\n    neighbors = {}\n    for i in range(len(features)):\n        neighbors[i] = find_neighbors_from_distance_matrix(distances, i, k)\n    \n    return neighbors\n\ndef softmax(values: List[float]) -> List[float]:\n    \"\"\"\n    Apply softmax function to a list of values"
    },
    "softmax": {
      "start_line": 152,
      "end_line": 172,
      "parameters": [
        {
          "name": "values"
        }
      ],
      "return_type": "complex_type",
      "calls": [
        {
          "name": "max",
          "line": 163
        },
        {
          "name": "sum",
          "line": 169
        },
        {
          "name": "math.exp",
          "line": 166
        }
      ],
      "docstring": "\n    Apply softmax function to a list of values\n    \n    Args:\n        values: List of values\n        \n    Returns:\n        Softmax probabilities\n    ",
      "code_snippet": "    return neighbors\n\ndef softmax(values: List[float]) -> List[float]:\n    \"\"\"\n    Apply softmax function to a list of values\n    \n    Args:\n        values: List of values\n        \n    Returns:\n        Softmax probabilities\n    \"\"\"\n    # Find max for numerical stability\n    max_val = max(values)\n    \n    # Calculate exp values with the max subtracted\n    exp_values = [math.exp(val - max_val) for val in values]\n    \n    # Normalize to get probabilities\n    sum_exp = sum(exp_values)\n    return [val / sum_exp for val in exp_values]\n\ndef argmax(values: List[float]) -> int:\n    \"\"\"\n    Find the index of the maximum value in a list"
    },
    "argmax": {
      "start_line": 172,
      "end_line": 192,
      "parameters": [
        {
          "name": "values"
        }
      ],
      "return_type": "int",
      "calls": [
        {
          "name": "range",
          "line": 185
        },
        {
          "name": "len",
          "line": 185
        }
      ],
      "docstring": "\n    Find the index of the maximum value in a list\n    \n    Args:\n        values: List of values\n        \n    Returns:\n        Index of the maximum value\n    ",
      "code_snippet": "    return [val / sum_exp for val in exp_values]\n\ndef argmax(values: List[float]) -> int:\n    \"\"\"\n    Find the index of the maximum value in a list\n    \n    Args:\n        values: List of values\n        \n    Returns:\n        Index of the maximum value\n    \"\"\"\n    max_val = values[0]\n    max_idx = 0\n    \n    for i in range(1, len(values)):\n        if values[i] > max_val:\n            max_val = values[i]\n            max_idx = i\n    \n    return max_idx\n\ndef bincount(values: List[int], minlength: int = 0) -> List[int]:\n    \"\"\"\n    Count occurrences of each integer in a list"
    },
    "bincount": {
      "start_line": 192,
      "end_line": 219,
      "parameters": [
        {
          "name": "values"
        },
        {
          "name": "minlength",
          "type": "int"
        }
      ],
      "return_type": "complex_type",
      "calls": [
        {
          "name": "max",
          "line": 210
        },
        {
          "name": "max",
          "line": 207
        }
      ],
      "docstring": "\n    Count occurrences of each integer in a list\n    \n    Args:\n        values: List of integers\n        minlength: Minimum length of output array\n        \n    Returns:\n        Counts of each integer\n    ",
      "code_snippet": "    return max_idx\n\ndef bincount(values: List[int], minlength: int = 0) -> List[int]:\n    \"\"\"\n    Count occurrences of each integer in a list\n    \n    Args:\n        values: List of integers\n        minlength: Minimum length of output array\n        \n    Returns:\n        Counts of each integer\n    \"\"\"\n    # Determine the range of the output array\n    if not values:\n        max_val = -1\n    else:\n        max_val = max(values)\n    \n    # Create the output array\n    count_length = max(max_val + 1, minlength)\n    counts = [0] * count_length\n    \n    # Count occurrences\n    for val in values:\n        counts[val] += 1\n    \n    return counts\n\ndef mean(values: List[float]) -> float:\n    \"\"\"\n    Calculate the mean of a list of values"
    },
    "mean": {
      "start_line": 219,
      "end_line": 231,
      "parameters": [
        {
          "name": "values"
        }
      ],
      "return_type": "float",
      "calls": [
        {
          "name": "sum",
          "line": 229
        },
        {
          "name": "len",
          "line": 229
        }
      ],
      "docstring": "\n    Calculate the mean of a list of values\n    \n    Args:\n        values: List of values\n        \n    Returns:\n        Mean value\n    ",
      "code_snippet": "    return counts\n\ndef mean(values: List[float]) -> float:\n    \"\"\"\n    Calculate the mean of a list of values\n    \n    Args:\n        values: List of values\n        \n    Returns:\n        Mean value\n    \"\"\"\n    return sum(values) / len(values) if values else 0.0\n\ndef std_dev(values: List[float], ddof: int = 0) -> float:\n    \"\"\"\n    Calculate the standard deviation of a list of values"
    },
    "std_dev": {
      "start_line": 231,
      "end_line": 251,
      "parameters": [
        {
          "name": "values"
        },
        {
          "name": "ddof",
          "type": "int"
        }
      ],
      "return_type": "float",
      "calls": [
        {
          "name": "len",
          "line": 242
        },
        {
          "name": "mean",
          "line": 246
        },
        {
          "name": "math.sqrt",
          "line": 249
        },
        {
          "name": "sum",
          "line": 248
        }
      ],
      "docstring": "\n    Calculate the standard deviation of a list of values\n    \n    Args:\n        values: List of values\n        ddof: Delta degrees of freedom\n        \n    Returns:\n        Standard deviation\n    ",
      "code_snippet": "    return sum(values) / len(values) if values else 0.0\n\ndef std_dev(values: List[float], ddof: int = 0) -> float:\n    \"\"\"\n    Calculate the standard deviation of a list of values\n    \n    Args:\n        values: List of values\n        ddof: Delta degrees of freedom\n        \n    Returns:\n        Standard deviation\n    \"\"\"\n    n = len(values)\n    if n <= ddof:\n        return 0.0\n    \n    avg = mean(values)\n    squared_diffs = [(x - avg)**2 for x in values]\n    variance = sum(squared_diffs) / (n - ddof)\n    return math.sqrt(variance)\n\n# Test the module if run directly\nif __name__ == \"__main__\":\n    # Create test vectors"
    }
  },
  "constants": {}
}