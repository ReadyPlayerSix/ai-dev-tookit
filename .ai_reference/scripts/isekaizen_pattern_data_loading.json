{
  "path": "D:\\Projects\\isekaiZen\\machine-learning-optimizer\\isekaizen\\pattern\\data_loading.py",
  "imports": [
    {
      "name": "os",
      "line": 7
    },
    {
      "name": "json",
      "line": 8
    },
    {
      "name": "logging",
      "line": 9
    },
    {
      "name": "typing.Dict",
      "line": 10
    },
    {
      "name": "typing.Any",
      "line": 10
    },
    {
      "name": "typing.Optional",
      "line": 10
    },
    {
      "name": "datetime.datetime",
      "line": 11
    },
    {
      "name": "isekaizen.configs.PATTERN_MAPS_DIR",
      "line": 14
    },
    {
      "name": "traceback",
      "line": 102
    }
  ],
  "classes": {},
  "functions": {
    "load_latest_pattern_map": {
      "start_line": 18,
      "end_line": 107,
      "parameters": [
        {
          "name": "directory"
        }
      ],
      "return_type": "complex_type",
      "calls": [
        {
          "name": "os.path.join",
          "line": 51
        },
        {
          "name": "os.path.isfile",
          "line": 52
        },
        {
          "name": "logger.info",
          "line": 79
        },
        {
          "name": "os.listdir",
          "line": 80
        },
        {
          "name": "os.path.isdir",
          "line": 33
        },
        {
          "name": "logger.warning",
          "line": 34
        },
        {
          "name": "os.path.isdir",
          "line": 36
        },
        {
          "name": "os.path.isfile",
          "line": 59
        },
        {
          "name": "logger.warning",
          "line": 75
        },
        {
          "name": "pattern_files.sort",
          "line": 88
        },
        {
          "name": "logger.info",
          "line": 90
        },
        {
          "name": "logger.info",
          "line": 95
        },
        {
          "name": "logger.warning",
          "line": 98
        },
        {
          "name": "logger.error",
          "line": 101
        },
        {
          "name": "logger.error",
          "line": 103
        },
        {
          "name": "os.path.join",
          "line": 36
        },
        {
          "name": "logger.info",
          "line": 37
        },
        {
          "name": "os.path.join",
          "line": 38
        },
        {
          "name": "os.path.join",
          "line": 41
        },
        {
          "name": "os.path.isdir",
          "line": 42
        },
        {
          "name": "open",
          "line": 54
        },
        {
          "name": "....strip",
          "line": 55
        },
        {
          "name": "logger.info",
          "line": 56
        },
        {
          "name": "logger.info",
          "line": 62
        },
        {
          "name": "logger.warning",
          "line": 65
        },
        {
          "name": "os.path.join",
          "line": 67
        },
        {
          "name": "os.path.isfile",
          "line": 68
        },
        {
          "name": "filename.endswith",
          "line": 81
        },
        {
          "name": "os.path.join",
          "line": 82
        },
        {
          "name": "pattern_files.append",
          "line": 83
        },
        {
          "name": "logger.debug",
          "line": 84
        },
        {
          "name": "open",
          "line": 93
        },
        {
          "name": "json.load",
          "line": 94
        },
        {
          "name": "traceback.format_exc",
          "line": 103
        },
        {
          "name": "os.getcwd",
          "line": 36
        },
        {
          "name": "os.getcwd",
          "line": 38
        },
        {
          "name": "os.getcwd",
          "line": 41
        },
        {
          "name": "os.path.join",
          "line": 42
        },
        {
          "name": "logger.info",
          "line": 43
        },
        {
          "name": "os.path.join",
          "line": 44
        },
        {
          "name": "logger.error",
          "line": 46
        },
        {
          "name": "logger.info",
          "line": 47
        },
        {
          "name": "open",
          "line": 60
        },
        {
          "name": "json.load",
          "line": 61
        },
        {
          "name": "os.path.dirname",
          "line": 67
        },
        {
          "name": "os.path.basename",
          "line": 67
        },
        {
          "name": "logger.info",
          "line": 69
        },
        {
          "name": "logger.info",
          "line": 72
        },
        {
          "name": "f.read",
          "line": 55
        },
        {
          "name": "open",
          "line": 70
        },
        {
          "name": "json.load",
          "line": 71
        },
        {
          "name": "os.path.getmtime",
          "line": 83
        },
        {
          "name": "str",
          "line": 101
        },
        {
          "name": "os.path.join",
          "line": 37
        },
        {
          "name": "os.getcwd",
          "line": 37
        },
        {
          "name": "os.path.join",
          "line": 43
        },
        {
          "name": "os.getcwd",
          "line": 47
        }
      ],
      "docstring": "\n    Load the most recent pattern map.\n    \n    Args:\n        directory: Directory containing pattern maps (defaults to standard pattern maps directory)\n        \n    Returns:\n        Pattern map dictionary or None if not found\n    ",
      "code_snippet": "logger = logging.getLogger(__name__)\n\ndef load_latest_pattern_map(directory: Optional[str] = None) -> Optional[Dict[str, Any]]:\n    \"\"\"\n    Load the most recent pattern map.\n    \n    Args:\n        directory: Directory containing pattern maps (defaults to standard pattern maps directory)\n        \n    Returns:\n        Pattern map dictionary or None if not found\n    \"\"\"\n    # Use standardized pattern maps directory if none provided\n    if directory is None:\n        directory = PATTERN_MAPS_DIR\n    try:\n        # Check if the directory exists\n        if not os.path.isdir(directory):\n            logger.warning(f\"Pattern map directory not found: {directory}\")\n            # Try to check if the directory exists elsewhere\n            if os.path.isdir(os.path.join(os.getcwd(), directory)):\n                logger.info(f\"Found pattern map directory in current working directory: {os.path.join(os.getcwd(), directory)}\")\n                directory = os.path.join(os.getcwd(), directory)\n            else:\n                # Also check parent directory\n                parent_path = os.path.join(os.getcwd(), '..')\n                if os.path.isdir(os.path.join(parent_path, directory)):\n                    logger.info(f\"Found pattern map directory in parent directory: {os.path.join(parent_path, directory)}\")\n                    directory = os.path.join(parent_path, directory)\n                else:\n                    logger.error(f\"Pattern map directory not found in current working directory or parent directory\")\n                    logger.info(f\"Current working directory: {os.getcwd()}\")\n                    return None\n            \n        # Check for the latest path file\n        latest_path_file = os.path.join(directory, \"latest_pattern_map_path.txt\")\n        if os.path.isfile(latest_path_file):\n            # Read the path\n            with open(latest_path_file, 'r') as f:\n                latest_path = f.read().strip()\n                logger.info(f\"Latest pattern map path from file: {latest_path}\")\n                \n            # Load the pattern map\n            if os.path.isfile(latest_path):\n                with open(latest_path, 'r') as f:\n                    pattern_map = json.load(f)\n                logger.info(f\"Loaded pattern map from {latest_path}\")\n                return pattern_map\n            else:\n                logger.warning(f\"Pattern map file not found: {latest_path}\")\n                # Try to see if the path is relative\n                adjusted_path = os.path.join(os.path.dirname(latest_path_file), os.path.basename(latest_path))\n                if os.path.isfile(adjusted_path):\n                    logger.info(f\"Found pattern map at adjusted path: {adjusted_path}\")\n                    with open(adjusted_path, 'r') as f:\n                        pattern_map = json.load(f)\n                    logger.info(f\"Loaded pattern map from {adjusted_path}\")\n                    return pattern_map\n        else:\n            logger.warning(f\"No latest_pattern_map_path.txt file found in {directory}\")\n        \n        # If no latest path found, try to find the most recent map file\n        pattern_files = []\n        logger.info(f\"Searching for pattern map files in {directory}...\")\n        for filename in os.listdir(directory):\n            if filename.endswith(\".json\") and \"pattern\" in filename:\n                filepath = os.path.join(directory, filename)\n                pattern_files.append((filepath, os.path.getmtime(filepath)))\n                logger.debug(f\"Found potential pattern map file: {filepath}\")\n                \n        if pattern_files:\n            # Sort by modification time (most recent first)\n            pattern_files.sort(key=lambda x: x[1], reverse=True)\n            latest_path = pattern_files[0][0]\n            logger.info(f\"Found most recent pattern map file: {latest_path}\")\n            \n            # Load the pattern map\n            with open(latest_path, 'r') as f:\n                pattern_map = json.load(f)\n            logger.info(f\"Loaded pattern map from {latest_path}\")\n            return pattern_map\n        else:\n            logger.warning(f\"No pattern map files found in {directory}\")\n    \n    except Exception as e:\n        logger.error(f\"Error loading pattern map: {str(e)}\")\n        import traceback\n        logger.error(traceback.format_exc())\n    \n    return None\n\ndef save_pattern_map(pattern_map: Dict[str, Any], \n                     directory: Optional[str] = None,\n                     filename: Optional[str] = None) -> Optional[str]:"
    },
    "save_pattern_map": {
      "start_line": 107,
      "end_line": 153,
      "parameters": [
        {
          "name": "pattern_map"
        },
        {
          "name": "directory"
        },
        {
          "name": "filename"
        }
      ],
      "return_type": "complex_type",
      "calls": [
        {
          "name": "os.makedirs",
          "line": 126
        },
        {
          "name": "os.path.join",
          "line": 134
        },
        {
          "name": "os.path.join",
          "line": 141
        },
        {
          "name": "logger.info",
          "line": 145
        },
        {
          "name": "....strftime",
          "line": 130
        },
        {
          "name": "open",
          "line": 137
        },
        {
          "name": "json.dump",
          "line": 138
        },
        {
          "name": "open",
          "line": 142
        },
        {
          "name": "f.write",
          "line": 143
        },
        {
          "name": "logger.error",
          "line": 149
        },
        {
          "name": "datetime.now",
          "line": 130
        },
        {
          "name": "str",
          "line": 149
        }
      ],
      "docstring": "\n    Save a pattern map to file.\n    \n    Args:\n        pattern_map: Pattern map to save\n        directory: Directory to save the map (defaults to standard pattern maps directory)\n        filename: Optional specific filename\n        \n    Returns:\n        Path to saved file or None if failed\n    ",
      "code_snippet": "    return None\n\ndef save_pattern_map(pattern_map: Dict[str, Any], \n                     directory: Optional[str] = None,\n                     filename: Optional[str] = None) -> Optional[str]:\n    \"\"\"\n    Save a pattern map to file.\n    \n    Args:\n        pattern_map: Pattern map to save\n        directory: Directory to save the map (defaults to standard pattern maps directory)\n        filename: Optional specific filename\n        \n    Returns:\n        Path to saved file or None if failed\n    \"\"\"\n    # Use standardized pattern maps directory if none provided\n    if directory is None:\n        directory = PATTERN_MAPS_DIR\n    try:\n        # Create directory if it doesn't exist\n        os.makedirs(directory, exist_ok=True)\n        \n        # Generate filename if not provided\n        if not filename:\n            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            filename = f\"pattern_map_{timestamp}.json\"\n            \n        # Full path\n        filepath = os.path.join(directory, filename)\n        \n        # Save pattern map\n        with open(filepath, 'w') as f:\n            json.dump(pattern_map, f, indent=2)\n        \n        # Update latest path file\n        latest_path_file = os.path.join(directory, \"latest_pattern_map_path.txt\")\n        with open(latest_path_file, 'w') as f:\n            f.write(filepath)\n            \n        logger.info(f\"Saved pattern map to {filepath}\")\n        return filepath\n        \n    except Exception as e:\n        logger.error(f\"Error saving pattern map: {str(e)}\")\n        \n    return None"
    }
  },
  "constants": {}
}