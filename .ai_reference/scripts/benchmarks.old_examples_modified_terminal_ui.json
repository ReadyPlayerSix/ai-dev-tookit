{
  "path": "D:\\Projects\\isekaiZen\\machine-learning-optimizer\\benchmarks.old\\examples\\modified\\terminal_ui.py",
  "imports": [
    {
      "name": "os",
      "line": 12
    },
    {
      "name": "sys",
      "line": 13
    },
    {
      "name": "time",
      "line": 14
    },
    {
      "name": "logging",
      "line": 15
    },
    {
      "name": "json",
      "line": 16
    },
    {
      "name": "torch",
      "line": 17
    },
    {
      "name": "psutil",
      "line": 18
    },
    {
      "name": "platform",
      "line": 19
    },
    {
      "name": "argparse",
      "line": 20
    },
    {
      "name": "shutil",
      "line": 21
    },
    {
      "name": "urwid",
      "line": 22
    },
    {
      "name": "datetime.datetime",
      "line": 23
    },
    {
      "name": "typing.Dict",
      "line": 24
    },
    {
      "name": "typing.List",
      "line": 24
    },
    {
      "name": "typing.Any",
      "line": 24
    },
    {
      "name": "typing.Optional",
      "line": 24
    },
    {
      "name": "typing.Tuple",
      "line": 24
    },
    {
      "name": "typing.Callable",
      "line": 24
    },
    {
      "name": "traceback",
      "line": 1936
    }
  ],
  "classes": {
    "TerminalUI": {
      "start_line": 56,
      "end_line": 1027,
      "methods": {
        "__init__": {
          "start_line": 59,
          "end_line": 70,
          "parameters": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "self._get_hardware_info",
              "line": 66
            },
            {
              "name": "os.path.join",
              "line": 67
            },
            {
              "name": "os.makedirs",
              "line": 68
            }
          ],
          "docstring": "Initialize the terminal UI",
          "code_snippet": "    \"\"\"Terminal User Interface for the IsekaiZen ML Optimization Framework\"\"\"\n    \n    def __init__(self):\n        \"\"\"Initialize the terminal UI\"\"\"\n        # We'll get terminal size each time we draw a screen for better resize support\n        self.model_type = None\n        self.dataset_type = None\n        self.training_start_time = None\n        self.training_end_time = None\n        self.hardware_info = self._get_hardware_info()\n        self.results_dir = os.path.join(\"examples\", \"output\")\n        os.makedirs(self.results_dir, exist_ok=True)\n        \n    def _get_terminal_size(self):\n        \"\"\"Get current terminal size, for responsive layout\"\"\"\n        return shutil.get_terminal_size().columns, shutil.get_terminal_size().lines"
        },
        "_get_terminal_size": {
          "start_line": 70,
          "end_line": 74,
          "parameters": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "shutil.get_terminal_size",
              "line": 72
            },
            {
              "name": "shutil.get_terminal_size",
              "line": 72
            }
          ],
          "docstring": "Get current terminal size, for responsive layout",
          "code_snippet": "        os.makedirs(self.results_dir, exist_ok=True)\n        \n    def _get_terminal_size(self):\n        \"\"\"Get current terminal size, for responsive layout\"\"\"\n        return shutil.get_terminal_size().columns, shutil.get_terminal_size().lines\n        \n    def _get_hardware_info(self) -> Dict[str, Any]:\n        \"\"\"Get system hardware information\"\"\"\n        hw_info = {"
        },
        "_get_hardware_info": {
          "start_line": 74,
          "end_line": 93,
          "parameters": [
            {
              "name": "self"
            }
          ],
          "return_type": "complex_type",
          "calls": [
            {
              "name": "platform.system",
              "line": 77
            },
            {
              "name": "platform.version",
              "line": 78
            },
            {
              "name": "platform.processor",
              "line": 79
            },
            {
              "name": "psutil.cpu_count",
              "line": 80
            },
            {
              "name": "psutil.cpu_count",
              "line": 81
            },
            {
              "name": "torch.cuda.is_available",
              "line": 83
            },
            {
              "name": "torch.cuda.device_count",
              "line": 87
            },
            {
              "name": "psutil.virtual_memory",
              "line": 82
            },
            {
              "name": "torch.cuda.get_device_name",
              "line": 88
            },
            {
              "name": "range",
              "line": 88
            }
          ],
          "docstring": "Get system hardware information",
          "code_snippet": "        return shutil.get_terminal_size().columns, shutil.get_terminal_size().lines\n        \n    def _get_hardware_info(self) -> Dict[str, Any]:\n        \"\"\"Get system hardware information\"\"\"\n        hw_info = {\n            \"platform\": platform.system(),\n            \"platform_version\": platform.version(),\n            \"processor\": platform.processor(),\n            \"cpu_cores\": psutil.cpu_count(logical=False),\n            \"cpu_threads\": psutil.cpu_count(logical=True),\n            \"memory_total\": psutil.virtual_memory().total,\n            \"has_gpu\": torch.cuda.is_available(),\n        }\n        \n        if hw_info[\"has_gpu\"]:\n            hw_info[\"gpu_count\"] = torch.cuda.device_count()\n            hw_info[\"gpu_names\"] = [torch.cuda.get_device_name(i) for i in range(hw_info[\"gpu_count\"])]\n            hw_info[\"cuda_version\"] = torch.version.cuda\n            \n        return hw_info\n    \n    def clear_screen(self):\n        \"\"\"Clear the terminal screen\"\"\"\n        os.system('cls' if os.name == 'nt' else 'clear')"
        },
        "clear_screen": {
          "start_line": 93,
          "end_line": 97,
          "parameters": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "os.system",
              "line": 95
            }
          ],
          "docstring": "Clear the terminal screen",
          "code_snippet": "        return hw_info\n    \n    def clear_screen(self):\n        \"\"\"Clear the terminal screen\"\"\"\n        os.system('cls' if os.name == 'nt' else 'clear')\n    \n    def display_header(self, title: str):\n        \"\"\"Display a header with the given title\"\"\"\n        self.clear_screen()"
        },
        "display_header": {
          "start_line": 97,
          "end_line": 107,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "title",
              "type": "str"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "self.clear_screen",
              "line": 99
            },
            {
              "name": "self._get_terminal_size",
              "line": 100
            },
            {
              "name": "print",
              "line": 101
            },
            {
              "name": "print",
              "line": 102
            },
            {
              "name": "print",
              "line": 103
            },
            {
              "name": "print",
              "line": 104
            },
            {
              "name": "print",
              "line": 105
            },
            {
              "name": "title.center",
              "line": 102
            },
            {
              "name": "....strftime",
              "line": 104
            },
            {
              "name": "datetime.now",
              "line": 104
            }
          ],
          "docstring": "Display a header with the given title",
          "code_snippet": "        os.system('cls' if os.name == 'nt' else 'clear')\n    \n    def display_header(self, title: str):\n        \"\"\"Display a header with the given title\"\"\"\n        self.clear_screen()\n        terminal_width, _ = self._get_terminal_size()\n        print(\"=\" * terminal_width)\n        print(f\"{title.center(terminal_width)}\")\n        print(\"=\" * terminal_width)\n        print(f\"IsekaiZen ML Optimization Framework - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\")\n        print(\"-\" * terminal_width)\n    \n    def display_welcome(self):\n        \"\"\"Display the welcome screen\"\"\"\n        self.display_header(\"Welcome to IsekaiZen ML Optimizer\")"
        },
        "display_welcome": {
          "start_line": 107,
          "end_line": 127,
          "parameters": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "self.display_header",
              "line": 109
            },
            {
              "name": "print",
              "line": 112
            },
            {
              "name": "print",
              "line": 113
            },
            {
              "name": "print",
              "line": 123
            },
            {
              "name": "print",
              "line": 124
            },
            {
              "name": "input",
              "line": 125
            },
            {
              "name": "....join",
              "line": 116
            },
            {
              "name": "print",
              "line": 117
            },
            {
              "name": "print",
              "line": 118
            },
            {
              "name": "print",
              "line": 120
            },
            {
              "name": "print",
              "line": 121
            }
          ],
          "docstring": "Display the welcome screen",
          "code_snippet": "        print(\"-\" * terminal_width)\n    \n    def display_welcome(self):\n        \"\"\"Display the welcome screen\"\"\"\n        self.display_header(\"Welcome to IsekaiZen ML Optimizer\")\n        \n        # Display system information - minimal form\n        print(\"\\nSystem Overview:\")\n        print(f\"  Platform: {self.hardware_info['platform']} {self.hardware_info['platform_version']}\")\n        \n        if self.hardware_info[\"has_gpu\"]:\n            gpu_names = \", \".join(self.hardware_info[\"gpu_names\"])\n            print(f\"  Hardware: {self.hardware_info['processor']} | {self.hardware_info['cpu_cores']} cores | {self.hardware_info['memory_total'] / (1024**3):.1f} GB RAM\")\n            print(f\"  GPU: {gpu_names}\")\n        else:\n            print(f\"  Hardware: {self.hardware_info['processor']} | {self.hardware_info['cpu_cores']} cores | {self.hardware_info['memory_total'] / (1024**3):.1f} GB RAM\")\n            print(\"  GPU: None detected. CPU will be used for training.\")\n        \n        print(\"\\nIsekaiZen\u2122 optimizes machine learning performance based on pattern recognition and hardware capabilities.\")\n        print(\"\\nPress Enter to continue to model selection...\")\n        input()\n    \n    def select_model(self) -> str:\n        \"\"\"Let user select a model\"\"\"\n        # Model information dictionary with brief descriptions"
        },
        "select_model": {
          "start_line": 127,
          "end_line": 298,
          "parameters": [
            {
              "name": "self"
            }
          ],
          "return_type": "str",
          "calls": [
            {
              "name": "self.display_header",
              "line": 181
            },
            {
              "name": "print",
              "line": 184
            },
            {
              "name": "print",
              "line": 251
            },
            {
              "name": "print",
              "line": 254
            },
            {
              "name": "print",
              "line": 259
            },
            {
              "name": "print",
              "line": 260
            },
            {
              "name": "input",
              "line": 262
            },
            {
              "name": "enumerate",
              "line": 188
            },
            {
              "name": "enumerate",
              "line": 226
            },
            {
              "name": "print",
              "line": 242
            },
            {
              "name": "print",
              "line": 245
            },
            {
              "name": "print",
              "line": 246
            },
            {
              "name": "print",
              "line": 247
            },
            {
              "name": "print",
              "line": 256
            },
            {
              "name": "print",
              "line": 258
            },
            {
              "name": "choice.lower",
              "line": 265
            },
            {
              "name": "model_info.get",
              "line": 189
            },
            {
              "name": "info.get",
              "line": 190
            },
            {
              "name": "info.get",
              "line": 191
            },
            {
              "name": "info.get",
              "line": 192
            },
            {
              "name": "info.get",
              "line": 193
            },
            {
              "name": "info.get",
              "line": 194
            },
            {
              "name": "print",
              "line": 208
            },
            {
              "name": "print",
              "line": 216
            },
            {
              "name": "print",
              "line": 223
            },
            {
              "name": "model_info.get",
              "line": 227
            },
            {
              "name": "info.get",
              "line": 228
            },
            {
              "name": "info.get",
              "line": 229
            },
            {
              "name": "print",
              "line": 240
            },
            {
              "name": "choice.lower",
              "line": 270
            },
            {
              "name": "print",
              "line": 221
            },
            {
              "name": "choice.lower",
              "line": 275
            },
            {
              "name": "print",
              "line": 276
            },
            {
              "name": "sys.exit",
              "line": 277
            },
            {
              "name": "usage_info.replace",
              "line": 214
            },
            {
              "name": "int",
              "line": 283
            },
            {
              "name": "len",
              "line": 284
            },
            {
              "name": "print",
              "line": 288
            },
            {
              "name": "choice.lower",
              "line": 291
            },
            {
              "name": "next",
              "line": 293
            },
            {
              "name": "print",
              "line": 296
            },
            {
              "name": "m.lower",
              "line": 291
            },
            {
              "name": "len",
              "line": 288
            },
            {
              "name": "m.lower",
              "line": 293
            },
            {
              "name": "choice.lower",
              "line": 293
            }
          ],
          "docstring": "Let user select a model",
          "code_snippet": "        input()\n    \n    def select_model(self) -> str:\n        \"\"\"Let user select a model\"\"\"\n        # Model information dictionary with brief descriptions\n        model_info = {\n            \"resnet18\": {\n                \"description\": \"Lightweight ResNet model with 18 layers\",\n                \"parameters\": \"11.7M parameters\",\n                \"performance\": \"Good balance of accuracy and speed\",\n                \"ideal_for\": \"Small to medium-sized datasets, quick training\",\n                \"recommended_for\": [\"cifar10\"]\n            },\n            \"resnet34\": {\n                \"description\": \"Medium-depth ResNet model with 34 layers\",\n                \"parameters\": \"21.8M parameters\",\n                \"performance\": \"Better accuracy than ResNet18 with reasonable training time\",\n                \"ideal_for\": \"Medium-sized datasets with complex features\",\n                \"recommended_for\": [\"cifar10\", \"cifar100\"]\n            },\n            \"resnet50\": {\n                \"description\": \"Deep ResNet model with 50 layers and bottleneck blocks\",\n                \"parameters\": \"25.6M parameters\",\n                \"performance\": \"High accuracy with moderate training requirements\",\n                \"ideal_for\": \"Complex vision tasks requiring high accuracy\",\n                \"recommended_for\": [\"cifar100\"]\n            },\n            \"vgg16\": {\n                \"description\": \"Classic VGG architecture with 16 layers\",\n                \"parameters\": \"138M parameters\",\n                \"performance\": \"Good feature extraction, but slower training\",\n                \"ideal_for\": \"Feature extraction and transfer learning\",\n                \"recommended_for\": []\n            },\n            \"mobilenet_v2\": {\n                \"description\": \"Efficient architecture designed for mobile devices\",\n                \"parameters\": \"3.5M parameters\",\n                \"performance\": \"Fast inference with good accuracy/size tradeoff\",\n                \"ideal_for\": \"Resource-constrained environments, edge devices\",\n                \"recommended_for\": [\"cifar10\"]\n            },\n            \"efficientnet_b0\": {\n                \"description\": \"Compound scaling architecture optimized for efficiency\",\n                \"parameters\": \"5.3M parameters\",\n                \"performance\": \"Excellent accuracy/parameter ratio\",\n                \"ideal_for\": \"Balanced performance and efficiency requirements\",\n                \"recommended_for\": [\"cifar10\", \"cifar100\"]\n            }\n        }\n        \n        # Flag for detailed view toggle\n        show_detailed_view = False\n        # Flag for using pre-trained weights\n        self.use_pretrained = False\n        \n        while True:\n            self.display_header(\"Model Selection\")\n            \n            # Display models based on view type\n            print(\"\\nAvailable Models:\")\n            \n            if show_detailed_view:\n                # Detailed view with descriptions\n                for i, model_type in enumerate(MODEL_TYPES[\"vision\"], 1):\n                    info = model_info.get(model_type, {})\n                    description = info.get('description', '')\n                    performance = info.get('performance', '')\n                    ideal_for = info.get('ideal_for', '')\n                    parameters = info.get('parameters', '')\n                    recommended_for = info.get('recommended_for', [])\n                    \n                    # Check if this model is recommended for the selected dataset\n                    is_recommended = self.dataset_type in recommended_for\n                    \n                    # Format with colors (using ANSI escape codes)\n                    if is_recommended:\n                        # Add asterisk for recommended models\n                        model_name = f\"\\033[1;36m{i}. {model_type} \\033[1;33m*\\033[0m\"  # Cyan, bold with asterisk\n                    else:\n                        model_name = f\"\\033[1;36m{i}. {model_type}\\033[0m\"  # Cyan, bold\n                    \n                    # Box around each model\n                    # Model name - parameters on same line\n                    print(f\"  {model_name} - \\033[0;32m{parameters}\\033[0m\")\n                    # Description and best use combined with highlighted keywords\n                    usage_info = description + \". \" + performance + \". \" + \"Best for \" + ideal_for\n                    # Highlight keywords by adding color\n                    for keyword in [\"accuracy\", \"performance\", \"speed\", \"efficiency\", \"small\", \"medium\", \"complex\", \"quick\", \"fast\", \"mobile\", \"resource\", \"feature\"]:\n                        if keyword in usage_info:\n                            usage_info = usage_info.replace(keyword, f\"\\033[1;33m{keyword}\\033[0m\")\n                    \n                    print(f\"  \\033[0;37m{usage_info}\\033[0m\")\n                    \n                    # Add recommendation note if applicable\n                    if is_recommended:\n                        recommendation = f\"Recommended for {self.dataset_type}!\"\n                        print(f\"  \\033[1;33m{recommendation}\\033[0m\")\n                        \n                    print(\"\")\n            else:\n                # Simple list view with models\n                for i, model_type in enumerate(MODEL_TYPES[\"vision\"], 1):\n                    info = model_info.get(model_type, {})\n                    parameters = info.get('parameters', '')\n                    recommended_for = info.get('recommended_for', [])\n                    \n                    # Check if this model is recommended for the selected dataset\n                    is_recommended = self.dataset_type in recommended_for\n                    \n                    if is_recommended:\n                        # Add asterisk for recommended model\n                        model_display = f\"{i}. {model_type} \\033[1;33m*\\033[0m - \\033[0;32m{parameters}\\033[0m\"\n                    else:\n                        model_display = f\"{i}. {model_type} - \\033[0;32m{parameters}\\033[0m\"\n                    \n                    print(f\"  {model_display}\")\n                \n                print(\"\\nModels marked with \\033[1;33m*\\033[0m are recommended for the selected dataset.\")\n                \n                # Box around the input area\n                print(\"\\n\u250c\" + \"\u2500\" * 60 + \"\u2510\")\n                print(\"\u2502 Enter a number or model name (e.g. '1' or 'resnet18'):\" + \" \" * 12 + \"\u2502\")\n                print(\"\u2514\" + \"\u2500\" * 60 + \"\u2518\")\n            \n            # Display pre-trained status\n            pretrained_status = \"Yes\" if self.use_pretrained else \"No\"\n            print(f\"\\nUse pre-trained weights: {pretrained_status}\")\n            \n            # Display options\n            print(\"\\nOptions:\")\n            if show_detailed_view:\n                print(\"  i - Show simple model list\")\n            else:\n                print(\"  i - Show detailed model information\")\n            print(\"  p - Toggle pre-trained weights\")\n            print(\"  q - Quit\")\n            \n            choice = input(\"\\nSelect model (number/name) or option (letter): \")\n            \n            # Toggle information view\n            if choice.lower() == 'i':\n                show_detailed_view = not show_detailed_view\n                continue\n            \n            # Toggle pre-trained weights\n            elif choice.lower() == 'p':\n                self.use_pretrained = not self.use_pretrained\n                continue\n            \n            # Handle the quit option\n            elif choice.lower() == 'q':\n                print(\"Exiting IsekaiZen ML Optimizer. Goodbye!\")\n                sys.exit(0)\n            \n            # Process model choice - now supports both number and name\n            else:\n                # Check if it's a number\n                try:\n                    num_choice = int(choice)\n                    if 1 <= num_choice <= len(MODEL_TYPES[\"vision\"]):\n                        self.model_type = MODEL_TYPES[\"vision\"][num_choice-1]\n                        return self.model_type\n                    else:\n                        print(f\"Please enter a number between 1 and {len(MODEL_TYPES['vision'])}\")\n                except ValueError:\n                    # Not a number, check if it's a valid model name\n                    if choice.lower() in [m.lower() for m in MODEL_TYPES[\"vision\"]]:\n                        # Find the actual model name with correct case\n                        self.model_type = next(m for m in MODEL_TYPES[\"vision\"] if m.lower() == choice.lower())\n                        return self.model_type\n                    else:\n                        print(f\"Invalid model name. Please choose from the available models.\")\n    \n    def select_dataset(self) -> str:\n        \"\"\"Let user select a dataset\"\"\"\n        # Dataset information dictionary"
        },
        "select_dataset": {
          "start_line": 298,
          "end_line": 458,
          "parameters": [
            {
              "name": "self"
            }
          ],
          "return_type": "str",
          "calls": [
            {
              "name": "self.display_header",
              "line": 336
            },
            {
              "name": "print",
              "line": 339
            },
            {
              "name": "print",
              "line": 396
            },
            {
              "name": "print",
              "line": 401
            },
            {
              "name": "print",
              "line": 402
            },
            {
              "name": "input",
              "line": 404
            },
            {
              "name": "enumerate",
              "line": 343
            },
            {
              "name": "enumerate",
              "line": 376
            },
            {
              "name": "print",
              "line": 387
            },
            {
              "name": "print",
              "line": 388
            },
            {
              "name": "print",
              "line": 391
            },
            {
              "name": "print",
              "line": 392
            },
            {
              "name": "print",
              "line": 393
            },
            {
              "name": "print",
              "line": 398
            },
            {
              "name": "print",
              "line": 400
            },
            {
              "name": "choice.lower",
              "line": 407
            },
            {
              "name": "dataset_info.get",
              "line": 344
            },
            {
              "name": "info.get",
              "line": 345
            },
            {
              "name": "info.get",
              "line": 346
            },
            {
              "name": "info.get",
              "line": 347
            },
            {
              "name": "info.get",
              "line": 348
            },
            {
              "name": "info.get",
              "line": 349
            },
            {
              "name": "print",
              "line": 354
            },
            {
              "name": "print",
              "line": 355
            },
            {
              "name": "print",
              "line": 373
            },
            {
              "name": "dataset_info.get",
              "line": 377
            },
            {
              "name": "info.get",
              "line": 378
            },
            {
              "name": "choice.lower",
              "line": 412
            },
            {
              "name": "print",
              "line": 359
            },
            {
              "name": "print",
              "line": 363
            },
            {
              "name": "print",
              "line": 367
            },
            {
              "name": "print",
              "line": 371
            },
            {
              "name": "print",
              "line": 382
            },
            {
              "name": "print",
              "line": 384
            },
            {
              "name": "choice.lower",
              "line": 417
            },
            {
              "name": "print",
              "line": 418
            },
            {
              "name": "sys.exit",
              "line": 419
            },
            {
              "name": "int",
              "line": 425
            },
            {
              "name": "len",
              "line": 426
            },
            {
              "name": "print",
              "line": 436
            },
            {
              "name": "....lower",
              "line": 428
            },
            {
              "name": "print",
              "line": 429
            },
            {
              "name": "print",
              "line": 430
            },
            {
              "name": "input",
              "line": 431
            },
            {
              "name": "choice.lower",
              "line": 439
            },
            {
              "name": "next",
              "line": 447
            },
            {
              "name": "print",
              "line": 450
            },
            {
              "name": "d.lower",
              "line": 439
            },
            {
              "name": "choice.lower",
              "line": 441
            },
            {
              "name": "print",
              "line": 442
            },
            {
              "name": "print",
              "line": 443
            },
            {
              "name": "input",
              "line": 444
            },
            {
              "name": "len",
              "line": 436
            },
            {
              "name": "d.lower",
              "line": 447
            },
            {
              "name": "choice.lower",
              "line": 447
            }
          ],
          "docstring": "Let user select a dataset",
          "code_snippet": "                        print(f\"Invalid model name. Please choose from the available models.\")\n    \n    def select_dataset(self) -> str:\n        \"\"\"Let user select a dataset\"\"\"\n        # Dataset information dictionary\n        dataset_info = {\n            \"cifar10\": {\n                \"description\": \"10-class color image dataset with 60,000 32x32 images\",\n                \"classes\": \"10 classes: airplane, automobile, bird, cat, deer, dog, frog, horse, ship, truck\",\n                \"size\": \"50,000 training images, 10,000 test images\",\n                \"dimensions\": \"32x32 RGB color images\",\n                \"ideal_for\": \"Basic computer vision experiments and benchmarking\",\n                \"data_size\": \"Small\",\n                \"complexity\": \"Low to Medium\"\n            },\n            \"cifar100\": {\n                \"description\": \"100-class color image dataset with 60,000 32x32 images\",\n                \"classes\": \"100 fine-grained classes organized into 20 super-classes\",\n                \"size\": \"50,000 training images, 10,000 test images\",\n                \"dimensions\": \"32x32 RGB color images\",\n                \"ideal_for\": \"More challenging classification tasks with finer-grained categories\",\n                \"data_size\": \"Medium\",\n                \"complexity\": \"Medium to High\"\n            },\n            \"more datasets coming soon\": {\n                \"description\": \"Support for additional datasets is coming in future updates\",\n                \"note\": \"Planned datasets include ImageNet (Large), MNIST (Small), Fashion-MNIST (Small), and custom dataset loading\",\n                \"eta\": \"Check the GitHub repository for updates\",\n                \"data_size\": \"Various\",\n                \"complexity\": \"Various\"\n            }\n        }\n        \n        # Flag for detailed view toggle\n        show_detailed_view = False\n        \n        # Flag to track if we need to go back to model selection\n        go_back = False\n        \n        while True:\n            self.display_header(\"Dataset Selection\")\n            \n            # Display datasets based on view type\n            print(\"\\nAvailable Datasets:\")\n            \n            if show_detailed_view:\n                # Detailed view with descriptions\n                for i, dataset_type in enumerate(DATASET_TYPES[\"vision\"], 1):\n                    info = dataset_info.get(dataset_type, {})\n                    description = info.get('description', '')\n                    ideal_for = info.get('ideal_for', '')\n                    size_info = info.get('size', '')\n                    data_size = info.get('data_size', '')\n                    complexity = info.get('complexity', '')\n                    \n                    # Format with colors (using ANSI escape codes)\n                    dataset_name = f\"\\033[1;35m{i}. {dataset_type}\\033[0m\"  # Magenta, bold\n                    \n                    print(f\"  {dataset_name}\")\n                    print(f\"     \\033[0;37m{description}\\033[0m\")\n                    \n                    # Show data size category and complexity\n                    if data_size and complexity:\n                        print(f\"     Size Category: \\033[0;32m{data_size}\\033[0m | Complexity: \\033[0;33m{complexity}\\033[0m\")\n                    \n                    # Show exact size if available\n                    if size_info:\n                        print(f\"     Images: \\033[0;32m{size_info}\\033[0m\")\n                    \n                    # Show ideal use case\n                    if ideal_for:\n                        print(f\"     \\033[0;33mBest used for: {ideal_for}\\033[0m\")\n                    \n                    # Add note if present\n                    if \"note\" in info:\n                        print(f\"     \\033[0;32mNote: {info['note']}\\033[0m\")\n                    \n                    print()\n            else:\n                # Simple list view \n                for i, dataset_type in enumerate(DATASET_TYPES[\"vision\"], 1):\n                    info = dataset_info.get(dataset_type, {})\n                    data_size = info.get('data_size', '')\n                    \n                    # Display dataset with its category size\n                    if data_size:\n                        print(f\"  {i}. {dataset_type} - \\033[0;32m{data_size}\\033[0m\")\n                    else:\n                        print(f\"  {i}. {dataset_type}\")\n                \n                # Add note about datasets needing preprocessing\n                print(\"\\nNote: New datasets require preprocessing before training.\")\n                print(\"The IsekaiZen framework will handle this automatically.\")\n                \n                # Box around the input area\n                print(\"\\n\u250c\" + \"\u2500\" * 60 + \"\u2510\")\n                print(\"\u2502 Enter a number or dataset name (e.g. '1' or 'cifar10'):\" + \" \" * 10 + \"\u2502\")\n                print(\"\u2514\" + \"\u2500\" * 60 + \"\u2518\")\n            \n            # Display options\n            print(\"\\nOptions:\")\n            if show_detailed_view:\n                print(\"  i - Show simple dataset list\")\n            else:\n                print(\"  i - Show detailed dataset information\")\n            print(\"  b - Go back to model selection\")\n            print(\"  q - Quit\")\n            \n            choice = input(\"\\nSelect dataset (number/name) or option (letter): \")\n            \n            # Toggle information view\n            if choice.lower() == 'i':\n                show_detailed_view = not show_detailed_view\n                continue\n            \n            # Handle the back option\n            elif choice.lower() == 'b':\n                go_back = True\n                break\n            \n            # Handle the quit option\n            elif choice.lower() == 'q':\n                print(\"Exiting IsekaiZen ML Optimizer. Goodbye!\")\n                sys.exit(0)\n            \n            # Process dataset choice - supports both number and name\n            else:\n                # Check if it's a number\n                try:\n                    num_choice = int(choice)\n                    if 1 <= num_choice <= len(DATASET_TYPES[\"vision\"]):\n                        # Check if this is the \"coming soon\" option\n                        if \"coming soon\" in DATASET_TYPES[\"vision\"][num_choice-1].lower():\n                            print(\"\\nThis dataset option is not yet available.\")\n                            print(\"Please select cifar10 or cifar100 for now.\")\n                            input(\"Press Enter to continue...\")\n                            continue\n                        self.dataset_type = DATASET_TYPES[\"vision\"][num_choice-1]\n                        break\n                    else:\n                        print(f\"Please enter a number between 1 and {len(DATASET_TYPES['vision'])}\")\n                except ValueError:\n                    # Not a number, check if it's a valid dataset name\n                    if choice.lower() in [d.lower() for d in DATASET_TYPES[\"vision\"]]:\n                        # Check if this is the \"coming soon\" option\n                        if \"coming soon\" in choice.lower():\n                            print(\"\\nThis dataset option is not yet available.\")\n                            print(\"Please select cifar10 or cifar100 for now.\")\n                            input(\"Press Enter to continue...\")\n                            continue\n                        # Find the actual dataset name with correct case\n                        self.dataset_type = next(d for d in DATASET_TYPES[\"vision\"] if d.lower() == choice.lower())\n                        break\n                    else:\n                        print(f\"Invalid dataset name. Please choose from the available datasets.\")\n        \n        # If going back to model selection, return None\n        if go_back:\n            return None\n            \n        return self.dataset_type\n    \n    def training_settings(self, settings: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Configure training settings before confirmation\"\"\"\n        "
        },
        "training_settings": {
          "start_line": 458,
          "end_line": 716,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "settings"
            }
          ],
          "return_type": "complex_type",
          "calls": [
            {
              "name": "settings.copy",
              "line": 462
            },
            {
              "name": "self.display_header",
              "line": 477
            },
            {
              "name": "print",
              "line": 480
            },
            {
              "name": "current_settings.get",
              "line": 481
            },
            {
              "name": "print",
              "line": 492
            },
            {
              "name": "print",
              "line": 493
            },
            {
              "name": "print",
              "line": 500
            },
            {
              "name": "print",
              "line": 501
            },
            {
              "name": "print",
              "line": 502
            },
            {
              "name": "print",
              "line": 503
            },
            {
              "name": "print",
              "line": 506
            },
            {
              "name": "print",
              "line": 507
            },
            {
              "name": "print",
              "line": 508
            },
            {
              "name": "print",
              "line": 509
            },
            {
              "name": "print",
              "line": 512
            },
            {
              "name": "print",
              "line": 513
            },
            {
              "name": "print",
              "line": 514
            },
            {
              "name": "print",
              "line": 515
            },
            {
              "name": "print",
              "line": 516
            },
            {
              "name": "print",
              "line": 517
            },
            {
              "name": "....lower",
              "line": 519
            },
            {
              "name": "print",
              "line": 485
            },
            {
              "name": "print",
              "line": 486
            },
            {
              "name": "print",
              "line": 489
            },
            {
              "name": "print",
              "line": 490
            },
            {
              "name": "print",
              "line": 497
            },
            {
              "name": "input",
              "line": 519
            },
            {
              "name": "training_mode.capitalize",
              "line": 492
            },
            {
              "name": "current_settings.get",
              "line": 493
            },
            {
              "name": "current_settings.get",
              "line": 501
            },
            {
              "name": "current_settings.get",
              "line": 502
            },
            {
              "name": "current_settings.get",
              "line": 503
            },
            {
              "name": "current_settings.get",
              "line": 507
            },
            {
              "name": "current_settings.get",
              "line": 508
            },
            {
              "name": "current_settings.get",
              "line": 509
            },
            {
              "name": "print",
              "line": 532
            },
            {
              "name": "sys.exit",
              "line": 533
            },
            {
              "name": "current_settings.get",
              "line": 485
            },
            {
              "name": "current_settings.get",
              "line": 490
            },
            {
              "name": "print",
              "line": 551
            },
            {
              "name": "input",
              "line": 552
            },
            {
              "name": "choice.isdigit",
              "line": 556
            },
            {
              "name": "print",
              "line": 707
            },
            {
              "name": "input",
              "line": 708
            },
            {
              "name": "choice.isdigit",
              "line": 558
            },
            {
              "name": "input",
              "line": 558
            },
            {
              "name": "int",
              "line": 561
            },
            {
              "name": "print",
              "line": 565
            },
            {
              "name": "print",
              "line": 566
            },
            {
              "name": "....lower",
              "line": 567
            },
            {
              "name": "print",
              "line": 703
            },
            {
              "name": "input",
              "line": 704
            },
            {
              "name": "current_settings.get",
              "line": 565
            },
            {
              "name": "print",
              "line": 581
            },
            {
              "name": "print",
              "line": 584
            },
            {
              "name": "print",
              "line": 585
            },
            {
              "name": "....lower",
              "line": 586
            },
            {
              "name": "input",
              "line": 567
            },
            {
              "name": "current_settings.get",
              "line": 584
            },
            {
              "name": "print",
              "line": 600
            },
            {
              "name": "print",
              "line": 603
            },
            {
              "name": "print",
              "line": 604
            },
            {
              "name": "print",
              "line": 605
            },
            {
              "name": "float",
              "line": 572
            },
            {
              "name": "input",
              "line": 586
            },
            {
              "name": "print",
              "line": 622
            },
            {
              "name": "enumerate",
              "line": 623
            },
            {
              "name": "input",
              "line": 572
            },
            {
              "name": "print",
              "line": 577
            },
            {
              "name": "print",
              "line": 579
            },
            {
              "name": "int",
              "line": 591
            },
            {
              "name": "int",
              "line": 609
            },
            {
              "name": "print",
              "line": 624
            },
            {
              "name": "print",
              "line": 638
            },
            {
              "name": "input",
              "line": 591
            },
            {
              "name": "print",
              "line": 596
            },
            {
              "name": "print",
              "line": 598
            },
            {
              "name": "input",
              "line": 609
            },
            {
              "name": "print",
              "line": 619
            },
            {
              "name": "int",
              "line": 628
            },
            {
              "name": "print",
              "line": 651
            },
            {
              "name": "enumerate",
              "line": 652
            },
            {
              "name": "print",
              "line": 617
            },
            {
              "name": "input",
              "line": 628
            },
            {
              "name": "len",
              "line": 629
            },
            {
              "name": "print",
              "line": 633
            },
            {
              "name": "print",
              "line": 635
            },
            {
              "name": "int",
              "line": 641
            },
            {
              "name": "print",
              "line": 653
            },
            {
              "name": "print",
              "line": 667
            },
            {
              "name": "enumerate",
              "line": 668
            },
            {
              "name": "input",
              "line": 641
            },
            {
              "name": "print",
              "line": 646
            },
            {
              "name": "print",
              "line": 648
            },
            {
              "name": "int",
              "line": 657
            },
            {
              "name": "print",
              "line": 669
            },
            {
              "name": "current_settings.get",
              "line": 683
            },
            {
              "name": "print",
              "line": 684
            },
            {
              "name": "print",
              "line": 685
            },
            {
              "name": "print",
              "line": 699
            },
            {
              "name": "input",
              "line": 700
            },
            {
              "name": "input",
              "line": 657
            },
            {
              "name": "len",
              "line": 658
            },
            {
              "name": "print",
              "line": 662
            },
            {
              "name": "print",
              "line": 664
            },
            {
              "name": "int",
              "line": 673
            },
            {
              "name": "....lower",
              "line": 688
            },
            {
              "name": "len",
              "line": 633
            },
            {
              "name": "input",
              "line": 673
            },
            {
              "name": "len",
              "line": 674
            },
            {
              "name": "print",
              "line": 678
            },
            {
              "name": "print",
              "line": 680
            },
            {
              "name": "input",
              "line": 688
            },
            {
              "name": "print",
              "line": 696
            },
            {
              "name": "len",
              "line": 662
            },
            {
              "name": "len",
              "line": 678
            }
          ],
          "docstring": "Configure training settings before confirmation",
          "code_snippet": "        return self.dataset_type\n    \n    def training_settings(self, settings: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Configure training settings before confirmation\"\"\"\n        \n        # Make a copy of settings so we can modify it\n        current_settings = settings.copy()\n        \n        # Define available optimizer options\n        optimizer_options = [\"eve_unified\", \"eve_simplified\", \"sgd\", \"adam\"]\n        \n        # Define weight range options\n        weight_range_options = [\"default\", \"wide\", \"narrow\", \"adaptive\"]\n        \n        # Define learning rate sensitivity options\n        lr_sensitivity_options = [\"high\", \"medium\", \"low\"]\n        \n        # Flag for going back to dataset selection\n        go_back = False\n        \n        while True:\n            self.display_header(\"Training Settings\")\n            \n            # Display core settings with colored formatting - making goal and epochs mutually exclusive\n            print(\"\\nTraining Configuration:\")\n            training_mode = current_settings.get('training_mode', 'epochs')\n            \n            if training_mode == 'accuracy':\n                # If in accuracy goal mode, show N/A for epochs\n                print(f\"  \\033[1;36m1. Accuracy Goal:\\033[0m {current_settings.get('accuracy_goal', 90.0)}%\")\n                print(f\"  \\033[1;36m2. Max Epochs:\\033[0m N/A (Will train until accuracy goal is reached)\")\n            else:\n                # If in epochs mode, show N/A for accuracy goal\n                print(f\"  \\033[1;36m1. Accuracy Goal:\\033[0m N/A (Training for fixed number of epochs)\")\n                print(f\"  \\033[1;36m2. Max Epochs:\\033[0m {current_settings.get('epochs', 15)}\")\n                \n            print(f\"  \\033[1;36m3. Training Mode:\\033[0m {training_mode.capitalize()}\")\n            print(f\"  \\033[1;36m4. Optimizer:\\033[0m {current_settings.get('optimizer', 'eve_unified')}\")\n            \n            # Display input size and resolution\n            if \"input_size\" in current_settings:\n                print(f\"  \\033[1;36m5. Input Resolution:\\033[0m {current_settings['input_size']}\u00d7{current_settings['input_size']}\")\n            \n            # Display advanced settings\n            print(\"\\nAdvanced Settings:\")\n            print(f\"  \\033[0;33m6. Weight Range:\\033[0m {current_settings.get('weight_range', 'default')}\")\n            print(f\"  \\033[0;33m7. LR Sensitivity:\\033[0m {current_settings.get('lr_sensitivity', 'high')}\")\n            print(f\"  \\033[0;33m8. Use Augmentation:\\033[0m {current_settings.get('use_augmentation', True)}\")\n            \n            # Display model and dataset info\n            print(\"\\nSelected Configuration:\")\n            print(f\"  Model: {current_settings.get('model_type', self.model_type)}\")\n            print(f\"  Dataset: {current_settings.get('dataset_type', self.dataset_type)}\")\n            print(f\"  Pre-trained Weights: {current_settings.get('use_pretrained', False)}\")\n            \n            # Display options\n            print(\"\\nOptions:\")\n            print(\"  c - Confirm and proceed to training\")\n            print(\"  e - Edit a setting (enter setting number)\")\n            print(\"  r - Reset to default settings\")\n            print(\"  b - Go back to dataset selection\")\n            print(\"  q - Quit\")\n            \n            choice = input(\"\\nEnter option: \").lower()\n            \n            # Confirm settings and proceed\n            if choice == 'c':\n                return current_settings\n            \n            # Go back to dataset selection\n            elif choice == 'b':\n                go_back = True\n                break\n                \n            # Handle the quit option\n            elif choice == 'q':\n                print(\"Exiting IsekaiZen ML Optimizer. Goodbye!\")\n                sys.exit(0)\n            \n            # Reset to defaults\n            elif choice == 'r':\n                current_settings = {\n                    'model_type': self.model_type,\n                    'dataset_type': self.dataset_type,\n                    'epochs': 15,\n                    'optimizer': 'eve_unified',\n                    'use_pretrained': self.use_pretrained,\n                    'input_size': 32,\n                    'num_classes': 10 if self.dataset_type == \"cifar10\" else 100,\n                    'weight_range': 'default',\n                    'lr_sensitivity': 'high',\n                    'use_augmentation': True,\n                    'accuracy_goal': 90.0,\n                    'training_mode': 'epochs'\n                }\n                print(\"Settings reset to defaults.\")\n                input(\"Press Enter to continue...\")\n                continue\n            \n            # Edit a specific setting\n            elif choice == 'e' or choice.isdigit():\n                # Get the setting number to change\n                setting_num = choice if choice.isdigit() else input(\"Enter setting number (1-8): \")\n                \n                try:\n                    setting_num = int(setting_num)\n                    \n                    # Handle each setting\n                    if setting_num == 1:  # Accuracy Goal\n                        print(\"Current training mode:\", current_settings.get('training_mode', 'epochs'))\n                        print(\"Switch to accuracy goal mode? This will disable fixed epochs. (y/n)\")\n                        switch_mode = input().lower()\n                        if switch_mode in ('y', 'yes'):\n                            current_settings['training_mode'] = 'accuracy'\n                            while True:\n                                try:\n                                    accuracy_goal = float(input(\"Enter accuracy goal (0-100%): \"))\n                                    if 0 <= accuracy_goal <= 100:\n                                        current_settings['accuracy_goal'] = accuracy_goal\n                                        break\n                                    else:\n                                        print(\"Please enter a value between 0 and 100\")\n                                except ValueError:\n                                    print(\"Please enter a valid number\")\n                        else:\n                            print(\"Keeping current training mode.\")\n                    \n                    elif setting_num == 2:  # Epochs\n                        print(\"Current training mode:\", current_settings.get('training_mode', 'epochs'))\n                        print(\"Switch to epochs mode? This will disable accuracy goal. (y/n)\")\n                        switch_mode = input().lower()\n                        if switch_mode in ('y', 'yes'):\n                            current_settings['training_mode'] = 'epochs'\n                            while True:\n                                try:\n                                    epochs = int(input(\"Enter maximum epochs (1-100): \"))\n                                    if 1 <= epochs <= 100:\n                                        current_settings['epochs'] = epochs\n                                        break\n                                    else:\n                                        print(\"Please enter a value between 1 and 100\")\n                                except ValueError:\n                                    print(\"Please enter a valid number\")\n                        else:\n                            print(\"Keeping current training mode.\")\n                    \n                    elif setting_num == 3:  # Training Mode\n                        print(\"Select training mode:\")\n                        print(\"  1. Epochs - Train for a fixed number of epochs\")\n                        print(\"  2. Accuracy - Train until reaching a target accuracy\")\n                        \n                        while True:\n                            try:\n                                mode_choice = int(input(\"Select mode (1-2): \"))\n                                if mode_choice == 1:\n                                    current_settings['training_mode'] = 'epochs'\n                                    break\n                                elif mode_choice == 2:\n                                    current_settings['training_mode'] = 'accuracy'\n                                    break\n                                else:\n                                    print(\"Please enter 1 or 2\")\n                            except ValueError:\n                                print(\"Please enter a valid number\")\n                    \n                    elif setting_num == 4:  # Optimizer\n                        print(\"Available optimizers:\")\n                        for i, opt in enumerate(optimizer_options, 1):\n                            print(f\"  {i}. {opt}\")\n                        \n                        while True:\n                            try:\n                                opt_choice = int(input(\"Select optimizer (number): \"))\n                                if 1 <= opt_choice <= len(optimizer_options):\n                                    current_settings['optimizer'] = optimizer_options[opt_choice-1]\n                                    break\n                                else:\n                                    print(f\"Please enter a number between 1 and {len(optimizer_options)}\")\n                            except ValueError:\n                                print(\"Please enter a valid number\")\n                    \n                    elif setting_num == 5:  # Input Size\n                        print(\"Common sizes: 32 (CIFAR default), 224 (ImageNet standard), 160, 96\")\n                        while True:\n                            try:\n                                size = int(input(\"Enter input resolution (32-256): \"))\n                                if 32 <= size <= 256:\n                                    current_settings['input_size'] = size\n                                    break\n                                else:\n                                    print(\"Please enter a value between 32 and 256\")\n                            except ValueError:\n                                print(\"Please enter a valid number\")\n                    \n                    elif setting_num == 6:  # Weight Range\n                        print(\"Available weight range options:\")\n                        for i, opt in enumerate(weight_range_options, 1):\n                            print(f\"  {i}. {opt}\")\n                        \n                        while True:\n                            try:\n                                opt_choice = int(input(\"Select weight range (number): \"))\n                                if 1 <= opt_choice <= len(weight_range_options):\n                                    current_settings['weight_range'] = weight_range_options[opt_choice-1]\n                                    break\n                                else:\n                                    print(f\"Please enter a number between 1 and {len(weight_range_options)}\")\n                            except ValueError:\n                                print(\"Please enter a valid number\")\n                    \n                    elif setting_num == 7:  # LR Sensitivity\n                        print(\"Available LR sensitivity options:\")\n                        for i, opt in enumerate(lr_sensitivity_options, 1):\n                            print(f\"  {i}. {opt}\")\n                        \n                        while True:\n                            try:\n                                opt_choice = int(input(\"Select LR sensitivity (number): \"))\n                                if 1 <= opt_choice <= len(lr_sensitivity_options):\n                                    current_settings['lr_sensitivity'] = lr_sensitivity_options[opt_choice-1]\n                                    break\n                                else:\n                                    print(f\"Please enter a number between 1 and {len(lr_sensitivity_options)}\")\n                            except ValueError:\n                                print(\"Please enter a valid number\")\n                    \n                    elif setting_num == 8:  # Use Augmentation\n                        current_augment = current_settings.get('use_augmentation', True)\n                        print(f\"Current setting: {current_augment}\")\n                        print(\"Note: Data augmentation is strongly recommended for most tasks.\")\n                        \n                        while True:\n                            choice = input(\"Use data augmentation? (y/n): \").lower()\n                            if choice in ['y', 'yes']:\n                                current_settings['use_augmentation'] = True\n                                break\n                            elif choice in ['n', 'no']:\n                                current_settings['use_augmentation'] = False\n                                break\n                            else:\n                                print(\"Please enter 'y' or 'n'\")\n                    \n                    else:\n                        print(f\"Invalid setting number: {setting_num}\")\n                        input(\"Press Enter to continue...\")\n                    \n                except ValueError:\n                    print(\"Please enter a valid setting number\")\n                    input(\"Press Enter to continue...\")\n            \n            else:\n                print(\"Invalid option. Please try again.\")\n                input(\"Press Enter to continue...\")\n        \n        # Return None if going back\n        if go_back:\n            return None\n        \n        return current_settings\n    \n    def confirm_settings(self, settings: Dict[str, Any]) -> bool:\n        \"\"\"Confirm training settings with the user and allow adjustments\"\"\"\n        "
        },
        "confirm_settings": {
          "start_line": 716,
          "end_line": 788,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "settings"
            }
          ],
          "return_type": "bool",
          "calls": [
            {
              "name": "self.training_settings",
              "line": 721
            },
            {
              "name": "settings.update",
              "line": 730
            },
            {
              "name": "self.display_header",
              "line": 733
            },
            {
              "name": "print",
              "line": 735
            },
            {
              "name": "print",
              "line": 736
            },
            {
              "name": "print",
              "line": 737
            },
            {
              "name": "print",
              "line": 738
            },
            {
              "name": "print",
              "line": 739
            },
            {
              "name": "print",
              "line": 740
            },
            {
              "name": "print",
              "line": 741
            },
            {
              "name": "print",
              "line": 743
            },
            {
              "name": "print",
              "line": 752
            },
            {
              "name": "print",
              "line": 753
            },
            {
              "name": "print",
              "line": 755
            },
            {
              "name": "print",
              "line": 756
            },
            {
              "name": "print",
              "line": 757
            },
            {
              "name": "print",
              "line": 760
            },
            {
              "name": "print",
              "line": 761
            },
            {
              "name": "print",
              "line": 762
            },
            {
              "name": "print",
              "line": 763
            },
            {
              "name": "print",
              "line": 765
            },
            {
              "name": "print",
              "line": 766
            },
            {
              "name": "print",
              "line": 768
            },
            {
              "name": "print",
              "line": 769
            },
            {
              "name": "print",
              "line": 770
            },
            {
              "name": "print",
              "line": 771
            },
            {
              "name": "settings.get",
              "line": 744
            },
            {
              "name": "print",
              "line": 745
            },
            {
              "name": "print",
              "line": 746
            },
            {
              "name": "print",
              "line": 747
            },
            {
              "name": "print",
              "line": 749
            },
            {
              "name": "print",
              "line": 750
            },
            {
              "name": "print",
              "line": 751
            },
            {
              "name": "....lower",
              "line": 774
            },
            {
              "name": "input",
              "line": 774
            },
            {
              "name": "print",
              "line": 780
            },
            {
              "name": "sys.exit",
              "line": 781
            },
            {
              "name": "print",
              "line": 783
            }
          ],
          "docstring": "Confirm training settings with the user and allow adjustments",
          "code_snippet": "        return current_settings\n    \n    def confirm_settings(self, settings: Dict[str, Any]) -> bool:\n        \"\"\"Confirm training settings with the user and allow adjustments\"\"\"\n        \n        while True:\n            # Get training settings\n            configured_settings = self.training_settings(settings)\n            \n            # Check if user wants to go back\n            if configured_settings is None:\n                # Return to dataset selection - this will be handled by the calling function\n                # For now, since navigation isn't fully implemented yet, we'll just show the settings again\n                continue\n            \n            # Update settings\n            settings.update(configured_settings)\n            \n            # Show confirmation screen\n            self.display_header(\"Confirm Training Settings\")\n            \n            print(\"\\nThe following settings will be used for training:\")\n            print(\"\\nModel & Dataset:\")\n            print(f\"  Model: {settings['model_type']}\")\n            print(f\"  Dataset: {settings['dataset_type']}\")\n            print(f\"  Pre-trained Weights: {settings['use_pretrained']}\")\n            print(f\"  Input Resolution: {settings['input_size']}\u00d7{settings['input_size']}\")\n            print(f\"  Classes: {settings['num_classes']}\")\n            \n            print(\"\\nTraining Parameters:\")\n            if settings.get('training_mode') == 'accuracy':\n                print(f\"  Training Mode: Accuracy Goal\")\n                print(f\"  Accuracy Goal: {settings['accuracy_goal']}%\")\n                print(f\"  Maximum Epochs: N/A (Will train until accuracy goal is reached)\")\n            else:\n                print(f\"  Training Mode: Fixed Epochs\")\n                print(f\"  Maximum Epochs: {settings['epochs']}\")\n                print(f\"  Accuracy Goal: N/A (Training for fixed number of epochs)\")\n            print(f\"  Optimizer: {settings['optimizer']}\")\n            print(f\"  Data Augmentation: {settings['use_augmentation']}\")\n            \n            print(\"\\nAdvanced Settings:\")\n            print(f\"  Weight Range: {settings['weight_range']}\")\n            print(f\"  LR Sensitivity: {settings['lr_sensitivity']}\")\n            \n            # Add information about settings persistence and random seeds\n            print(\"\\nSettings Persistence:\")\n            print(\"  \u2022 Settings are saved with training results and can be loaded in future sessions\")\n            print(\"  \u2022 Random seeds ensure reproducible results when rerunning the same configuration\")\n            print(\"  \u2022 When you save a model, a random seed value is saved with it for reproducibility\")\n            \n            print(\"\\nIsekaiZen will optimize batch sizes and learning rates dynamically during training.\")\n            print(\"These settings will be used as initial values and constraints.\")\n            \n            print(\"\\nOptions:\")\n            print(\"  y - Yes, start training with these settings\")\n            print(\"  n - No, go back to training settings\")\n            print(\"  q - Quit\")\n            \n            while True:\n                choice = input(\"\\nEnter option: \").lower()\n                if choice in ['y', 'yes']:\n                    return True\n                elif choice in ['n', 'no']:\n                    break\n                elif choice == 'q':\n                    print(\"Exiting IsekaiZen ML Optimizer. Goodbye!\")\n                    sys.exit(0)\n                else:\n                    print(\"Please enter 'y', 'n', or 'q'\")\n            \n            # If user chose 'n', return to settings\n            continue\n    \n    def display_training_progress(self, epoch: int, total_epochs: int, \n                                 metrics: Dict[str, float], \n                                 batch_size: int,"
        },
        "display_training_progress": {
          "start_line": 788,
          "end_line": 832,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "epoch",
              "type": "int"
            },
            {
              "name": "total_epochs",
              "type": "int"
            },
            {
              "name": "metrics"
            },
            {
              "name": "batch_size",
              "type": "int"
            },
            {
              "name": "memory_usage"
            },
            {
              "name": "elapsed_time",
              "type": "float"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "self.clear_screen",
              "line": 794
            },
            {
              "name": "int",
              "line": 798
            },
            {
              "name": "print",
              "line": 802
            },
            {
              "name": "print",
              "line": 803
            },
            {
              "name": "print",
              "line": 804
            },
            {
              "name": "print",
              "line": 807
            },
            {
              "name": "print",
              "line": 808
            },
            {
              "name": "print",
              "line": 811
            },
            {
              "name": "print",
              "line": 812
            },
            {
              "name": "print",
              "line": 813
            },
            {
              "name": "print",
              "line": 820
            },
            {
              "name": "print",
              "line": 821
            },
            {
              "name": "print",
              "line": 826
            },
            {
              "name": "print",
              "line": 827
            },
            {
              "name": "print",
              "line": 830
            },
            {
              "name": "....center",
              "line": 803
            },
            {
              "name": "print",
              "line": 815
            },
            {
              "name": "print",
              "line": 817
            },
            {
              "name": "print",
              "line": 823
            },
            {
              "name": "print",
              "line": 829
            },
            {
              "name": "metrics.get",
              "line": 812
            },
            {
              "name": "metrics.get",
              "line": 813
            },
            {
              "name": "psutil.cpu_percent",
              "line": 827
            },
            {
              "name": "metrics.get",
              "line": 815
            },
            {
              "name": "metrics.get",
              "line": 817
            },
            {
              "name": "metrics.get",
              "line": 823
            },
            {
              "name": "psutil.virtual_memory",
              "line": 830
            },
            {
              "name": "memory_usage.get",
              "line": 829
            },
            {
              "name": "memory_usage.get",
              "line": 829
            }
          ],
          "docstring": "Display real-time training progress",
          "code_snippet": "            continue\n    \n    def display_training_progress(self, epoch: int, total_epochs: int, \n                                 metrics: Dict[str, float], \n                                 batch_size: int,\n                                 memory_usage: Dict[str, float],\n                                 elapsed_time: float):\n        \"\"\"Display real-time training progress\"\"\"\n        self.clear_screen()\n        \n        # Calculate progress bar\n        bar_width = self.terminal_width - 20\n        progress = int(bar_width * epoch / total_epochs)\n        progress_bar = f\"[{'=' * progress}{' ' * (bar_width - progress)}]\"\n        \n        # Header information\n        print(\"=\" * self.terminal_width)\n        print(f\"IsekaiZen Training: {self.model_type} on {self.dataset_type}\".center(self.terminal_width))\n        print(\"=\" * self.terminal_width)\n        \n        # Progress information\n        print(f\"\\nEpoch: {epoch}/{total_epochs} {progress_bar} {epoch/total_epochs*100:.1f}%\")\n        print(f\"Elapsed Time: {elapsed_time:.2f} seconds\")\n        \n        # Display basic metrics\n        print(\"\\nMetrics:\")\n        print(f\"  Train Loss: {metrics.get('train_loss', 0):.4f}\")\n        print(f\"  Train Accuracy: {metrics.get('train_acc', 0):.2f}%\")\n        if 'val_loss' in metrics:\n            print(f\"  Validation Loss: {metrics.get('val_loss', 0):.4f}\")\n        if 'val_acc' in metrics:\n            print(f\"  Validation Accuracy: {metrics.get('val_acc', 0):.2f}%\")\n        \n        # Display adaptive parameters\n        print(\"\\nAdaptive Parameters:\")\n        print(f\"  Current Batch Size: {batch_size}\")\n        if 'learning_rate' in metrics:\n            print(f\"  Learning Rate: {metrics.get('learning_rate', 0):.6f}\")\n        \n        # Display hardware usage\n        print(\"\\nHardware Usage:\")\n        print(f\"  CPU Usage: {psutil.cpu_percent()}%\")\n        if self.hardware_info[\"has_gpu\"]:\n            print(f\"  GPU Memory: {memory_usage.get('allocated', 0)/1e9:.2f} GB / {memory_usage.get('total', 0)/1e9:.2f} GB\")\n        print(f\"  RAM Usage: {psutil.virtual_memory().percent}%\")\n    \n    def display_final_results(self, history: Dict[str, Any], \n                             model_info: Dict[str, Any],\n                             metrics: Dict[str, Any]):"
        },
        "display_final_results": {
          "start_line": 832,
          "end_line": 893,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "history"
            },
            {
              "name": "model_info"
            },
            {
              "name": "metrics"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "self.display_header",
              "line": 836
            },
            {
              "name": "print",
              "line": 844
            },
            {
              "name": "print",
              "line": 845
            },
            {
              "name": "print",
              "line": 846
            },
            {
              "name": "print",
              "line": 853
            },
            {
              "name": "print",
              "line": 862
            },
            {
              "name": "print",
              "line": 865
            },
            {
              "name": "print",
              "line": 868
            },
            {
              "name": "print",
              "line": 869
            },
            {
              "name": "print",
              "line": 870
            },
            {
              "name": "print",
              "line": 871
            },
            {
              "name": "print",
              "line": 872
            },
            {
              "name": "print",
              "line": 841
            },
            {
              "name": "print",
              "line": 848
            },
            {
              "name": "print",
              "line": 850
            },
            {
              "name": "print",
              "line": 855
            },
            {
              "name": "print",
              "line": 856
            },
            {
              "name": "print",
              "line": 859
            },
            {
              "name": "print",
              "line": 864
            },
            {
              "name": "len",
              "line": 854
            },
            {
              "name": "int",
              "line": 876
            },
            {
              "name": "model_info.get",
              "line": 845
            },
            {
              "name": "model_info.get",
              "line": 846
            },
            {
              "name": "metrics.get",
              "line": 865
            },
            {
              "name": "input",
              "line": 876
            },
            {
              "name": "self._save_model",
              "line": 878
            },
            {
              "name": "print",
              "line": 891
            },
            {
              "name": "max",
              "line": 856
            },
            {
              "name": "self._save_history",
              "line": 881
            },
            {
              "name": "self._save_all",
              "line": 884
            },
            {
              "name": "print",
              "line": 889
            }
          ],
          "docstring": "Display comprehensive results after training completion",
          "code_snippet": "        print(f\"  RAM Usage: {psutil.virtual_memory().percent}%\")\n    \n    def display_final_results(self, history: Dict[str, Any], \n                             model_info: Dict[str, Any],\n                             metrics: Dict[str, Any]):\n        \"\"\"Display comprehensive results after training completion\"\"\"\n        self.display_header(\"Training Complete\")\n        \n        # Training summary\n        if self.training_start_time and self.training_end_time:\n            training_time = self.training_end_time - self.training_start_time\n            print(f\"\\nTotal Training Time: {training_time:.2f} seconds\")\n        \n        # Model information\n        print(\"\\nModel Information:\")\n        print(f\"  Architecture: {model_info.get('model_type', self.model_type)}\")\n        print(f\"  Dataset: {model_info.get('dataset_type', self.dataset_type)}\")\n        if 'model_size' in model_info:\n            print(f\"  Model Size: {model_info['model_size']/1e6:.2f} MB\")\n        if 'parameter_count' in model_info:\n            print(f\"  Parameters: {model_info['parameter_count']:,}\")\n        \n        # Final metrics\n        print(\"\\nFinal Performance:\")\n        if history and 'val_acc' in history and len(history['val_acc']) > 0:\n            print(f\"  Final Validation Accuracy: {history['val_acc'][-1]:.2f}%\")\n            print(f\"  Best Validation Accuracy: {max(history['val_acc']):.2f}%\")\n        \n        if 'inference_time' in metrics:\n            print(f\"  Inference Time: {metrics['inference_time']*1000:.2f} ms/sample\")\n        \n        # Hardware utilization\n        print(\"\\nPeak Resource Usage:\")\n        if 'peak_gpu_memory' in metrics:\n            print(f\"  Peak GPU Memory: {metrics['peak_gpu_memory']/1e9:.2f} GB\")\n        print(f\"  Peak CPU Utilization: {metrics.get('peak_cpu_util', 0):.1f}%\")\n        \n        # Save results options\n        print(\"\\nSave Results:\")\n        print(\"  1. Save model\")\n        print(\"  2. Save training history\")\n        print(\"  3. Save all (model, history, and metrics)\")\n        print(\"  4. Exit without saving\")\n        \n        while True:\n            try:\n                choice = int(input(\"\\nSelect option (1-4): \"))\n                if choice == 1:\n                    self._save_model(model_info)\n                    break\n                elif choice == 2:\n                    self._save_history(history)\n                    break\n                elif choice == 3:\n                    self._save_all(model_info, history, metrics)\n                    break\n                elif choice == 4:\n                    break\n                else:\n                    print(\"Please enter a number between 1 and 4\")\n            except ValueError:\n                print(\"Please enter a valid number\")\n    \n    def _save_model(self, model_info: Dict[str, Any]):\n        \"\"\"Save just the model\"\"\"\n        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')"
        },
        "_save_model": {
          "start_line": 893,
          "end_line": 904,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "model_info"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "....strftime",
              "line": 895
            },
            {
              "name": "os.path.join",
              "line": 896
            },
            {
              "name": "torch.save",
              "line": 899
            },
            {
              "name": "print",
              "line": 900
            },
            {
              "name": "print",
              "line": 902
            },
            {
              "name": "datetime.now",
              "line": 895
            },
            {
              "name": "....state_dict",
              "line": 899
            }
          ],
          "docstring": "Save just the model",
          "code_snippet": "                print(\"Please enter a valid number\")\n    \n    def _save_model(self, model_info: Dict[str, Any]):\n        \"\"\"Save just the model\"\"\"\n        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')\n        model_path = os.path.join(self.results_dir, f\"{self.model_type}_{self.dataset_type}_model_{timestamp}.pth\")\n        \n        if 'model' in model_info:\n            torch.save(model_info['model'].state_dict(), model_path)\n            print(f\"Model saved to {model_path}\")\n        else:\n            print(\"No model found to save\")\n    \n    def _save_history(self, history: Dict[str, Any]):\n        \"\"\"Save training history\"\"\"\n        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')"
        },
        "_save_history": {
          "start_line": 904,
          "end_line": 922,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "history"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "....strftime",
              "line": 906
            },
            {
              "name": "os.path.join",
              "line": 907
            },
            {
              "name": "history.items",
              "line": 911
            },
            {
              "name": "print",
              "line": 920
            },
            {
              "name": "isinstance",
              "line": 912
            },
            {
              "name": "open",
              "line": 917
            },
            {
              "name": "json.dump",
              "line": 918
            },
            {
              "name": "datetime.now",
              "line": 906
            },
            {
              "name": "str",
              "line": 915
            },
            {
              "name": "type",
              "line": 912
            }
          ],
          "docstring": "Save training history",
          "code_snippet": "            print(\"No model found to save\")\n    \n    def _save_history(self, history: Dict[str, Any]):\n        \"\"\"Save training history\"\"\"\n        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')\n        history_path = os.path.join(self.results_dir, f\"{self.model_type}_{self.dataset_type}_history_{timestamp}.json\")\n        \n        # Convert any non-serializable values to strings\n        serializable_history = {}\n        for k, v in history.items():\n            if isinstance(v, (list, dict, str, int, float, bool, type(None))):\n                serializable_history[k] = v\n            else:\n                serializable_history[k] = str(v)\n        \n        with open(history_path, 'w') as f:\n            json.dump(serializable_history, f, indent=2)\n        \n        print(f\"Training history saved to {history_path}\")\n    \n    def _save_all(self, model_info: Dict[str, Any], history: Dict[str, Any], metrics: Dict[str, Any]):\n        \"\"\"Save all training artifacts\"\"\"\n        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')"
        },
        "_save_all": {
          "start_line": 922,
          "end_line": 962,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "model_info"
            },
            {
              "name": "history"
            },
            {
              "name": "metrics"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "....strftime",
              "line": 924
            },
            {
              "name": "os.path.join",
              "line": 925
            },
            {
              "name": "make_serializable",
              "line": 953
            },
            {
              "name": "print",
              "line": 960
            },
            {
              "name": "torch.save",
              "line": 930
            },
            {
              "name": "print",
              "line": 931
            },
            {
              "name": "isinstance",
              "line": 944
            },
            {
              "name": "open",
              "line": 957
            },
            {
              "name": "json.dump",
              "line": 958
            },
            {
              "name": "datetime.now",
              "line": 924
            },
            {
              "name": "....state_dict",
              "line": 930
            },
            {
              "name": "isinstance",
              "line": 946
            },
            {
              "name": "model_info.items",
              "line": 937
            },
            {
              "name": "make_serializable",
              "line": 945
            },
            {
              "name": "isinstance",
              "line": 948
            },
            {
              "name": "isinstance",
              "line": 937
            },
            {
              "name": "make_serializable",
              "line": 947
            },
            {
              "name": "str",
              "line": 951
            },
            {
              "name": "obj.items",
              "line": 947
            },
            {
              "name": "type",
              "line": 948
            }
          ],
          "docstring": "Save all training artifacts",
          "code_snippet": "        print(f\"Training history saved to {history_path}\")\n    \n    def _save_all(self, model_info: Dict[str, Any], history: Dict[str, Any], metrics: Dict[str, Any]):\n        \"\"\"Save all training artifacts\"\"\"\n        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')\n        base_path = os.path.join(self.results_dir, f\"{self.model_type}_{self.dataset_type}_{timestamp}\")\n        \n        # Save model\n        if 'model' in model_info:\n            model_path = f\"{base_path}_model.pth\"\n            torch.save(model_info['model'].state_dict(), model_path)\n            print(f\"Model saved to {model_path}\")\n        \n        # Save history and metrics\n        combined_data = {\n            \"history\": history,\n            \"metrics\": metrics,\n            \"model_info\": {k: v for k, v in model_info.items() if not isinstance(v, torch.nn.Module)},\n            \"hardware_info\": self.hardware_info,\n            \"training_time\": (self.training_end_time - self.training_start_time) if self.training_end_time else None\n        }\n        \n        # Convert non-serializable values\n        def make_serializable(obj):\n            if isinstance(obj, (list, tuple)):\n                return [make_serializable(item) for item in obj]\n            elif isinstance(obj, dict):\n                return {k: make_serializable(v) for k, v in obj.items()}\n            elif isinstance(obj, (int, float, str, bool, type(None))):\n                return obj\n            else:\n                return str(obj)\n        \n        combined_data = make_serializable(combined_data)\n        \n        # Save to JSON\n        data_path = f\"{base_path}_data.json\"\n        with open(data_path, 'w') as f:\n            json.dump(combined_data, f, indent=2)\n        \n        print(f\"All data saved to {data_path}\")\n    \n    def start_training_ui(self) -> Dict[str, Any]:\n        \"\"\"\n        Initialize the training UI and gather settings."
        },
        "start_training_ui": {
          "start_line": 962,
          "end_line": 1022,
          "parameters": [
            {
              "name": "self"
            }
          ],
          "return_type": "complex_type",
          "calls": [
            {
              "name": "self.display_welcome",
              "line": 969
            },
            {
              "name": "self.select_dataset",
              "line": 974
            },
            {
              "name": "print",
              "line": 981
            },
            {
              "name": "input",
              "line": 982
            },
            {
              "name": "self.select_model",
              "line": 987
            },
            {
              "name": "self.confirm_settings",
              "line": 1009
            },
            {
              "name": "time.time",
              "line": 1012
            }
          ],
          "docstring": "\n        Initialize the training UI and gather settings.\n        \n        Returns:\n            Dictionary with selected training settings\n        ",
          "code_snippet": "        print(f\"All data saved to {data_path}\")\n    \n    def start_training_ui(self) -> Dict[str, Any]:\n        \"\"\"\n        Initialize the training UI and gather settings.\n        \n        Returns:\n            Dictionary with selected training settings\n        \"\"\"\n        self.display_welcome()\n        \n        # Flow control for the UI navigation\n        while True:\n            # Select dataset first\n            dataset_type = self.select_dataset()\n            \n            if dataset_type is None:\n                # Should not happen on first run, but handle it gracefully\n                continue\n                \n            # Proceed directly to model selection\n            print(\"\\nPress Enter to continue to model selection...\")\n            input()\n            \n            # Now select model with back navigation\n            model_selection_loop = True\n            while model_selection_loop:\n                model_type = self.select_model()\n                \n                # User selected a model, proceed to settings\n                model_selection_loop = False\n                \n                # Default settings\n                settings = {\n                    'model_type': model_type,\n                    'dataset_type': dataset_type,\n                    'epochs': 15,\n                    'optimizer': 'eve_unified',\n                    'use_pretrained': self.use_pretrained,  # Use the value from model selection\n                    'input_size': 32,\n                    'num_classes': 10 if dataset_type == \"cifar10\" else 100,\n                    'weight_range': 'default',\n                    'lr_sensitivity': 'high',\n                    'use_augmentation': True,\n                    'accuracy_goal': 90.0,  # Default accuracy goal as percentage\n                    'training_mode': 'epochs'  # Default to fixed epochs rather than accuracy goal\n                }\n                \n                # Confirm settings with proper back navigation\n                confirmed = self.confirm_settings(settings)\n                if confirmed:\n                    # User confirmed settings, proceed with training\n                    self.training_start_time = time.time()\n                    return settings\n                    \n            # If we get here, go back to dataset selection\n            continue\n        \n        # This line should never be reached due to the return in the inner loop\n        # or the sys.exit() calls for quitting the program\n        return {}\n    \n    def end_training_ui(self, history: Dict[str, Any], model_info: Dict[str, Any], metrics: Dict[str, Any]):\n        \"\"\"End the training UI and display final results\"\"\"\n        self.training_end_time = time.time()"
        },
        "end_training_ui": {
          "start_line": 1022,
          "end_line": 1027,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "history"
            },
            {
              "name": "model_info"
            },
            {
              "name": "metrics"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "time.time",
              "line": 1024
            },
            {
              "name": "self.display_final_results",
              "line": 1025
            }
          ],
          "docstring": "End the training UI and display final results",
          "code_snippet": "        return {}\n    \n    def end_training_ui(self, history: Dict[str, Any], model_info: Dict[str, Any], metrics: Dict[str, Any]):\n        \"\"\"End the training UI and display final results\"\"\"\n        self.training_end_time = time.time()\n        self.display_final_results(history, model_info, metrics)\n\n\ndef parse_args():\n    \"\"\"Parse command line arguments\"\"\""
        }
      },
      "class_variables": [],
      "bases": [],
      "docstring": "Terminal User Interface for the IsekaiZen ML Optimization Framework"
    },
    "UrwidTerminalUI": {
      "start_line": 1040,
      "end_line": 1905,
      "methods": {
        "__init__": {
          "start_line": 1066,
          "end_line": 1086,
          "parameters": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "self._get_hardware_info",
              "line": 1073
            },
            {
              "name": "os.path.join",
              "line": 1074
            },
            {
              "name": "os.makedirs",
              "line": 1075
            }
          ],
          "docstring": "Initialize the urwid terminal UI",
          "code_snippet": "    ]\n    \n    def __init__(self):\n        \"\"\"Initialize the urwid terminal UI\"\"\"\n        self.model_type = None\n        self.dataset_type = None\n        self.use_pretrained = False\n        self.training_start_time = None\n        self.training_end_time = None\n        self.hardware_info = self._get_hardware_info()\n        self.results_dir = os.path.join(\"examples\", \"output\")\n        os.makedirs(self.results_dir, exist_ok=True)\n        \n        # Set up screen stack for navigation\n        self.screen_stack = []\n        \n        # Store settings\n        self.settings = {}\n        \n        # Initialize main loop\n        self.loop = None\n        \n    def _get_hardware_info(self) -> Dict[str, Any]:\n        \"\"\"Get system hardware information\"\"\"\n        hw_info = {"
        },
        "_get_hardware_info": {
          "start_line": 1086,
          "end_line": 1105,
          "parameters": [
            {
              "name": "self"
            }
          ],
          "return_type": "complex_type",
          "calls": [
            {
              "name": "platform.system",
              "line": 1089
            },
            {
              "name": "platform.version",
              "line": 1090
            },
            {
              "name": "platform.processor",
              "line": 1091
            },
            {
              "name": "psutil.cpu_count",
              "line": 1092
            },
            {
              "name": "psutil.cpu_count",
              "line": 1093
            },
            {
              "name": "torch.cuda.is_available",
              "line": 1095
            },
            {
              "name": "torch.cuda.device_count",
              "line": 1099
            },
            {
              "name": "psutil.virtual_memory",
              "line": 1094
            },
            {
              "name": "torch.cuda.get_device_name",
              "line": 1100
            },
            {
              "name": "range",
              "line": 1100
            }
          ],
          "docstring": "Get system hardware information",
          "code_snippet": "        self.loop = None\n        \n    def _get_hardware_info(self) -> Dict[str, Any]:\n        \"\"\"Get system hardware information\"\"\"\n        hw_info = {\n            \"platform\": platform.system(),\n            \"platform_version\": platform.version(),\n            \"processor\": platform.processor(),\n            \"cpu_cores\": psutil.cpu_count(logical=False),\n            \"cpu_threads\": psutil.cpu_count(logical=True),\n            \"memory_total\": psutil.virtual_memory().total,\n            \"has_gpu\": torch.cuda.is_available(),\n        }\n        \n        if hw_info[\"has_gpu\"]:\n            hw_info[\"gpu_count\"] = torch.cuda.device_count()\n            hw_info[\"gpu_names\"] = [torch.cuda.get_device_name(i) for i in range(hw_info[\"gpu_count\"])]\n            hw_info[\"cuda_version\"] = torch.version.cuda\n            \n        return hw_info\n    \n    def exit_program(self, button=None):\n        \"\"\"Exit the program gracefully\"\"\"\n        raise urwid.ExitMainLoop()"
        },
        "exit_program": {
          "start_line": 1105,
          "end_line": 1109,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "button"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "urwid.ExitMainLoop",
              "line": 1107
            }
          ],
          "docstring": "Exit the program gracefully",
          "code_snippet": "        return hw_info\n    \n    def exit_program(self, button=None):\n        \"\"\"Exit the program gracefully\"\"\"\n        raise urwid.ExitMainLoop()\n    \n    def go_back(self, button=None):\n        \"\"\"Navigate back to the previous screen\"\"\"\n        if len(self.screen_stack) > 1:"
        },
        "go_back": {
          "start_line": 1109,
          "end_line": 1116,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "button"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "len",
              "line": 1111
            },
            {
              "name": "self.screen_stack.pop",
              "line": 1112
            }
          ],
          "docstring": "Navigate back to the previous screen",
          "code_snippet": "        raise urwid.ExitMainLoop()\n    \n    def go_back(self, button=None):\n        \"\"\"Navigate back to the previous screen\"\"\"\n        if len(self.screen_stack) > 1:\n            self.screen_stack.pop()  # Remove current screen\n            previous_screen = self.screen_stack[-1]  # Get previous screen\n            self.loop.widget = previous_screen\n        \n    def push_screen(self, screen):\n        \"\"\"Add a new screen to the navigation stack and display it\"\"\"\n        self.screen_stack.append(screen)"
        },
        "push_screen": {
          "start_line": 1116,
          "end_line": 1122,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "screen"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "self.screen_stack.append",
              "line": 1118
            }
          ],
          "docstring": "Add a new screen to the navigation stack and display it",
          "code_snippet": "            self.loop.widget = previous_screen\n        \n    def push_screen(self, screen):\n        \"\"\"Add a new screen to the navigation stack and display it\"\"\"\n        self.screen_stack.append(screen)\n        if self.loop:\n            self.loop.widget = screen\n    \n    def create_button(self, label, callback, user_data=None):\n        \"\"\"Create a styled button\"\"\"\n        button = urwid.Button(label)"
        },
        "create_button": {
          "start_line": 1122,
          "end_line": 1128,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "label"
            },
            {
              "name": "callback"
            },
            {
              "name": "user_data"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "urwid.Button",
              "line": 1124
            },
            {
              "name": "urwid.connect_signal",
              "line": 1125
            },
            {
              "name": "urwid.AttrMap",
              "line": 1126
            }
          ],
          "docstring": "Create a styled button",
          "code_snippet": "            self.loop.widget = screen\n    \n    def create_button(self, label, callback, user_data=None):\n        \"\"\"Create a styled button\"\"\"\n        button = urwid.Button(label)\n        urwid.connect_signal(button, 'click', callback, user_data)\n        return urwid.AttrMap(button, 'button', focus_map='button_focus')\n    \n    def create_header(self, title):\n        \"\"\"Create a header widget with title\"\"\"\n        header_text = f\"IsekaiZen ML Optimization Framework - {title}\""
        },
        "create_header": {
          "start_line": 1128,
          "end_line": 1133,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "title"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "urwid.AttrMap",
              "line": 1131
            },
            {
              "name": "urwid.Text",
              "line": 1131
            }
          ],
          "docstring": "Create a header widget with title",
          "code_snippet": "        return urwid.AttrMap(button, 'button', focus_map='button_focus')\n    \n    def create_header(self, title):\n        \"\"\"Create a header widget with title\"\"\"\n        header_text = f\"IsekaiZen ML Optimization Framework - {title}\"\n        return urwid.AttrMap(urwid.Text(header_text, align='center'), 'header')\n    \n    def create_footer(self):\n        \"\"\"Create a footer widget with navigation help\"\"\"\n        footer_text = \"Q: Quit  |  B: Back  |  Enter: Select\""
        },
        "create_footer": {
          "start_line": 1133,
          "end_line": 1138,
          "parameters": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "urwid.AttrMap",
              "line": 1136
            },
            {
              "name": "urwid.Text",
              "line": 1136
            }
          ],
          "docstring": "Create a footer widget with navigation help",
          "code_snippet": "        return urwid.AttrMap(urwid.Text(header_text, align='center'), 'header')\n    \n    def create_footer(self):\n        \"\"\"Create a footer widget with navigation help\"\"\"\n        footer_text = \"Q: Quit  |  B: Back  |  Enter: Select\"\n        return urwid.AttrMap(urwid.Text(footer_text, align='center'), 'footer')\n    \n    def create_welcome_screen(self):\n        \"\"\"Create the welcome screen\"\"\"\n        # Header"
        },
        "create_welcome_screen": {
          "start_line": 1138,
          "end_line": 1204,
          "parameters": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "self.create_header",
              "line": 1141
            },
            {
              "name": "urwid.Text",
              "line": 1147
            },
            {
              "name": "urwid.Text",
              "line": 1148
            },
            {
              "name": "urwid.Text",
              "line": 1150
            },
            {
              "name": "urwid.Text",
              "line": 1162
            },
            {
              "name": "self.create_button",
              "line": 1173
            },
            {
              "name": "self.create_button",
              "line": 1174
            },
            {
              "name": "urwid.GridFlow",
              "line": 1175
            },
            {
              "name": "urwid.Pile",
              "line": 1178
            },
            {
              "name": "urwid.Padding",
              "line": 1190
            },
            {
              "name": "urwid.AttrMap",
              "line": 1193
            },
            {
              "name": "urwid.Frame",
              "line": 1196
            },
            {
              "name": "....join",
              "line": 1156
            },
            {
              "name": "urwid.Text",
              "line": 1157
            },
            {
              "name": "urwid.Text",
              "line": 1159
            },
            {
              "name": "urwid.Text",
              "line": 1193
            },
            {
              "name": "urwid.Filler",
              "line": 1197
            },
            {
              "name": "urwid.Divider",
              "line": 1180
            },
            {
              "name": "urwid.Divider",
              "line": 1184
            },
            {
              "name": "urwid.Divider",
              "line": 1186
            }
          ],
          "docstring": "Create the welcome screen",
          "code_snippet": "        return urwid.AttrMap(urwid.Text(footer_text, align='center'), 'footer')\n    \n    def create_welcome_screen(self):\n        \"\"\"Create the welcome screen\"\"\"\n        # Header\n        header = self.create_header(\"Welcome\")\n        \n        # Content\n        hw_info = self.hardware_info\n        \n        # System overview section\n        sys_title = urwid.Text(('title', \"System Overview:\"))\n        platform_text = urwid.Text(f\"Platform: {hw_info['platform']} {hw_info['platform_version']}\")\n        \n        hardware_text = urwid.Text(\n            f\"Hardware: {hw_info['processor']} | {hw_info['cpu_cores']} cores | \"\n            f\"{hw_info['memory_total'] / (1024**3):.1f} GB RAM\"\n        )\n        \n        if hw_info[\"has_gpu\"]:\n            gpu_names = \", \".join(hw_info[\"gpu_names\"])\n            gpu_text = urwid.Text(('success', f\"GPU: {gpu_names}\"))\n        else:\n            gpu_text = urwid.Text(('warning', \"GPU: None detected. CPU will be used for training.\"))\n        \n        # Welcome message\n        welcome_msg = urwid.Text([\n            \"\\nIsekaiZen\u2122 optimizes machine learning performance based on \",\n            ('highlight', \"pattern recognition\"),\n            \" and \",\n            ('highlight', \"hardware capabilities\"),\n            \".\\n\\n\"\n            \"This interface will guide you through the process of selecting a dataset,\\n\"\n            \"choosing a model, and configuring training parameters.\"\n        ])\n        \n        # Start button\n        start_button = self.create_button(\"Start\", self.show_dataset_selection)\n        quit_button = self.create_button(\"Quit\", self.exit_program)\n        buttons = urwid.GridFlow([start_button, quit_button], 15, 3, 1, 'center')\n        \n        # Combine all elements\n        content = urwid.Pile([\n            sys_title,\n            urwid.Divider(),\n            platform_text,\n            hardware_text, \n            gpu_text,\n            urwid.Divider(),\n            welcome_msg,\n            urwid.Divider(),\n            buttons\n        ])\n        \n        content = urwid.Padding(content, left=2, right=2)\n        \n        # Footer\n        footer = urwid.AttrMap(urwid.Text(\"Press Q to quit, Enter to continue\", align='center'), 'footer')\n        \n        # Create frame\n        frame = urwid.Frame(\n            urwid.Filler(content, valign='top', top=1, bottom=1),\n            header=header,\n            footer=footer\n        )\n        \n        return frame\n    \n    def show_dataset_selection(self, button=None):\n        \"\"\"Show the dataset selection screen\"\"\"\n        dataset_screen = self.create_dataset_selection_screen()"
        },
        "show_dataset_selection": {
          "start_line": 1204,
          "end_line": 1209,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "button"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "self.create_dataset_selection_screen",
              "line": 1206
            },
            {
              "name": "self.push_screen",
              "line": 1207
            }
          ],
          "docstring": "Show the dataset selection screen",
          "code_snippet": "        return frame\n    \n    def show_dataset_selection(self, button=None):\n        \"\"\"Show the dataset selection screen\"\"\"\n        dataset_screen = self.create_dataset_selection_screen()\n        self.push_screen(dataset_screen)\n    \n    def create_dataset_selection_screen(self):\n        \"\"\"Create the dataset selection screen\"\"\"\n        # Header"
        },
        "create_dataset_selection_screen": {
          "start_line": 1209,
          "end_line": 1308,
          "parameters": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "self.create_header",
              "line": 1212
            },
            {
              "name": "urwid.Text",
              "line": 1244
            },
            {
              "name": "urwid.Text",
              "line": 1270
            },
            {
              "name": "self.create_button",
              "line": 1277
            },
            {
              "name": "self.create_button",
              "line": 1278
            },
            {
              "name": "self.create_button",
              "line": 1279
            },
            {
              "name": "urwid.GridFlow",
              "line": 1281
            },
            {
              "name": "urwid.Pile",
              "line": 1284
            },
            {
              "name": "urwid.Padding",
              "line": 1294
            },
            {
              "name": "self.create_footer",
              "line": 1297
            },
            {
              "name": "urwid.Frame",
              "line": 1300
            },
            {
              "name": "info.get",
              "line": 1249
            },
            {
              "name": "urwid.Filler",
              "line": 1301
            },
            {
              "name": "urwid.Text",
              "line": 1260
            },
            {
              "name": "dataset_buttons.append",
              "line": 1261
            },
            {
              "name": "urwid.Button",
              "line": 1264
            },
            {
              "name": "urwid.connect_signal",
              "line": 1265
            },
            {
              "name": "dataset_buttons.append",
              "line": 1267
            },
            {
              "name": "urwid.Divider",
              "line": 1286
            },
            {
              "name": "urwid.Divider",
              "line": 1288
            },
            {
              "name": "urwid.Divider",
              "line": 1290
            },
            {
              "name": "urwid.AttrMap",
              "line": 1267
            },
            {
              "name": "self.on_dataset_selected",
              "line": 1266
            }
          ],
          "docstring": "Create the dataset selection screen",
          "code_snippet": "        self.push_screen(dataset_screen)\n    \n    def create_dataset_selection_screen(self):\n        \"\"\"Create the dataset selection screen\"\"\"\n        # Header\n        header = self.create_header(\"Dataset Selection\")\n        \n        # Define dataset information\n        dataset_info = {\n            \"cifar10\": {\n                \"description\": \"10-class color image dataset with 60,000 32x32 images\",\n                \"classes\": \"10 classes: airplane, automobile, bird, cat, deer, dog, frog, horse, ship, truck\",\n                \"size\": \"50,000 training images, 10,000 test images\",\n                \"dimensions\": \"32x32 RGB color images\",\n                \"ideal_for\": \"Basic computer vision experiments and benchmarking\",\n                \"data_size\": \"Small\",\n                \"complexity\": \"Low to Medium\"\n            },\n            \"cifar100\": {\n                \"description\": \"100-class color image dataset with 60,000 32x32 images\",\n                \"classes\": \"100 fine-grained classes organized into 20 super-classes\",\n                \"size\": \"50,000 training images, 10,000 test images\",\n                \"dimensions\": \"32x32 RGB color images\",\n                \"ideal_for\": \"More challenging classification tasks with finer-grained categories\",\n                \"data_size\": \"Medium\",\n                \"complexity\": \"Medium to High\"\n            },\n            \"more datasets coming soon\": {\n                \"description\": \"Support for additional datasets is coming in future updates\",\n                \"note\": \"Planned datasets include ImageNet (Large), MNIST (Small), Fashion-MNIST (Small), and custom dataset loading\",\n                \"eta\": \"Check the GitHub repository for updates\",\n                \"data_size\": \"Various\",\n                \"complexity\": \"Various\"\n            }\n        }\n        \n        # Content - Simple mode initially\n        title = urwid.Text(('title', \"Available Datasets:\"))\n        \n        dataset_buttons = []\n        for dataset_name in [\"cifar10\", \"cifar100\", \"more datasets coming soon\"]:\n            info = dataset_info[dataset_name]\n            data_size = info.get('data_size', '')\n            \n            # Create button text with size category\n            if data_size:\n                button_text = f\"{dataset_name} - {data_size}\"\n            else:\n                button_text = dataset_name\n                \n            # Create button\n            if \"more datasets coming soon\" in dataset_name:\n                # This one is not clickable\n                button = urwid.Text(('info', f\"\u2022 {button_text} (Coming Soon)\"))\n                dataset_buttons.append(button)\n            else:\n                # Create clickable button\n                button = urwid.Button(button_text)\n                urwid.connect_signal(button, 'click', \n                                    lambda b, name=dataset_name: self.on_dataset_selected(b, name))\n                dataset_buttons.append(urwid.AttrMap(button, 'button', focus_map='button_focus'))\n        \n        # Preprocessing note\n        note = urwid.Text([\n            ('info', \"\\nNote: \"),\n            \"New datasets require preprocessing before training.\\n\",\n            \"The IsekaiZen framework will handle this automatically.\"\n        ])\n        \n        # Detail toggle button\n        detail_button = self.create_button(\"Show Details\", self.toggle_dataset_details)\n        back_button = self.create_button(\"Back\", self.go_back)\n        quit_button = self.create_button(\"Quit\", self.exit_program)\n        \n        buttons = urwid.GridFlow([detail_button, back_button, quit_button], 15, 3, 1, 'center')\n        \n        # Create main content\n        content = urwid.Pile([\n            title,\n            urwid.Divider(),\n            *dataset_buttons,\n            urwid.Divider(),\n            note,\n            urwid.Divider(),\n            buttons\n        ])\n        \n        content = urwid.Padding(content, left=2, right=2)\n        \n        # Footer\n        footer = self.create_footer()\n        \n        # Create frame\n        frame = urwid.Frame(\n            urwid.Filler(content, valign='top', top=1, bottom=1),\n            header=header,\n            footer=footer\n        )\n        \n        return frame\n    \n    def toggle_dataset_details(self, button):\n        \"\"\"Toggle between simple and detailed dataset views\"\"\"\n        # We'd implement this in a full version"
        },
        "toggle_dataset_details": {
          "start_line": 1308,
          "end_line": 1314,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "button"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "self.show_dialog",
              "line": 1312
            }
          ],
          "docstring": "Toggle between simple and detailed dataset views",
          "code_snippet": "        return frame\n    \n    def toggle_dataset_details(self, button):\n        \"\"\"Toggle between simple and detailed dataset views\"\"\"\n        # We'd implement this in a full version\n        # For now, just show a message\n        self.show_dialog(\"Feature Coming Soon\", \"Detailed dataset view will be available in the next update.\")\n    \n    def on_dataset_selected(self, button, dataset_name):\n        \"\"\"Handle dataset selection\"\"\"\n        self.dataset_type = dataset_name"
        },
        "on_dataset_selected": {
          "start_line": 1314,
          "end_line": 1324,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "button"
            },
            {
              "name": "dataset_name"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "self.create_model_selection_screen",
              "line": 1321
            },
            {
              "name": "self.push_screen",
              "line": 1322
            }
          ],
          "docstring": "Handle dataset selection",
          "code_snippet": "        self.show_dialog(\"Feature Coming Soon\", \"Detailed dataset view will be available in the next update.\")\n    \n    def on_dataset_selected(self, button, dataset_name):\n        \"\"\"Handle dataset selection\"\"\"\n        self.dataset_type = dataset_name\n        self.settings['dataset_type'] = dataset_name\n        self.settings['num_classes'] = 10 if dataset_name == \"cifar10\" else 100\n        \n        # Move to model selection\n        model_screen = self.create_model_selection_screen()\n        self.push_screen(model_screen)\n    \n    def create_model_selection_screen(self):\n        \"\"\"Create the model selection screen\"\"\"\n        # Header"
        },
        "create_model_selection_screen": {
          "start_line": 1324,
          "end_line": 1447,
          "parameters": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "self.create_header",
              "line": 1327
            },
            {
              "name": "urwid.Text",
              "line": 1376
            },
            {
              "name": "model_info.keys",
              "line": 1379
            },
            {
              "name": "urwid.Text",
              "line": 1402
            },
            {
              "name": "urwid.CheckBox",
              "line": 1409
            },
            {
              "name": "urwid.AttrMap",
              "line": 1412
            },
            {
              "name": "self.create_button",
              "line": 1415
            },
            {
              "name": "self.create_button",
              "line": 1416
            },
            {
              "name": "self.create_button",
              "line": 1417
            },
            {
              "name": "urwid.GridFlow",
              "line": 1419
            },
            {
              "name": "urwid.Pile",
              "line": 1422
            },
            {
              "name": "urwid.Padding",
              "line": 1433
            },
            {
              "name": "self.create_footer",
              "line": 1436
            },
            {
              "name": "urwid.Frame",
              "line": 1439
            },
            {
              "name": "info.get",
              "line": 1381
            },
            {
              "name": "info.get",
              "line": 1382
            },
            {
              "name": "urwid.connect_signal",
              "line": 1397
            },
            {
              "name": "model_buttons.append",
              "line": 1399
            },
            {
              "name": "urwid.Filler",
              "line": 1440
            },
            {
              "name": "urwid.Button",
              "line": 1390
            },
            {
              "name": "urwid.AttrMap",
              "line": 1391
            },
            {
              "name": "urwid.Button",
              "line": 1394
            },
            {
              "name": "urwid.AttrMap",
              "line": 1395
            },
            {
              "name": "urwid.Divider",
              "line": 1424
            },
            {
              "name": "urwid.Divider",
              "line": 1427
            },
            {
              "name": "urwid.Divider",
              "line": 1429
            },
            {
              "name": "self.on_model_selected",
              "line": 1398
            }
          ],
          "docstring": "Create the model selection screen",
          "code_snippet": "        self.push_screen(model_screen)\n    \n    def create_model_selection_screen(self):\n        \"\"\"Create the model selection screen\"\"\"\n        # Header\n        header = self.create_header(\"Model Selection\")\n        \n        # Model information dictionary with brief descriptions\n        model_info = {\n            \"resnet18\": {\n                \"description\": \"Lightweight ResNet model with 18 layers\",\n                \"parameters\": \"11.7M parameters\",\n                \"performance\": \"Good balance of accuracy and speed\",\n                \"ideal_for\": \"Small to medium-sized datasets, quick training\",\n                \"recommended_for\": [\"cifar10\"]\n            },\n            \"resnet34\": {\n                \"description\": \"Medium-depth ResNet model with 34 layers\",\n                \"parameters\": \"21.8M parameters\",\n                \"performance\": \"Better accuracy than ResNet18 with reasonable training time\",\n                \"ideal_for\": \"Medium-sized datasets with complex features\",\n                \"recommended_for\": [\"cifar10\", \"cifar100\"]\n            },\n            \"resnet50\": {\n                \"description\": \"Deep ResNet model with 50 layers and bottleneck blocks\",\n                \"parameters\": \"25.6M parameters\",\n                \"performance\": \"High accuracy with moderate training requirements\",\n                \"ideal_for\": \"Complex vision tasks requiring high accuracy\",\n                \"recommended_for\": [\"cifar100\"]\n            },\n            \"vgg16\": {\n                \"description\": \"Classic VGG architecture with 16 layers\",\n                \"parameters\": \"138M parameters\",\n                \"performance\": \"Good feature extraction, but slower training\",\n                \"ideal_for\": \"Feature extraction and transfer learning\",\n                \"recommended_for\": []\n            },\n            \"mobilenet_v2\": {\n                \"description\": \"Efficient architecture designed for mobile devices\",\n                \"parameters\": \"3.5M parameters\",\n                \"performance\": \"Fast inference with good accuracy/size tradeoff\",\n                \"ideal_for\": \"Resource-constrained environments, edge devices\",\n                \"recommended_for\": [\"cifar10\"]\n            },\n            \"efficientnet_b0\": {\n                \"description\": \"Compound scaling architecture optimized for efficiency\",\n                \"parameters\": \"5.3M parameters\",\n                \"performance\": \"Excellent accuracy/parameter ratio\",\n                \"ideal_for\": \"Balanced performance and efficiency requirements\",\n                \"recommended_for\": [\"cifar10\", \"cifar100\"]\n            }\n        }\n        \n        # Content\n        title = urwid.Text(('title', \"Available Models:\"))\n        \n        model_buttons = []\n        for model_name in model_info.keys():\n            info = model_info[model_name]\n            parameters = info.get('parameters', '')\n            recommended_for = info.get('recommended_for', [])\n            \n            # Check if model is recommended for selected dataset\n            is_recommended = self.dataset_type in recommended_for\n            \n            # Create button text with params and recommendation\n            if is_recommended:\n                button_text = f\"{model_name} * - {parameters}\"\n                button = urwid.Button(button_text)\n                model_button = urwid.AttrMap(button, 'recommended', focus_map='button_focus')\n            else:\n                button_text = f\"{model_name} - {parameters}\"\n                button = urwid.Button(button_text)\n                model_button = urwid.AttrMap(button, 'button', focus_map='button_focus')\n                \n            urwid.connect_signal(button, 'click', \n                               lambda b, name=model_name: self.on_model_selected(b, name))\n            model_buttons.append(model_button)\n        \n        # Legend\n        legend = urwid.Text([\n            ('highlight', \"\\nModels marked with * are recommended for \"),\n            ('value', self.dataset_type),\n            \".\"\n        ])\n        \n        # Pre-trained toggle\n        pretrained_checkbox = urwid.CheckBox(\"Use pre-trained weights\", \n                                          state=self.use_pretrained, \n                                          on_state_change=self.toggle_pretrained)\n        pretrained_checkbox = urwid.AttrMap(pretrained_checkbox, 'edit', focus_map='edit_focus')\n        \n        # Detail toggle and navigation buttons\n        detail_button = self.create_button(\"Show Details\", self.toggle_model_details)\n        back_button = self.create_button(\"Back\", self.go_back)\n        quit_button = self.create_button(\"Quit\", self.exit_program)\n        \n        buttons = urwid.GridFlow([detail_button, back_button, quit_button], 15, 3, 1, 'center')\n        \n        # Create main content\n        content = urwid.Pile([\n            title,\n            urwid.Divider(),\n            *model_buttons,\n            legend,\n            urwid.Divider(),\n            pretrained_checkbox,\n            urwid.Divider(),\n            buttons\n        ])\n        \n        content = urwid.Padding(content, left=2, right=2)\n        \n        # Footer\n        footer = self.create_footer()\n        \n        # Create frame\n        frame = urwid.Frame(\n            urwid.Filler(content, valign='top', top=1, bottom=1),\n            header=header,\n            footer=footer\n        )\n        \n        return frame\n    \n    def toggle_pretrained(self, checkbox, new_state):\n        \"\"\"Toggle pre-trained weights\"\"\"\n        self.use_pretrained = new_state"
        },
        "toggle_pretrained": {
          "start_line": 1447,
          "end_line": 1451,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "checkbox"
            },
            {
              "name": "new_state"
            }
          ],
          "return_type": null,
          "calls": [],
          "docstring": "Toggle pre-trained weights",
          "code_snippet": "        return frame\n    \n    def toggle_pretrained(self, checkbox, new_state):\n        \"\"\"Toggle pre-trained weights\"\"\"\n        self.use_pretrained = new_state\n        \n    def toggle_model_details(self, button):\n        \"\"\"Toggle between simple and detailed model views\"\"\"\n        # We'd implement this in a full version"
        },
        "toggle_model_details": {
          "start_line": 1451,
          "end_line": 1457,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "button"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "self.show_dialog",
              "line": 1455
            }
          ],
          "docstring": "Toggle between simple and detailed model views",
          "code_snippet": "        self.use_pretrained = new_state\n        \n    def toggle_model_details(self, button):\n        \"\"\"Toggle between simple and detailed model views\"\"\"\n        # We'd implement this in a full version\n        # For now, just show a message\n        self.show_dialog(\"Feature Coming Soon\", \"Detailed model view will be available in the next update.\")\n    \n    def on_model_selected(self, button, model_name):\n        \"\"\"Handle model selection\"\"\"\n        self.model_type = model_name"
        },
        "on_model_selected": {
          "start_line": 1457,
          "end_line": 1480,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "button"
            },
            {
              "name": "model_name"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "self.create_training_settings_screen",
              "line": 1477
            },
            {
              "name": "self.push_screen",
              "line": 1478
            },
            {
              "name": "self.settings.update",
              "line": 1465
            }
          ],
          "docstring": "Handle model selection",
          "code_snippet": "        self.show_dialog(\"Feature Coming Soon\", \"Detailed model view will be available in the next update.\")\n    \n    def on_model_selected(self, button, model_name):\n        \"\"\"Handle model selection\"\"\"\n        self.model_type = model_name\n        self.settings['model_type'] = model_name\n        self.settings['use_pretrained'] = self.use_pretrained\n        \n        # Set default settings\n        if 'epochs' not in self.settings:\n            self.settings.update({\n                'epochs': 15,\n                'optimizer': 'eve_unified',\n                'input_size': 32,\n                'weight_range': 'default',\n                'lr_sensitivity': 'high',\n                'use_augmentation': True,\n                'accuracy_goal': 90.0,\n                'training_mode': 'epochs'\n            })\n        \n        # Move to training settings\n        settings_screen = self.create_training_settings_screen()\n        self.push_screen(settings_screen)\n    \n    def create_training_settings_screen(self):\n        \"\"\"Create the training settings screen\"\"\"\n        # Header"
        },
        "create_training_settings_screen": {
          "start_line": 1480,
          "end_line": 1650,
          "parameters": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "self.create_header",
              "line": 1483
            },
            {
              "name": "urwid.Text",
              "line": 1492
            },
            {
              "name": "urwid.Text",
              "line": 1497
            },
            {
              "name": "urwid.RadioButton",
              "line": 1500
            },
            {
              "name": "urwid.RadioButton",
              "line": 1502
            },
            {
              "name": "urwid.connect_signal",
              "line": 1506
            },
            {
              "name": "urwid.connect_signal",
              "line": 1508
            },
            {
              "name": "urwid.Columns",
              "line": 1511
            },
            {
              "name": "urwid.Text",
              "line": 1536
            },
            {
              "name": "urwid.GridFlow",
              "line": 1544
            },
            {
              "name": "urwid.Text",
              "line": 1545
            },
            {
              "name": "urwid.Text",
              "line": 1548
            },
            {
              "name": "urwid.IntEdit",
              "line": 1549
            },
            {
              "name": "urwid.AttrMap",
              "line": 1550
            },
            {
              "name": "urwid.CheckBox",
              "line": 1553
            },
            {
              "name": "urwid.AttrMap",
              "line": 1556
            },
            {
              "name": "urwid.Text",
              "line": 1559
            },
            {
              "name": "urwid.Text",
              "line": 1562
            },
            {
              "name": "urwid.GridFlow",
              "line": 1570
            },
            {
              "name": "urwid.Text",
              "line": 1571
            },
            {
              "name": "urwid.Text",
              "line": 1574
            },
            {
              "name": "urwid.GridFlow",
              "line": 1582
            },
            {
              "name": "urwid.Text",
              "line": 1583
            },
            {
              "name": "urwid.Text",
              "line": 1586
            },
            {
              "name": "urwid.Text",
              "line": 1587
            },
            {
              "name": "urwid.Text",
              "line": 1588
            },
            {
              "name": "urwid.Text",
              "line": 1589
            },
            {
              "name": "self.create_button",
              "line": 1592
            },
            {
              "name": "self.create_button",
              "line": 1593
            },
            {
              "name": "self.create_button",
              "line": 1594
            },
            {
              "name": "urwid.GridFlow",
              "line": 1596
            },
            {
              "name": "urwid.Pile",
              "line": 1599
            },
            {
              "name": "urwid.Padding",
              "line": 1636
            },
            {
              "name": "self.create_footer",
              "line": 1639
            },
            {
              "name": "urwid.Frame",
              "line": 1642
            },
            {
              "name": "self.settings.get",
              "line": 1518
            },
            {
              "name": "urwid.Text",
              "line": 1521
            },
            {
              "name": "urwid.Text",
              "line": 1523
            },
            {
              "name": "urwid.IntEdit",
              "line": 1524
            },
            {
              "name": "urwid.AttrMap",
              "line": 1525
            },
            {
              "name": "urwid.Text",
              "line": 1528
            },
            {
              "name": "urwid.IntEdit",
              "line": 1529
            },
            {
              "name": "urwid.AttrMap",
              "line": 1530
            },
            {
              "name": "urwid.Text",
              "line": 1533
            },
            {
              "name": "urwid.Button",
              "line": 1540
            },
            {
              "name": "urwid.connect_signal",
              "line": 1541
            },
            {
              "name": "optimizer_options_list.append",
              "line": 1543
            },
            {
              "name": "urwid.Button",
              "line": 1566
            },
            {
              "name": "urwid.connect_signal",
              "line": 1567
            },
            {
              "name": "weight_range_options_list.append",
              "line": 1569
            },
            {
              "name": "urwid.Button",
              "line": 1578
            },
            {
              "name": "urwid.connect_signal",
              "line": 1579
            },
            {
              "name": "lr_options_list.append",
              "line": 1581
            },
            {
              "name": "urwid.ListBox",
              "line": 1643
            },
            {
              "name": "self.settings.get",
              "line": 1501
            },
            {
              "name": "self.settings.get",
              "line": 1503
            },
            {
              "name": "self.on_training_mode_change",
              "line": 1507
            },
            {
              "name": "self.on_training_mode_change",
              "line": 1509
            },
            {
              "name": "urwid.AttrMap",
              "line": 1543
            },
            {
              "name": "str",
              "line": 1549
            },
            {
              "name": "self.settings.get",
              "line": 1554
            },
            {
              "name": "urwid.AttrMap",
              "line": 1569
            },
            {
              "name": "urwid.AttrMap",
              "line": 1581
            },
            {
              "name": "urwid.Divider",
              "line": 1601
            },
            {
              "name": "urwid.Divider",
              "line": 1604
            },
            {
              "name": "urwid.Divider",
              "line": 1607
            },
            {
              "name": "urwid.Divider",
              "line": 1610
            },
            {
              "name": "urwid.Divider",
              "line": 1614
            },
            {
              "name": "urwid.Divider",
              "line": 1617
            },
            {
              "name": "urwid.Divider",
              "line": 1623
            },
            {
              "name": "urwid.Divider",
              "line": 1627
            },
            {
              "name": "urwid.Divider",
              "line": 1632
            },
            {
              "name": "urwid.SimpleListWalker",
              "line": 1643
            },
            {
              "name": "urwid.Text",
              "line": 1513
            },
            {
              "name": "str",
              "line": 1524
            },
            {
              "name": "str",
              "line": 1529
            },
            {
              "name": "self.on_optimizer_selected",
              "line": 1542
            },
            {
              "name": "self.settings.get",
              "line": 1549
            },
            {
              "name": "self.on_weight_range_selected",
              "line": 1568
            },
            {
              "name": "self.on_lr_sensitivity_selected",
              "line": 1580
            },
            {
              "name": "self.settings.get",
              "line": 1587
            },
            {
              "name": "self.settings.get",
              "line": 1588
            },
            {
              "name": "self.settings.get",
              "line": 1589
            },
            {
              "name": "int",
              "line": 1524
            },
            {
              "name": "self.settings.get",
              "line": 1529
            },
            {
              "name": "self.settings.get",
              "line": 1545
            },
            {
              "name": "self.settings.get",
              "line": 1571
            },
            {
              "name": "self.settings.get",
              "line": 1583
            },
            {
              "name": "self.settings.get",
              "line": 1524
            }
          ],
          "docstring": "Create the training settings screen",
          "code_snippet": "        self.push_screen(settings_screen)\n    \n    def create_training_settings_screen(self):\n        \"\"\"Create the training settings screen\"\"\"\n        # Header\n        header = self.create_header(\"Training Settings\")\n        \n        # Define available choices for dropdowns\n        optimizer_options = [\"eve_unified\", \"eve_simplified\", \"sgd\", \"adam\"]\n        weight_range_options = [\"default\", \"wide\", \"narrow\", \"adaptive\"]\n        lr_sensitivity_options = [\"high\", \"medium\", \"low\"]\n        training_mode_options = [\"epochs\", \"accuracy\"]\n        \n        # Content\n        title = urwid.Text(('title', \"Configure Training Settings:\"))\n        \n        # Create settings widgets based on current settings\n        \n        # Training Mode - Radio buttons\n        mode_title = urwid.Text(('label', \"Training Mode:\"))\n        mode_group = []\n        # Create radio buttons without connecting signals yet\n        epochs_radio = urwid.RadioButton(mode_group, \"Fixed Epochs\", \n                                       self.settings.get('training_mode') == 'epochs')\n        accuracy_radio = urwid.RadioButton(mode_group, \"Accuracy Goal\", \n                                         self.settings.get('training_mode') == 'accuracy')\n                                         \n        # Connect signals separately to avoid any parameter issues\n        urwid.connect_signal(epochs_radio, 'change', \n                            lambda source, new_state: self.on_training_mode_change(source, new_state, 'epochs'))\n        urwid.connect_signal(accuracy_radio, 'change', \n                            lambda source, new_state: self.on_training_mode_change(source, new_state, 'accuracy'))\n        \n        mode_selection = urwid.Columns([\n            ('pack', epochs_radio),\n            ('pack', urwid.Text(\" | \")),\n            ('pack', accuracy_radio)\n        ])\n        \n        # Create input fields\n        if self.settings.get('training_mode') == 'accuracy':\n            # Accuracy goal mode\n            epochs_caption = \"Max Epochs: N/A (Will train until accuracy goal is reached)\"\n            epochs_edit = urwid.Text(epochs_caption)\n            \n            accuracy_caption = urwid.Text(('label', \"Accuracy Goal (%):\"))\n            accuracy_edit = urwid.IntEdit(default=str(int(self.settings.get('accuracy_goal', 90))))\n            accuracy_edit = urwid.AttrMap(accuracy_edit, 'edit', focus_map='edit_focus')\n        else:\n            # Fixed epochs mode\n            epochs_caption = urwid.Text(('label', \"Maximum Epochs:\"))\n            epochs_edit = urwid.IntEdit(default=str(self.settings.get('epochs', 15)))\n            epochs_edit = urwid.AttrMap(epochs_edit, 'edit', focus_map='edit_focus')\n            \n            accuracy_caption = \"Accuracy Goal: N/A (Training for fixed number of epochs)\"\n            accuracy_edit = urwid.Text(accuracy_caption)\n        \n        # Optimizer dropdown\n        optimizer_caption = urwid.Text(('label', \"Optimizer:\"))\n        optimizer_options_list = []\n        for opt in optimizer_options:\n            # Create button and connect signal separately with lambda\n            button = urwid.Button(opt)\n            urwid.connect_signal(button, 'click', \n                                lambda b, opt=opt: self.on_optimizer_selected(b, opt))\n            optimizer_options_list.append(urwid.AttrMap(button, 'button', focus_map='button_focus'))\n        optimizer_dropdown = urwid.GridFlow(optimizer_options_list, 15, 1, 1, 'left')\n        current_optimizer = urwid.Text(('value', f\"Current: {self.settings.get('optimizer', 'eve_unified')}\"))\n        \n        # Input size\n        input_size_caption = urwid.Text(('label', \"Input Resolution:\"))\n        input_size_edit = urwid.IntEdit(default=str(self.settings.get('input_size', 32)))\n        input_size_edit = urwid.AttrMap(input_size_edit, 'edit', focus_map='edit_focus')\n        \n        # Data augmentation checkbox  \n        augmentation_checkbox = urwid.CheckBox(\"Use data augmentation\", \n                                            state=self.settings.get('use_augmentation', True),\n                                            on_state_change=self.on_augmentation_change)\n        augmentation_checkbox = urwid.AttrMap(augmentation_checkbox, 'edit', focus_map='edit_focus')\n        \n        # Advanced settings title\n        advanced_title = urwid.Text(('title', \"\\nAdvanced Settings:\"))\n        \n        # Weight range dropdown\n        weight_range_caption = urwid.Text(('label', \"Weight Range:\"))\n        weight_range_options_list = []\n        for opt in weight_range_options:\n            # Create button and connect signal separately with lambda\n            button = urwid.Button(opt)\n            urwid.connect_signal(button, 'click', \n                                lambda b, opt=opt: self.on_weight_range_selected(b, opt))\n            weight_range_options_list.append(urwid.AttrMap(button, 'button', focus_map='button_focus'))\n        weight_range_dropdown = urwid.GridFlow(weight_range_options_list, 15, 1, 1, 'left')\n        current_weight_range = urwid.Text(('value', f\"Current: {self.settings.get('weight_range', 'default')}\"))\n        \n        # LR sensitivity dropdown\n        lr_caption = urwid.Text(('label', \"LR Sensitivity:\"))\n        lr_options_list = []\n        for opt in lr_sensitivity_options:\n            # Create button and connect signal separately with lambda\n            button = urwid.Button(opt)\n            urwid.connect_signal(button, 'click', \n                                lambda b, opt=opt: self.on_lr_sensitivity_selected(b, opt))\n            lr_options_list.append(urwid.AttrMap(button, 'button', focus_map='button_focus'))\n        lr_dropdown = urwid.GridFlow(lr_options_list, 15, 1, 1, 'left')\n        current_lr = urwid.Text(('value', f\"Current: {self.settings.get('lr_sensitivity', 'high')}\"))\n        \n        # Selected configuration\n        config_title = urwid.Text(('title', \"\\nSelected Configuration:\"))\n        model_text = urwid.Text(f\"Model: {self.settings.get('model_type')}\")\n        dataset_text = urwid.Text(f\"Dataset: {self.settings.get('dataset_type')}\")\n        pretrained_text = urwid.Text(f\"Pre-trained Weights: {self.settings.get('use_pretrained', False)}\")\n        \n        # Navigation buttons\n        confirm_button = self.create_button(\"Confirm Settings\", self.on_settings_confirmed)\n        back_button = self.create_button(\"Back\", self.go_back)\n        quit_button = self.create_button(\"Quit\", self.exit_program)\n        \n        buttons = urwid.GridFlow([confirm_button, back_button, quit_button], 20, 3, 1, 'center')\n        \n        # Create main content\n        content = urwid.Pile([\n            title,\n            urwid.Divider(),\n            mode_title,\n            mode_selection,\n            urwid.Divider(),\n            epochs_caption,\n            epochs_edit,\n            urwid.Divider(),\n            accuracy_caption,\n            accuracy_edit,\n            urwid.Divider(),\n            optimizer_caption,\n            current_optimizer,\n            optimizer_dropdown,\n            urwid.Divider(),\n            input_size_caption,\n            input_size_edit,\n            urwid.Divider(),\n            augmentation_checkbox,\n            advanced_title,\n            weight_range_caption,\n            current_weight_range,\n            weight_range_dropdown,\n            urwid.Divider(),\n            lr_caption,\n            current_lr,\n            lr_dropdown,\n            urwid.Divider(),\n            config_title,\n            model_text,\n            dataset_text,\n            pretrained_text,\n            urwid.Divider(),\n            buttons\n        ])\n        \n        content = urwid.Padding(content, left=2, right=2)\n        \n        # Footer\n        footer = self.create_footer()\n        \n        # Create frame\n        frame = urwid.Frame(\n            urwid.ListBox(urwid.SimpleListWalker([content])),\n            header=header,\n            footer=footer\n        )\n        \n        return frame\n    \n    def on_training_mode_change(self, radio_button, new_state, mode):\n        \"\"\"Handle training mode change\"\"\"\n        if new_state:  # Only process when button becomes active"
        },
        "on_training_mode_change": {
          "start_line": 1650,
          "end_line": 1660,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "radio_button"
            },
            {
              "name": "new_state"
            },
            {
              "name": "mode"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "self.create_training_settings_screen",
              "line": 1655
            }
          ],
          "docstring": "Handle training mode change",
          "code_snippet": "        return frame\n    \n    def on_training_mode_change(self, radio_button, new_state, mode):\n        \"\"\"Handle training mode change\"\"\"\n        if new_state:  # Only process when button becomes active\n            self.settings['training_mode'] = mode\n            # Recreate settings screen to reflect new mode\n            settings_screen = self.create_training_settings_screen()\n            # Replace current screen with updated one\n            self.screen_stack[-1] = settings_screen\n            self.loop.widget = settings_screen\n    \n    def on_optimizer_selected(self, button, optimizer):\n        \"\"\"Handle optimizer selection\"\"\"\n        self.settings['optimizer'] = optimizer"
        },
        "on_optimizer_selected": {
          "start_line": 1660,
          "end_line": 1668,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "button"
            },
            {
              "name": "optimizer"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "self.create_training_settings_screen",
              "line": 1664
            }
          ],
          "docstring": "Handle optimizer selection",
          "code_snippet": "            self.loop.widget = settings_screen\n    \n    def on_optimizer_selected(self, button, optimizer):\n        \"\"\"Handle optimizer selection\"\"\"\n        self.settings['optimizer'] = optimizer\n        # Update the screen to reflect change\n        settings_screen = self.create_training_settings_screen()\n        self.screen_stack[-1] = settings_screen\n        self.loop.widget = settings_screen\n    \n    def on_weight_range_selected(self, button, weight_range):\n        \"\"\"Handle weight range selection\"\"\"\n        self.settings['weight_range'] = weight_range"
        },
        "on_weight_range_selected": {
          "start_line": 1668,
          "end_line": 1676,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "button"
            },
            {
              "name": "weight_range"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "self.create_training_settings_screen",
              "line": 1672
            }
          ],
          "docstring": "Handle weight range selection",
          "code_snippet": "        self.loop.widget = settings_screen\n    \n    def on_weight_range_selected(self, button, weight_range):\n        \"\"\"Handle weight range selection\"\"\"\n        self.settings['weight_range'] = weight_range\n        # Update the screen to reflect change\n        settings_screen = self.create_training_settings_screen()\n        self.screen_stack[-1] = settings_screen\n        self.loop.widget = settings_screen\n    \n    def on_lr_sensitivity_selected(self, button, sensitivity):\n        \"\"\"Handle LR sensitivity selection\"\"\"\n        self.settings['lr_sensitivity'] = sensitivity"
        },
        "on_lr_sensitivity_selected": {
          "start_line": 1676,
          "end_line": 1684,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "button"
            },
            {
              "name": "sensitivity"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "self.create_training_settings_screen",
              "line": 1680
            }
          ],
          "docstring": "Handle LR sensitivity selection",
          "code_snippet": "        self.loop.widget = settings_screen\n    \n    def on_lr_sensitivity_selected(self, button, sensitivity):\n        \"\"\"Handle LR sensitivity selection\"\"\"\n        self.settings['lr_sensitivity'] = sensitivity\n        # Update the screen to reflect change\n        settings_screen = self.create_training_settings_screen()\n        self.screen_stack[-1] = settings_screen\n        self.loop.widget = settings_screen\n    \n    def on_augmentation_change(self, checkbox, new_state):\n        \"\"\"Handle augmentation toggle\"\"\"\n        self.settings['use_augmentation'] = new_state"
        },
        "on_augmentation_change": {
          "start_line": 1684,
          "end_line": 1688,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "checkbox"
            },
            {
              "name": "new_state"
            }
          ],
          "return_type": null,
          "calls": [],
          "docstring": "Handle augmentation toggle",
          "code_snippet": "        self.loop.widget = settings_screen\n    \n    def on_augmentation_change(self, checkbox, new_state):\n        \"\"\"Handle augmentation toggle\"\"\"\n        self.settings['use_augmentation'] = new_state\n    \n    def on_settings_confirmed(self, button):\n        \"\"\"Handle settings confirmation\"\"\"\n        # Extract values from editing widgets"
        },
        "on_settings_confirmed": {
          "start_line": 1688,
          "end_line": 1728,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "button"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "confirm_text.extend",
              "line": 1721
            },
            {
              "name": "self.show_confirmation",
              "line": 1726
            },
            {
              "name": "self.settings.get",
              "line": 1693
            },
            {
              "name": "self.settings.get",
              "line": 1714
            },
            {
              "name": "confirm_text.append",
              "line": 1715
            },
            {
              "name": "confirm_text.append",
              "line": 1716
            },
            {
              "name": "confirm_text.append",
              "line": 1718
            },
            {
              "name": "confirm_text.append",
              "line": 1719
            },
            {
              "name": "self.settings.get",
              "line": 1709
            },
            {
              "name": "self.settings.get",
              "line": 1710
            },
            {
              "name": "....capitalize",
              "line": 1711
            },
            {
              "name": "self.settings.get",
              "line": 1716
            },
            {
              "name": "self.settings.get",
              "line": 1719
            },
            {
              "name": "self.settings.get",
              "line": 1722
            },
            {
              "name": "self.settings.get",
              "line": 1711
            }
          ],
          "docstring": "Handle settings confirmation",
          "code_snippet": "        self.settings['use_augmentation'] = new_state\n    \n    def on_settings_confirmed(self, button):\n        \"\"\"Handle settings confirmation\"\"\"\n        # Extract values from editing widgets\n        \n        # Training mode specific settings\n        if self.settings.get('training_mode') == 'accuracy':\n            # Get accuracy goal from the widget\n            # Would need to implement this properly in full version\n            self.settings['accuracy_goal'] = 90.0\n        else:\n            # Get epochs from the widget\n            # Would need to implement this properly in full version\n            self.settings['epochs'] = 15\n        \n        # Get input size from widget\n        # Would need to implement this properly in full version\n        self.settings['input_size'] = 32\n        \n        # Show confirmation dialog\n        confirm_text = [\n            \"Ready to start training with the following settings:\\n\\n\",\n            ('label', \"Model: \"), ('value', f\"{self.settings.get('model_type')}\\n\"),\n            ('label', \"Dataset: \"), ('value', f\"{self.settings.get('dataset_type')}\\n\"),\n            ('label', \"Training Mode: \"), ('value', f\"{self.settings.get('training_mode').capitalize()}\\n\"),\n        ]\n        \n        if self.settings.get('training_mode') == 'accuracy':\n            confirm_text.append(('label', \"Accuracy Goal: \"))\n            confirm_text.append(('value', f\"{self.settings.get('accuracy_goal')}%\\n\"))\n        else:\n            confirm_text.append(('label', \"Epochs: \"))\n            confirm_text.append(('value', f\"{self.settings.get('epochs')}\\n\"))\n        \n        confirm_text.extend([\n            ('label', \"Optimizer: \"), ('value', f\"{self.settings.get('optimizer')}\\n\"),\n            \"\\nStart training now?\"\n        ])\n        \n        self.show_confirmation(\"Confirm Training\", confirm_text, self.start_training)\n    \n    def start_training(self, confirmed):\n        \"\"\"Start the training process if confirmed\"\"\"\n        if confirmed:"
        },
        "start_training": {
          "start_line": 1728,
          "end_line": 1736,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "confirmed"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "time.time",
              "line": 1732
            },
            {
              "name": "self.create_training_progress_screen",
              "line": 1733
            },
            {
              "name": "self.push_screen",
              "line": 1734
            }
          ],
          "docstring": "Start the training process if confirmed",
          "code_snippet": "        self.show_confirmation(\"Confirm Training\", confirm_text, self.start_training)\n    \n    def start_training(self, confirmed):\n        \"\"\"Start the training process if confirmed\"\"\"\n        if confirmed:\n            # In a full implementation, this would start the actual training\n            self.training_start_time = time.time()\n            training_screen = self.create_training_progress_screen()\n            self.push_screen(training_screen)\n        \n    def create_training_progress_screen(self):\n        \"\"\"Create the training progress screen (placeholder)\"\"\"\n        # Header"
        },
        "create_training_progress_screen": {
          "start_line": 1736,
          "end_line": 1787,
          "parameters": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "self.create_header",
              "line": 1739
            },
            {
              "name": "urwid.Text",
              "line": 1742
            },
            {
              "name": "urwid.Text",
              "line": 1745
            },
            {
              "name": "urwid.Text",
              "line": 1746
            },
            {
              "name": "urwid.ProgressBar",
              "line": 1749
            },
            {
              "name": "urwid.Text",
              "line": 1752
            },
            {
              "name": "self.create_button",
              "line": 1755
            },
            {
              "name": "urwid.Pile",
              "line": 1758
            },
            {
              "name": "urwid.Padding",
              "line": 1773
            },
            {
              "name": "urwid.AttrMap",
              "line": 1776
            },
            {
              "name": "urwid.Frame",
              "line": 1779
            },
            {
              "name": "urwid.Text",
              "line": 1776
            },
            {
              "name": "urwid.Filler",
              "line": 1780
            },
            {
              "name": "urwid.Divider",
              "line": 1760
            },
            {
              "name": "urwid.Divider",
              "line": 1763
            },
            {
              "name": "urwid.Text",
              "line": 1764
            },
            {
              "name": "urwid.Divider",
              "line": 1766
            },
            {
              "name": "urwid.Text",
              "line": 1767
            },
            {
              "name": "urwid.Divider",
              "line": 1769
            },
            {
              "name": "urwid.Padding",
              "line": 1770
            },
            {
              "name": "self.settings.get",
              "line": 1745
            },
            {
              "name": "self.settings.get",
              "line": 1746
            }
          ],
          "docstring": "Create the training progress screen (placeholder)",
          "code_snippet": "            self.push_screen(training_screen)\n        \n    def create_training_progress_screen(self):\n        \"\"\"Create the training progress screen (placeholder)\"\"\"\n        # Header\n        header = self.create_header(\"Training Progress\")\n        \n        # Content\n        title = urwid.Text(('title', \"Training in Progress:\"))\n        \n        # Info\n        model_text = urwid.Text(f\"Model: {self.settings.get('model_type')}\")\n        dataset_text = urwid.Text(f\"Dataset: {self.settings.get('dataset_type')}\")\n        \n        # Progress bar placeholder\n        progress_bar = urwid.ProgressBar('linebox', 'highlight', 0, 100)\n        \n        # Metrics placeholder\n        metrics_text = urwid.Text(\"Waiting for metrics...\")\n        \n        # Buttons\n        stop_button = self.create_button(\"Stop Training\", self.stop_training)\n        \n        # Create main content\n        content = urwid.Pile([\n            title,\n            urwid.Divider(),\n            model_text,\n            dataset_text,\n            urwid.Divider(),\n            urwid.Text(\"Progress:\"),\n            progress_bar,\n            urwid.Divider(),\n            urwid.Text(\"Metrics:\"),\n            metrics_text,\n            urwid.Divider(),\n            urwid.Padding(stop_button, width=20, align='center')\n        ])\n        \n        content = urwid.Padding(content, left=2, right=2)\n        \n        # Footer\n        footer = urwid.AttrMap(urwid.Text(\"Press Q to quit\", align='center'), 'footer')\n        \n        # Create frame\n        frame = urwid.Frame(\n            urwid.Filler(content, valign='top', top=1, bottom=1),\n            header=header,\n            footer=footer\n        )\n        \n        return frame\n    \n    def stop_training(self, button):\n        \"\"\"Stop the training process\"\"\"\n        self.show_dialog(\"Training Stopped\", \"Training has been stopped. Results will not be saved.\")"
        },
        "stop_training": {
          "start_line": 1787,
          "end_line": 1794,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "button"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "self.show_dialog",
              "line": 1789
            },
            {
              "name": "self.create_welcome_screen",
              "line": 1791
            }
          ],
          "docstring": "Stop the training process",
          "code_snippet": "        return frame\n    \n    def stop_training(self, button):\n        \"\"\"Stop the training process\"\"\"\n        self.show_dialog(\"Training Stopped\", \"Training has been stopped. Results will not be saved.\")\n        # Return to welcome screen\n        self.screen_stack = [self.create_welcome_screen()]\n        self.loop.widget = self.screen_stack[0]\n    \n    def show_dialog(self, title, message, buttons=None):\n        \"\"\"Show a dialog box with a message\"\"\"\n        if buttons is None:"
        },
        "show_dialog": {
          "start_line": 1794,
          "end_line": 1831,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "title"
            },
            {
              "name": "message"
            },
            {
              "name": "buttons"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "urwid.Pile",
              "line": 1802
            },
            {
              "name": "urwid.LineBox",
              "line": 1809
            },
            {
              "name": "urwid.AttrMap",
              "line": 1813
            },
            {
              "name": "urwid.Overlay",
              "line": 1816
            },
            {
              "name": "self.create_button",
              "line": 1798
            },
            {
              "name": "urwid.Padding",
              "line": 1799
            },
            {
              "name": "urwid.Padding",
              "line": 1810
            },
            {
              "name": "urwid.Text",
              "line": 1803
            },
            {
              "name": "urwid.Divider",
              "line": 1804
            }
          ],
          "docstring": "Show a dialog box with a message",
          "code_snippet": "        self.loop.widget = self.screen_stack[0]\n    \n    def show_dialog(self, title, message, buttons=None):\n        \"\"\"Show a dialog box with a message\"\"\"\n        if buttons is None:\n            # Default OK button\n            ok_button = self.create_button(\"OK\", self.close_dialog)\n            buttons = urwid.Padding(ok_button, align='center', width=10)\n        \n        # Create dialog content\n        content = urwid.Pile([\n            urwid.Text(message),\n            urwid.Divider(),\n            buttons\n        ])\n        \n        # Create dialog box\n        dialog = urwid.LineBox(\n            urwid.Padding(content, left=1, right=1, min_width=40),\n            title=title\n        )\n        dialog = urwid.AttrMap(dialog, 'dialog')\n        \n        # Center the dialog on screen\n        dialog = urwid.Overlay(\n            dialog,\n            self.loop.widget,\n            align='center',\n            valign='middle',\n            width=('relative', 50),\n            height=('relative', 25)\n        )\n        \n        # Store the original widget to restore later\n        self._original_widget = self.loop.widget\n        \n        # Show the dialog\n        self.loop.widget = dialog\n    \n    def close_dialog(self, button):\n        \"\"\"Close the dialog and restore original screen\"\"\"\n        self.loop.widget = self._original_widget"
        },
        "close_dialog": {
          "start_line": 1831,
          "end_line": 1835,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "button"
            }
          ],
          "return_type": null,
          "calls": [],
          "docstring": "Close the dialog and restore original screen",
          "code_snippet": "        self.loop.widget = dialog\n    \n    def close_dialog(self, button):\n        \"\"\"Close the dialog and restore original screen\"\"\"\n        self.loop.widget = self._original_widget\n    \n    def show_confirmation(self, title, message, callback):\n        \"\"\"Show a confirmation dialog with Yes/No buttons\"\"\"\n        # Lambda functions don't have the same issue"
        },
        "show_confirmation": {
          "start_line": 1835,
          "end_line": 1873,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "title"
            },
            {
              "name": "message"
            },
            {
              "name": "callback"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "self.create_button",
              "line": 1838
            },
            {
              "name": "self.create_button",
              "line": 1839
            },
            {
              "name": "urwid.GridFlow",
              "line": 1841
            },
            {
              "name": "urwid.Pile",
              "line": 1844
            },
            {
              "name": "urwid.LineBox",
              "line": 1851
            },
            {
              "name": "urwid.AttrMap",
              "line": 1855
            },
            {
              "name": "urwid.Overlay",
              "line": 1858
            },
            {
              "name": "urwid.Padding",
              "line": 1852
            },
            {
              "name": "self.confirm_dialog",
              "line": 1838
            },
            {
              "name": "self.confirm_dialog",
              "line": 1839
            },
            {
              "name": "urwid.Text",
              "line": 1845
            },
            {
              "name": "urwid.Divider",
              "line": 1846
            }
          ],
          "docstring": "Show a confirmation dialog with Yes/No buttons",
          "code_snippet": "        self.loop.widget = self._original_widget\n    \n    def show_confirmation(self, title, message, callback):\n        \"\"\"Show a confirmation dialog with Yes/No buttons\"\"\"\n        # Lambda functions don't have the same issue\n        yes_button = self.create_button(\"Yes\", lambda _: self.confirm_dialog(True, callback))\n        no_button = self.create_button(\"No\", lambda _: self.confirm_dialog(False, callback))\n        \n        buttons = urwid.GridFlow([yes_button, no_button], 10, 3, 1, 'center')\n        \n        # Create dialog content\n        content = urwid.Pile([\n            urwid.Text(message),\n            urwid.Divider(),\n            buttons\n        ])\n        \n        # Create dialog box\n        dialog = urwid.LineBox(\n            urwid.Padding(content, left=1, right=1, min_width=50),\n            title=title\n        )\n        dialog = urwid.AttrMap(dialog, 'dialog')\n        \n        # Center the dialog on screen\n        dialog = urwid.Overlay(\n            dialog,\n            self.loop.widget,\n            align='center',\n            valign='middle',\n            width=('relative', 60),\n            height=('relative', 40)\n        )\n        \n        # Store the original widget to restore later\n        self._original_widget = self.loop.widget\n        \n        # Show the dialog\n        self.loop.widget = dialog\n    \n    def confirm_dialog(self, confirmed, callback):\n        \"\"\"Handle confirmation dialog response\"\"\"\n        self.loop.widget = self._original_widget"
        },
        "confirm_dialog": {
          "start_line": 1873,
          "end_line": 1878,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "confirmed"
            },
            {
              "name": "callback"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "callback",
              "line": 1876
            }
          ],
          "docstring": "Handle confirmation dialog response",
          "code_snippet": "        self.loop.widget = dialog\n    \n    def confirm_dialog(self, confirmed, callback):\n        \"\"\"Handle confirmation dialog response\"\"\"\n        self.loop.widget = self._original_widget\n        callback(confirmed)\n    \n    def run(self):\n        \"\"\"Run the UI\"\"\"\n        # Create the welcome screen"
        },
        "run": {
          "start_line": 1878,
          "end_line": 1898,
          "parameters": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "self.create_welcome_screen",
              "line": 1881
            },
            {
              "name": "urwid.MainLoop",
              "line": 1887
            },
            {
              "name": "self.loop.run",
              "line": 1893
            }
          ],
          "docstring": "Run the UI",
          "code_snippet": "        callback(confirmed)\n    \n    def run(self):\n        \"\"\"Run the UI\"\"\"\n        # Create the welcome screen\n        welcome_screen = self.create_welcome_screen()\n        \n        # Initialize screen stack\n        self.screen_stack = [welcome_screen]\n        \n        # Start the main loop\n        self.loop = urwid.MainLoop(\n            welcome_screen,\n            palette=self.PALETTE,\n            unhandled_input=self.handle_input\n        )\n        \n        self.loop.run()\n        \n        # Return the settings for use by the caller\n        return self.settings\n    \n    def handle_input(self, key):\n        \"\"\"Handle keyboard input\"\"\"\n        if key in ('q', 'Q'):"
        },
        "handle_input": {
          "start_line": 1898,
          "end_line": 1905,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "key"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "urwid.ExitMainLoop",
              "line": 1901
            },
            {
              "name": "self.go_back",
              "line": 1903
            }
          ],
          "docstring": "Handle keyboard input",
          "code_snippet": "        return self.settings\n    \n    def handle_input(self, key):\n        \"\"\"Handle keyboard input\"\"\"\n        if key in ('q', 'Q'):\n            raise urwid.ExitMainLoop()\n        elif key in ('b', 'B'):\n            self.go_back()\n\n\nif __name__ == \"__main__\":\n    args = parse_args()"
        }
      },
      "class_variables": [
        {
          "name": "PALETTE",
          "line": 1044
        }
      ],
      "bases": [],
      "docstring": "Terminal User Interface for the IsekaiZen ML Optimization Framework using urwid"
    }
  },
  "functions": {
    "parse_args": {
      "start_line": 1028,
      "end_line": 1038,
      "parameters": [],
      "return_type": null,
      "calls": [
        {
          "name": "argparse.ArgumentParser",
          "line": 1030
        },
        {
          "name": "parser.add_argument",
          "line": 1031
        },
        {
          "name": "parser.add_argument",
          "line": 1032
        },
        {
          "name": "parser.add_argument",
          "line": 1033
        },
        {
          "name": "parser.add_argument",
          "line": 1034
        },
        {
          "name": "parser.add_argument",
          "line": 1035
        },
        {
          "name": "parser.parse_args",
          "line": 1036
        }
      ],
      "docstring": "Parse command line arguments",
      "code_snippet": "\n\ndef parse_args():\n    \"\"\"Parse command line arguments\"\"\"\n    parser = argparse.ArgumentParser(description=\"IsekaiZen ML Optimizer Terminal UI\")\n    parser.add_argument(\"--no-ui\", action=\"store_true\", help=\"Run without interactive UI (use default settings)\")\n    parser.add_argument(\"--model\", type=str, default=\"resnet18\", help=\"Model architecture\")\n    parser.add_argument(\"--dataset\", type=str, default=\"cifar10\", help=\"Dataset name\")\n    parser.add_argument(\"--epochs\", type=int, default=15, help=\"Number of training epochs\")\n    parser.add_argument(\"--basic-ui\", action=\"store_true\", help=\"Use basic UI instead of advanced urwid UI\")\n    return parser.parse_args()\n\n\n# UrwidTerminalUI - A more sophisticated terminal UI using the urwid library\nclass UrwidTerminalUI:"
    }
  },
  "constants": {
    "MODEL_TYPES": {
      "line": 31
    },
    "DATASET_TYPES": {
      "line": 44
    }
  }
}