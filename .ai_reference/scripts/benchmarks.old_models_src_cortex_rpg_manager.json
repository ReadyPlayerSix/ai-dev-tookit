{
  "path": "D:\\Projects\\isekaiZen\\machine-learning-optimizer\\benchmarks.old\\models\\src\\cortex\\rpg_manager.py",
  "imports": [
    {
      "name": "dataclasses.dataclass",
      "line": 4
    },
    {
      "name": "typing.Dict",
      "line": 5
    },
    {
      "name": "typing.List",
      "line": 5
    },
    {
      "name": "typing.Optional",
      "line": 5
    },
    {
      "name": "typing.Set",
      "line": 5
    },
    {
      "name": "typing.Any",
      "line": 5
    },
    {
      "name": "enum.Enum",
      "line": 6
    },
    {
      "name": "torch",
      "line": 7
    },
    {
      "name": "numpy",
      "line": 8
    },
    {
      "name": "math",
      "line": 9
    }
  ],
  "classes": {
    "PatternType": {
      "start_line": 11,
      "end_line": 15,
      "methods": {},
      "class_variables": [
        {
          "name": "OPPORTUNITY",
          "line": 12
        },
        {
          "name": "RISK",
          "line": 13
        }
      ],
      "bases": [
        "Enum"
      ]
    },
    "SkillTree": {
      "start_line": 15,
      "end_line": 21,
      "methods": {},
      "class_variables": [
        {
          "name": "PATTERN_RECOGNITION",
          "line": 16
        },
        {
          "name": "RISK_ASSESSMENT",
          "line": 17
        },
        {
          "name": "INTUITION",
          "line": 18
        },
        {
          "name": "PATTERN_MEMORY",
          "line": 19
        }
      ],
      "bases": [
        "Enum"
      ]
    },
    "Pattern": {
      "start_line": 22,
      "end_line": 31,
      "methods": {},
      "class_variables": [],
      "bases": []
    },
    "RPGCortexManager": {
      "start_line": 31,
      "end_line": 171,
      "methods": {
        "__init__": {
          "start_line": 32,
          "end_line": 69,
          "parameters": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "torch.device",
              "line": 33
            },
            {
              "name": "math.floor",
              "line": 67
            },
            {
              "name": "torch.cuda.is_available",
              "line": 33
            },
            {
              "name": "range",
              "line": 67
            }
          ],
          "code_snippet": "\nclass RPGCortexManager:\n    def __init__(self):\n        self.device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')\n        \n        # Core RPG stats\n        self.level = 1\n        self.xp = 0\n        self.total_xp = 0\n        \n        # Skill levels and unlocks\n        self.skills = {\n            SkillTree.PATTERN_RECOGNITION: 1,\n            SkillTree.RISK_ASSESSMENT: 1,\n            SkillTree.INTUITION: 1,\n            SkillTree.PATTERN_MEMORY: 1\n        }\n        \n        # Level-based capabilities\n        self.pattern_complexity_limit = 1.0\n        self.pattern_memory_size = 50\n        self.pattern_recognition_bonus = 0.0\n        \n        # Pattern storage\n        self.active_patterns: List[Pattern] = []\n        self.pattern_purgatory: List[Pattern] = []\n        \n        # Performance metrics\n        self.metrics = {\n            \"patterns_processed\": 0,\n            \"successful_predictions\": 0,\n            \"complexity_handled\": 0,\n            \"skill_checks_passed\": 0\n        }\n        \n        # Level thresholds\n        self.level_thresholds = [\n            math.floor(1000 * (1.2 ** i)) for i in range(50)\n        ]\n    \n    def _calculate_xp_reward(self, pattern: Pattern, success: bool) -> float:\n        base_xp = pattern.xp_value * pattern.complexity"
        },
        "_calculate_xp_reward": {
          "start_line": 70,
          "end_line": 76,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "pattern",
              "type": "Pattern"
            },
            {
              "name": "success",
              "type": "bool"
            }
          ],
          "return_type": "float",
          "calls": [
            {
              "name": "max",
              "line": 72
            }
          ],
          "code_snippet": "        ]\n    \n    def _calculate_xp_reward(self, pattern: Pattern, success: bool) -> float:\n        base_xp = pattern.xp_value * pattern.complexity\n        level_modifier = max(0.1, 1.0 - (self.level / pattern.power_level))\n        success_multiplier = 1.5 if success else 0.5\n        return base_xp * level_modifier * success_multiplier\n    \n    def _check_level_up(self):\n        while self.level < len(self.level_thresholds) and self.total_xp >= self.level_thresholds[self.level - 1]:\n            self.level += 1"
        },
        "_check_level_up": {
          "start_line": 76,
          "end_line": 87,
          "parameters": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "print",
              "line": 79
            },
            {
              "name": "len",
              "line": 77
            },
            {
              "name": "self._improve_random_skill",
              "line": 85
            }
          ],
          "code_snippet": "        return base_xp * level_modifier * success_multiplier\n    \n    def _check_level_up(self):\n        while self.level < len(self.level_thresholds) and self.total_xp >= self.level_thresholds[self.level - 1]:\n            self.level += 1\n            print(f\"\\nLEVEL UP! Now level {self.level}\")\n            \n            self.pattern_complexity_limit *= 1.2\n            self.pattern_recognition_bonus += 0.05\n            \n            if self.level % 2 == 0:\n                self._improve_random_skill()\n    \n    def _improve_random_skill(self):\n        skill = np.random.choice(list(SkillTree))\n        self.skills[skill] += 1"
        },
        "_improve_random_skill": {
          "start_line": 87,
          "end_line": 95,
          "parameters": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "np.random.choice",
              "line": 88
            },
            {
              "name": "print",
              "line": 90
            },
            {
              "name": "list",
              "line": 88
            }
          ],
          "code_snippet": "                self._improve_random_skill()\n    \n    def _improve_random_skill(self):\n        skill = np.random.choice(list(SkillTree))\n        self.skills[skill] += 1\n        print(f\"Skill increased: {skill.value} is now level {self.skills[skill]}\")\n        \n        if skill == SkillTree.PATTERN_MEMORY:\n            self.pattern_memory_size += 25\n    \n    def _skill_check(self, difficulty: float, skill_type: SkillTree) -> bool:\n        skill_level = self.skills[skill_type]\n        roll = np.random.random()"
        },
        "_skill_check": {
          "start_line": 95,
          "end_line": 106,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "difficulty",
              "type": "float"
            },
            {
              "name": "skill_type",
              "type": "SkillTree"
            }
          ],
          "return_type": "bool",
          "calls": [
            {
              "name": "np.random.random",
              "line": 97
            }
          ],
          "code_snippet": "            self.pattern_memory_size += 25\n    \n    def _skill_check(self, difficulty: float, skill_type: SkillTree) -> bool:\n        skill_level = self.skills[skill_type]\n        roll = np.random.random()\n        base_chance = 0.5 + (skill_level * 0.1)\n        success = roll < (base_chance - (difficulty * 0.2))\n        \n        if success:\n            self.metrics[\"skill_checks_passed\"] += 1\n        \n        return success\n    \n    def process_pattern(self, pattern: Pattern) -> Dict[str, Any]:\n        # Calculate base XP even for failures\n        xp_gained = self._calculate_xp_reward(pattern, False)"
        },
        "process_pattern": {
          "start_line": 106,
          "end_line": 171,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "pattern",
              "type": "Pattern"
            }
          ],
          "return_type": "complex_type",
          "calls": [
            {
              "name": "self._calculate_xp_reward",
              "line": 108
            },
            {
              "name": "self._skill_check",
              "line": 123
            },
            {
              "name": "self._skill_check",
              "line": 144
            },
            {
              "name": "self._calculate_xp_reward",
              "line": 150
            },
            {
              "name": "self._check_level_up",
              "line": 161
            }
          ],
          "code_snippet": "        return success\n    \n    def process_pattern(self, pattern: Pattern) -> Dict[str, Any]:\n        # Calculate base XP even for failures\n        xp_gained = self._calculate_xp_reward(pattern, False)\n        \n        # Check pattern complexity\n        if pattern.complexity > self.pattern_complexity_limit:\n            return {\n                \"success\": False,\n                \"reason\": \"Pattern too complex for current level\",\n                \"complexity_gap\": pattern.complexity - self.pattern_complexity_limit,\n                \"xp_gained\": xp_gained,\n                \"current_level\": self.level,\n                \"current_xp\": self.xp,\n                \"next_level_xp\": self.level_thresholds[self.level - 1]\n            }\n        \n        # Pattern recognition check\n        recognition_success = self._skill_check(\n            pattern.complexity,\n            SkillTree.PATTERN_RECOGNITION\n        )\n        \n        if not recognition_success:\n            self.xp += xp_gained\n            self.total_xp += xp_gained\n            return {\n                \"success\": False,\n                \"reason\": \"Failed to recognize pattern\",\n                \"xp_gained\": xp_gained,\n                \"current_level\": self.level,\n                \"current_xp\": self.xp,\n                \"next_level_xp\": self.level_thresholds[self.level - 1]\n            }\n        \n        # Specific skill check\n        skill_type = (SkillTree.INTUITION if pattern.pattern_type == PatternType.OPPORTUNITY \n                     else SkillTree.RISK_ASSESSMENT)\n        \n        processing_success = self._skill_check(\n            pattern.complexity,\n            skill_type\n        )\n        \n        # Calculate final XP\n        xp_gained = self._calculate_xp_reward(pattern, processing_success)\n        self.xp += xp_gained\n        self.total_xp += xp_gained\n        \n        # Update metrics\n        self.metrics[\"patterns_processed\"] += 1\n        if processing_success:\n            self.metrics[\"successful_predictions\"] += 1\n            self.metrics[\"complexity_handled\"] += pattern.complexity\n        \n        # Check for level up\n        self._check_level_up()\n        \n        return {\n            \"success\": processing_success,\n            \"xp_gained\": xp_gained,\n            \"current_level\": self.level,\n            \"current_xp\": self.xp,\n            \"next_level_xp\": self.level_thresholds[self.level - 1],\n            \"metrics\": self.metrics\n        }"
        }
      },
      "class_variables": [],
      "bases": []
    }
  },
  "functions": {},
  "constants": {}
}