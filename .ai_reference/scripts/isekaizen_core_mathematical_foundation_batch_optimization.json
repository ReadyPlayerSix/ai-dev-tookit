{
  "path": "D:\\Projects\\isekaiZen\\machine-learning-optimizer\\isekaizen\\core\\mathematical_foundation\\batch_optimization.py",
  "imports": [
    {
      "name": "math",
      "line": 11
    },
    {
      "name": "cognitive_efficiency.calculate_cognitive_efficiency",
      "line": 12
    }
  ],
  "classes": {},
  "functions": {
    "calculate_optimal_batch_size": {
      "start_line": 14,
      "end_line": 62,
      "parameters": [
        {
          "name": "base_size"
        },
        {
          "name": "resource_share"
        },
        {
          "name": "polling_frequency"
        },
        {
          "name": "available_energy"
        },
        {
          "name": "cognitive_load"
        },
        {
          "name": "parallel_processors"
        }
      ],
      "return_type": null,
      "calls": [
        {
          "name": "math.sqrt",
          "line": 45
        },
        {
          "name": "max",
          "line": 60
        },
        {
          "name": "ValueError",
          "line": 38
        },
        {
          "name": "ValueError",
          "line": 40
        },
        {
          "name": "ValueError",
          "line": 42
        },
        {
          "name": "calculate_cognitive_efficiency",
          "line": 49
        },
        {
          "name": "round",
          "line": 60
        }
      ],
      "docstring": "\n    Calculate the optimal batch size for operations.\n    \n    Implements the formula from Section 6 of the Mathematical Foundation:\n    batch_size_i = base_size * sqrt(resource_share_i / polling_frequency_i) * efficiency_factor\n    \n    Args:\n        base_size (int): System-wide base batch size\n        resource_share (float): Resource allocation for the component\n        polling_frequency (float): Polling frequency for the component\n        available_energy (float, optional): Available energy for computation\n        cognitive_load (float, optional): Current cognitive load\n        parallel_processors (int, optional): Number of parallel processors. Defaults to 1.\n        \n    Returns:\n        int: Optimal batch size for operations\n        \n    Raises:\n        ValueError: If base_size, resource_share, or polling_frequency are not positive\n    ",
      "code_snippet": "from .cognitive_efficiency import calculate_cognitive_efficiency\n\ndef calculate_optimal_batch_size(base_size, resource_share, polling_frequency, \n                               available_energy=None, cognitive_load=None, parallel_processors=1):\n    \"\"\"\n    Calculate the optimal batch size for operations.\n    \n    Implements the formula from Section 6 of the Mathematical Foundation:\n    batch_size_i = base_size * sqrt(resource_share_i / polling_frequency_i) * efficiency_factor\n    \n    Args:\n        base_size (int): System-wide base batch size\n        resource_share (float): Resource allocation for the component\n        polling_frequency (float): Polling frequency for the component\n        available_energy (float, optional): Available energy for computation\n        cognitive_load (float, optional): Current cognitive load\n        parallel_processors (int, optional): Number of parallel processors. Defaults to 1.\n        \n    Returns:\n        int: Optimal batch size for operations\n        \n    Raises:\n        ValueError: If base_size, resource_share, or polling_frequency are not positive\n    \"\"\"\n    # Input validation\n    if base_size <= 0:\n        raise ValueError(\"Base size must be positive\")\n    if resource_share <= 0:\n        raise ValueError(\"Resource share must be positive\")\n    if polling_frequency <= 0:\n        raise ValueError(\"Polling frequency must be positive\")\n    \n    # Calculate batch scaling based on resource share and polling frequency\n    batch_scaling = math.sqrt(resource_share / polling_frequency)\n    \n    # Apply efficiency factor if energy and load information is available\n    if available_energy is not None and cognitive_load is not None:\n        efficiency_factor = calculate_cognitive_efficiency(\n            available_energy, cognitive_load, parallel_processors\n        )\n    else:\n        # Default efficiency factor if energy and load information not available\n        efficiency_factor = 0.9\n    \n    # Calculate optimal batch size\n    optimal_size = base_size * batch_scaling * efficiency_factor\n    \n    # Round to nearest integer and ensure it's at least 1\n    return max(1, round(optimal_size))\n\ndef calculate_batch_priority(type_priority, resource_impact, urgency):\n    \"\"\"\n    Calculate the priority for batch operations."
    },
    "calculate_batch_priority": {
      "start_line": 62,
      "end_line": 94,
      "parameters": [
        {
          "name": "type_priority"
        },
        {
          "name": "resource_impact"
        },
        {
          "name": "urgency"
        }
      ],
      "return_type": null,
      "calls": [
        {
          "name": "max",
          "line": 92
        },
        {
          "name": "ValueError",
          "line": 82
        },
        {
          "name": "ValueError",
          "line": 84
        },
        {
          "name": "ValueError",
          "line": 86
        },
        {
          "name": "min",
          "line": 92
        }
      ],
      "docstring": "\n    Calculate the priority for batch operations.\n    \n    Implements the formula from Section 2 of the Mathematical Foundation:\n    priority(batch) = type_priority * (1.0 - resource_impact*0.5) * (1.0 + urgency*0.5)\n    \n    Args:\n        type_priority (float): Base priority for the batch type\n        resource_impact (float): Impact on system resources (0.0-1.0)\n        urgency (float): Time sensitivity (0.0-1.0)\n        \n    Returns:\n        float: Priority value for the batch\n        \n    Raises:\n        ValueError: If input parameters are outside valid ranges\n    ",
      "code_snippet": "    return max(1, round(optimal_size))\n\ndef calculate_batch_priority(type_priority, resource_impact, urgency):\n    \"\"\"\n    Calculate the priority for batch operations.\n    \n    Implements the formula from Section 2 of the Mathematical Foundation:\n    priority(batch) = type_priority * (1.0 - resource_impact*0.5) * (1.0 + urgency*0.5)\n    \n    Args:\n        type_priority (float): Base priority for the batch type\n        resource_impact (float): Impact on system resources (0.0-1.0)\n        urgency (float): Time sensitivity (0.0-1.0)\n        \n    Returns:\n        float: Priority value for the batch\n        \n    Raises:\n        ValueError: If input parameters are outside valid ranges\n    \"\"\"\n    # Input validation\n    if type_priority < 0 or type_priority > 1:\n        raise ValueError(\"Type priority must be in range [0, 1]\")\n    if resource_impact < 0 or resource_impact > 1:\n        raise ValueError(\"Resource impact must be in range [0, 1]\")\n    if urgency < 0 or urgency > 1:\n        raise ValueError(\"Urgency must be in range [0, 1]\")\n    \n    # Calculate batch priority\n    priority = type_priority * (1.0 - resource_impact * 0.5) * (1.0 + urgency * 0.5)\n    \n    # Ensure result is in valid range [0, 1]\n    return max(0.0, min(1.0, priority))\n\ndef get_type_priority(batch_type):\n    \"\"\"\n    Get the base priority for a batch type."
    },
    "get_type_priority": {
      "start_line": 94,
      "end_line": 122,
      "parameters": [
        {
          "name": "batch_type"
        }
      ],
      "return_type": null,
      "calls": [
        {
          "name": "ValueError",
          "line": 118
        },
        {
          "name": "list",
          "line": 118
        },
        {
          "name": "priority_map.keys",
          "line": 118
        }
      ],
      "docstring": "\n    Get the base priority for a batch type.\n    \n    Implements the values from Section 2.1 of the Mathematical Foundation.\n    \n    Args:\n        batch_type (str): Type of batch ('metrics', 'optimization', 'action', 'notification')\n        \n    Returns:\n        float: Base priority for the batch type\n        \n    Raises:\n        ValueError: If batch_type is not recognized\n    ",
      "code_snippet": "    return max(0.0, min(1.0, priority))\n\ndef get_type_priority(batch_type):\n    \"\"\"\n    Get the base priority for a batch type.\n    \n    Implements the values from Section 2.1 of the Mathematical Foundation.\n    \n    Args:\n        batch_type (str): Type of batch ('metrics', 'optimization', 'action', 'notification')\n        \n    Returns:\n        float: Base priority for the batch type\n        \n    Raises:\n        ValueError: If batch_type is not recognized\n    \"\"\"\n    # Priority values from the Mathematical Foundation\n    priority_map = {\n        'metrics': 0.7,\n        'optimization': 0.8,\n        'action': 0.9,\n        'notification': 0.6\n    }\n    \n    if batch_type not in priority_map:\n        raise ValueError(f\"Batch type {batch_type} not recognized. Valid types: {list(priority_map.keys())}\")\n    \n    return priority_map[batch_type]\n\ndef calculate_resource_impact(operation_complexities, operation_weights=None):\n    \"\"\"\n    Calculate the resource impact based on computational complexity of operations."
    },
    "calculate_resource_impact": {
      "start_line": 122,
      "end_line": 162,
      "parameters": [
        {
          "name": "operation_complexities"
        },
        {
          "name": "operation_weights"
        }
      ],
      "return_type": null,
      "calls": [
        {
          "name": "len",
          "line": 141
        },
        {
          "name": "sum",
          "line": 150
        },
        {
          "name": "sum",
          "line": 157
        },
        {
          "name": "max",
          "line": 160
        },
        {
          "name": "min",
          "line": 160
        },
        {
          "name": "len",
          "line": 146
        },
        {
          "name": "ValueError",
          "line": 147
        },
        {
          "name": "zip",
          "line": 157
        }
      ],
      "docstring": "\n    Calculate the resource impact based on computational complexity of operations.\n    \n    Implements the formula from Section 2.2 of the Mathematical Foundation:\n    resource_impact = sum(operation_complexity_i * operation_weight_i) / n\n    \n    Args:\n        operation_complexities (list): Relative complexity of operations\n        operation_weights (list, optional): Importance weights of operations.\n                                          If None, all operations have equal weight.\n        \n    Returns:\n        float: Resource impact value (0.0-1.0)\n    ",
      "code_snippet": "    return priority_map[batch_type]\n\ndef calculate_resource_impact(operation_complexities, operation_weights=None):\n    \"\"\"\n    Calculate the resource impact based on computational complexity of operations.\n    \n    Implements the formula from Section 2.2 of the Mathematical Foundation:\n    resource_impact = sum(operation_complexity_i * operation_weight_i) / n\n    \n    Args:\n        operation_complexities (list): Relative complexity of operations\n        operation_weights (list, optional): Importance weights of operations.\n                                          If None, all operations have equal weight.\n        \n    Returns:\n        float: Resource impact value (0.0-1.0)\n    \"\"\"\n    # Input validation\n    if not operation_complexities:\n        return 0.0\n    \n    n = len(operation_complexities)\n    \n    # Set default weights if not provided\n    if operation_weights is None:\n        operation_weights = [1.0 / n] * n\n    elif len(operation_weights) != n:\n        raise ValueError(\"Operation weights must have the same length as operation complexities\")\n    \n    # Normalize weights to sum to 1.0\n    weight_sum = sum(operation_weights)\n    if weight_sum > 0:\n        normalized_weights = [w / weight_sum for w in operation_weights]\n    else:\n        normalized_weights = [1.0 / n] * n\n    \n    # Calculate weighted average of operation complexities\n    impact = sum(c * w for c, w in zip(operation_complexities, normalized_weights))\n    \n    # Ensure result is in valid range [0, 1]\n    return max(0.0, min(1.0, impact))\n\ndef calculate_urgency(time_since_last_execution, optimal_execution_interval):\n    \"\"\"\n    Calculate the urgency factor based on time since last execution."
    },
    "calculate_urgency": {
      "start_line": 162,
      "end_line": 188,
      "parameters": [
        {
          "name": "time_since_last_execution"
        },
        {
          "name": "optimal_execution_interval"
        }
      ],
      "return_type": null,
      "calls": [
        {
          "name": "min",
          "line": 186
        },
        {
          "name": "ValueError",
          "line": 178
        },
        {
          "name": "ValueError",
          "line": 180
        }
      ],
      "docstring": "\n    Calculate the urgency factor based on time since last execution.\n    \n    Implements the formula from Section 2.3 of the Mathematical Foundation:\n    urgency = min(1.0, time_since_last_execution / optimal_execution_interval)\n    \n    Args:\n        time_since_last_execution (float): Time since the last execution\n        optimal_execution_interval (float): Optimal interval between executions\n        \n    Returns:\n        float: Urgency factor (0.0-1.0)\n    ",
      "code_snippet": "    return max(0.0, min(1.0, impact))\n\ndef calculate_urgency(time_since_last_execution, optimal_execution_interval):\n    \"\"\"\n    Calculate the urgency factor based on time since last execution.\n    \n    Implements the formula from Section 2.3 of the Mathematical Foundation:\n    urgency = min(1.0, time_since_last_execution / optimal_execution_interval)\n    \n    Args:\n        time_since_last_execution (float): Time since the last execution\n        optimal_execution_interval (float): Optimal interval between executions\n        \n    Returns:\n        float: Urgency factor (0.0-1.0)\n    \"\"\"\n    # Input validation\n    if time_since_last_execution < 0:\n        raise ValueError(\"Time since last execution must be non-negative\")\n    if optimal_execution_interval <= 0:\n        raise ValueError(\"Optimal execution interval must be positive\")\n    \n    # Calculate urgency\n    urgency = time_since_last_execution / optimal_execution_interval\n    \n    # Ensure result is in valid range [0, 1]\n    return min(1.0, urgency)"
    }
  },
  "constants": {}
}