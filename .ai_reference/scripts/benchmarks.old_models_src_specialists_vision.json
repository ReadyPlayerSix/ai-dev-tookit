{
  "path": "D:\\Projects\\isekaiZen\\machine-learning-optimizer\\benchmarks.old\\models\\src\\specialists\\vision.py",
  "imports": [
    {
      "name": "torch",
      "line": 4
    },
    {
      "name": "typing.Dict",
      "line": 5
    },
    {
      "name": "typing.Any",
      "line": 5
    },
    {
      "name": "typing.Optional",
      "line": 5
    },
    {
      "name": "typing.List",
      "line": 5
    },
    {
      "name": "numpy",
      "line": 6
    },
    {
      "name": "ultralytics.YOLO",
      "line": 7
    },
    {
      "name": "dataclasses.dataclass",
      "line": 8
    },
    {
      "name": "specialists.base.BaseSpecialist",
      "line": 11
    },
    {
      "name": "utils.types.Pattern",
      "line": 12
    },
    {
      "name": "utils.types.DomainType",
      "line": 12
    },
    {
      "name": "utils.types.PatternType",
      "line": 12
    },
    {
      "name": "utils.resource_manager.ResourceManager",
      "line": 13
    }
  ],
  "classes": {
    "SemanticPattern": {
      "start_line": 16,
      "end_line": 23,
      "methods": {},
      "class_variables": [],
      "bases": [],
      "docstring": "Represents a pure visual semantic pattern"
    },
    "VisionSpecialist": {
      "start_line": 23,
      "end_line": 190,
      "methods": {
        "__init__": {
          "start_line": 24,
          "end_line": 49,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "resource_manager",
              "type": "ResourceManager"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "....__init__",
              "line": 25
            },
            {
              "name": "self.initialize_model",
              "line": 47
            },
            {
              "name": "super",
              "line": 25
            }
          ],
          "code_snippet": "\nclass VisionSpecialist(BaseSpecialist):\n    def __init__(self, resource_manager: ResourceManager):\n        super().__init__(DomainType.VISUAL, resource_manager)\n        self.memory_requirement = 500  # YOLO needs ~500MB\n        \n        # Initialize patterns\n        self.visual_patterns = {\n            \"spatial_dominance\": {\n                \"min_area_ratio\": 0.3,  # Object takes up significant space\n                \"confidence_threshold\": 0.85\n            },\n            \"spatial_relationship\": {\n                \"proximity_threshold\": 500,  # pixels\n                \"overlap_threshold\": 0.3\n            }\n        }\n        \n        # Track semantic translations\n        self.translation_metrics = {\n            \"patterns_identified\": 0,\n            \"high_confidence_patterns\": 0,\n            \"pattern_preservation_score\": 0.0\n        }\n        \n        self.initialize_model()\n        \n    def initialize_model(self):\n        \"\"\"Initialize YOLO model\"\"\"\n        self.model = YOLO('yolov8n.pt')  # Use nano model for speed"
        },
        "initialize_model": {
          "start_line": 49,
          "end_line": 55,
          "parameters": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "YOLO",
              "line": 51
            },
            {
              "name": "torch.cuda.is_available",
              "line": 52
            },
            {
              "name": "self.model.to",
              "line": 53
            }
          ],
          "docstring": "Initialize YOLO model",
          "code_snippet": "        self.initialize_model()\n        \n    def initialize_model(self):\n        \"\"\"Initialize YOLO model\"\"\"\n        self.model = YOLO('yolov8n.pt')  # Use nano model for speed\n        if torch.cuda.is_available():\n            self.model.to(self.device)\n        \n    def _calculate_spatial_metrics(self, bbox: List[float]) -> Dict[str, float]:\n        \"\"\"Calculate pure spatial characteristics\"\"\"\n        x1, y1, x2, y2 = bbox"
        },
        "_calculate_spatial_metrics": {
          "start_line": 55,
          "end_line": 70,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "bbox"
            }
          ],
          "return_type": "complex_type",
          "calls": [],
          "docstring": "Calculate pure spatial characteristics",
          "code_snippet": "            self.model.to(self.device)\n        \n    def _calculate_spatial_metrics(self, bbox: List[float]) -> Dict[str, float]:\n        \"\"\"Calculate pure spatial characteristics\"\"\"\n        x1, y1, x2, y2 = bbox\n        width = x2 - x1\n        height = y2 - y1\n        area = width * height\n        aspect_ratio = width / height if height != 0 else 0\n        center_x = (x1 + x2) / 2\n        center_y = (y1 + y2) / 2\n        \n        return {\n            \"area\": area,\n            \"aspect_ratio\": aspect_ratio,\n            \"center_position\": (center_x, center_y)\n        }\n        \n    def _identify_spatial_patterns(self, detection: Dict[str, Any]) -> Optional[SemanticPattern]:\n        \"\"\"Identify pure visual patterns from spatial information\"\"\""
        },
        "_identify_spatial_patterns": {
          "start_line": 71,
          "end_line": 93,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "detection"
            }
          ],
          "return_type": "complex_type",
          "calls": [
            {
              "name": "self._calculate_spatial_metrics",
              "line": 77
            },
            {
              "name": "SemanticPattern",
              "line": 81
            }
          ],
          "docstring": "Identify pure visual patterns from spatial information",
          "code_snippet": "        }\n        \n    def _identify_spatial_patterns(self, detection: Dict[str, Any]) -> Optional[SemanticPattern]:\n        \"\"\"Identify pure visual patterns from spatial information\"\"\"\n        bbox = detection['bbox']\n        confidence = detection['confidence']\n        \n        # Calculate spatial metrics while maintaining visual domain purity\n        spatial_metrics = self._calculate_spatial_metrics(bbox)\n        \n        # Check for dominant object pattern\n        if (confidence >= self.visual_patterns[\"spatial_dominance\"][\"confidence_threshold\"]):\n            return SemanticPattern(\n                pattern_type=\"dominant_object\",\n                spatial_relationship={\n                    \"relative_size\": spatial_metrics[\"area\"],\n                    \"position\": spatial_metrics[\"center_position\"],\n                    \"proportions\": spatial_metrics[\"aspect_ratio\"]\n                },\n                confidence=confidence\n            )\n            \n        return None\n        \n    def preprocess_input(self, input_data: Any) -> torch.Tensor:\n        \"\"\"Preprocess image for YOLO\"\"\"\n        # YOLO can handle the image directly"
        },
        "preprocess_input": {
          "start_line": 93,
          "end_line": 98,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "input_data",
              "type": "Any"
            }
          ],
          "return_type": null,
          "calls": [],
          "docstring": "Preprocess image for YOLO",
          "code_snippet": "        return None\n        \n    def preprocess_input(self, input_data: Any) -> torch.Tensor:\n        \"\"\"Preprocess image for YOLO\"\"\"\n        # YOLO can handle the image directly\n        return input_data\n        \n    def identify_patterns(self, detections: List[Dict]) -> Optional[Pattern]:\n        \"\"\"Convert YOLO detections to semantic patterns\"\"\"\n        semantic_patterns = []"
        },
        "identify_patterns": {
          "start_line": 98,
          "end_line": 135,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "detections"
            }
          ],
          "return_type": "complex_type",
          "calls": [
            {
              "name": "self._identify_spatial_patterns",
              "line": 104
            },
            {
              "name": "max",
              "line": 121
            },
            {
              "name": "Pattern",
              "line": 122
            },
            {
              "name": "semantic_patterns.append",
              "line": 110
            },
            {
              "name": "np.array",
              "line": 123
            }
          ],
          "docstring": "Convert YOLO detections to semantic patterns",
          "code_snippet": "        return input_data\n        \n    def identify_patterns(self, detections: List[Dict]) -> Optional[Pattern]:\n        \"\"\"Convert YOLO detections to semantic patterns\"\"\"\n        semantic_patterns = []\n        \n        # Process each detection while maintaining visual domain isolation\n        for detection in detections:\n            pattern = self._identify_spatial_patterns(detection)\n            \n            if pattern:\n                self.translation_metrics[\"patterns_identified\"] += 1\n                if pattern.confidence >= 0.85:\n                    self.translation_metrics[\"high_confidence_patterns\"] += 1\n                semantic_patterns.append(pattern)\n        \n        # Calculate pattern preservation score\n        if self.translation_metrics[\"patterns_identified\"] > 0:\n            self.translation_metrics[\"pattern_preservation_score\"] = (\n                self.translation_metrics[\"high_confidence_patterns\"] / \n                self.translation_metrics[\"patterns_identified\"]\n            )\n        \n        # Convert the most confident semantic pattern to a universal Pattern type\n        if semantic_patterns:\n            best_pattern = max(semantic_patterns, key=lambda p: p.confidence)\n            return Pattern(\n                signature=np.array([best_pattern.confidence]),  # Simplified signature\n                weight=best_pattern.confidence,\n                pattern_type=PatternType.OPPORTUNITY if best_pattern.confidence > 0.8 \n                          else PatternType.RISK,\n                complexity=1.0,  # Base complexity\n                domain=self.domain,\n                confidence=best_pattern.confidence,\n                preservation_score=self.translation_metrics[\"pattern_preservation_score\"]\n            )\n        \n        return None\n        \n    def process_input(self, input_data: Any) -> Dict[str, Any]:\n        \"\"\"Process image through YOLO and extract patterns\"\"\"\n        # Try to allocate resources"
        },
        "process_input": {
          "start_line": 135,
          "end_line": 181,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "input_data",
              "type": "Any"
            }
          ],
          "return_type": "complex_type",
          "calls": [
            {
              "name": "self.resource_manager.allocate_resources",
              "line": 138
            },
            {
              "name": "self.model",
              "line": 150
            },
            {
              "name": "self.identify_patterns",
              "line": 165
            },
            {
              "name": "self.resource_manager.release_resources",
              "line": 177
            },
            {
              "name": "str",
              "line": 139
            },
            {
              "name": "str",
              "line": 178
            },
            {
              "name": "detections.append",
              "line": 162
            },
            {
              "name": "....tolist",
              "line": 158
            },
            {
              "name": "float",
              "line": 159
            },
            {
              "name": "float",
              "line": 160
            }
          ],
          "docstring": "Process image through YOLO and extract patterns",
          "code_snippet": "        return None\n        \n    def process_input(self, input_data: Any) -> Dict[str, Any]:\n        \"\"\"Process image through YOLO and extract patterns\"\"\"\n        # Try to allocate resources\n        if not self.resource_manager.allocate_resources(\n            str(self.domain), \n            self.memory_requirement\n        ):\n            return {\n                \"success\": False,\n                \"error\": \"Failed to allocate resources\",\n                \"domain\": self.domain\n            }\n        \n        try:\n            # Run YOLO inference\n            results = self.model(input_data, stream=True)\n            detections = []\n            \n            # Process results\n            for r in results:\n                boxes = r.boxes\n                for box in boxes:\n                    detection = {\n                        'bbox': box.xyxy[0].tolist(),\n                        'confidence': float(box.conf[0]),\n                        'class_id': float(box.cls[0])\n                    }\n                    detections.append(detection)\n            \n            # Identify patterns from detections\n            pattern = self.identify_patterns(detections)\n            \n            return {\n                \"success\": True,\n                \"pattern\": pattern,\n                \"metrics\": self.metrics,\n                \"domain\": self.domain,\n                \"raw_detections\": detections\n            }\n            \n        finally:\n            # Always release resources\n            self.resource_manager.release_resources(\n                str(self.domain),\n                self.memory_requirement\n            )\n        \n    def save_state(self, path: str):\n        \"\"\"Save model state - YOLO handles its own state\"\"\""
        },
        "save_state": {
          "start_line": 182,
          "end_line": 186,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "path",
              "type": "str"
            }
          ],
          "return_type": null,
          "calls": [],
          "docstring": "Save model state - YOLO handles its own state",
          "code_snippet": "            )\n        \n    def save_state(self, path: str):\n        \"\"\"Save model state - YOLO handles its own state\"\"\"\n        pass\n        \n    def load_state(self, path: str):\n        \"\"\"Load model state - YOLO handles its own state\"\"\"\n        pass"
        },
        "load_state": {
          "start_line": 186,
          "end_line": 190,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "path",
              "type": "str"
            }
          ],
          "return_type": null,
          "calls": [],
          "docstring": "Load model state - YOLO handles its own state",
          "code_snippet": "        pass\n        \n    def load_state(self, path: str):\n        \"\"\"Load model state - YOLO handles its own state\"\"\"\n        pass"
        }
      },
      "class_variables": [],
      "bases": [
        "BaseSpecialist"
      ]
    }
  },
  "functions": {},
  "constants": {}
}