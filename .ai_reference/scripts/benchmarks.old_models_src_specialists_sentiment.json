{
  "path": "D:\\Projects\\isekaiZen\\machine-learning-optimizer\\benchmarks.old\\models\\src\\specialists\\sentiment.py",
  "imports": [
    {
      "name": "dataclasses.dataclass",
      "line": 4
    },
    {
      "name": "typing.Dict",
      "line": 5
    },
    {
      "name": "typing.List",
      "line": 5
    },
    {
      "name": "typing.Any",
      "line": 5
    },
    {
      "name": "typing.Optional",
      "line": 5
    },
    {
      "name": "torch",
      "line": 6
    },
    {
      "name": "transformers.RobertaTokenizer",
      "line": 7
    },
    {
      "name": "transformers.RobertaForSequenceClassification",
      "line": 7
    },
    {
      "name": "numpy",
      "line": 8
    },
    {
      "name": "base.BaseSpecialist",
      "line": 9
    }
  ],
  "classes": {
    "EmotionalPattern": {
      "start_line": 12,
      "end_line": 19,
      "methods": {},
      "class_variables": [],
      "bases": [],
      "docstring": "Represents a pure emotional pattern"
    },
    "SentimentSpecialist": {
      "start_line": 19,
      "end_line": 187,
      "methods": {
        "__init__": {
          "start_line": 20,
          "end_line": 61,
          "parameters": [
            {
              "name": "self"
            }
          ],
          "return_type": null,
          "calls": [
            {
              "name": "....__init__",
              "line": 21
            },
            {
              "name": "torch.device",
              "line": 22
            },
            {
              "name": "RobertaTokenizer.from_pretrained",
              "line": 26
            },
            {
              "name": "....to",
              "line": 27
            },
            {
              "name": "super",
              "line": 21
            },
            {
              "name": "torch.cuda.is_available",
              "line": 22
            },
            {
              "name": "RobertaForSequenceClassification.from_pretrained",
              "line": 27
            }
          ],
          "code_snippet": "\nclass SentimentSpecialist(BaseSpecialist):\n    def __init__(self):\n        super().__init__()\n        self.device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')\n        \n        # Initialize RoBERTa\n        self.model_name = \"roberta-base\"\n        self.tokenizer = RobertaTokenizer.from_pretrained(self.model_name)\n        self.model = RobertaForSequenceClassification.from_pretrained(\n            self.model_name,\n            num_labels=7  # joy, sadness, anger, fear, surprise, disgust, neutral\n        ).to(self.device)\n        \n        # Pattern thresholds\n        self.emotion_patterns = {\n            \"strong_emotion\": {\n                \"intensity_threshold\": 0.4,\n                \"confidence_threshold\": 0.6,\n                \"max_secondary_ratio\": 0.3\n            },\n            \"mixed_emotion\": {\n                \"secondary_ratio_min\": 0.4,\n                \"intensity_threshold\": 0.25,\n                \"confidence_threshold\": 0.5\n            },\n            \"neutral_emotion\": {\n                \"max_intensity\": 0.3,\n                \"min_complexity\": 0.3,\n                \"confidence_threshold\": 0.5\n            }\n        }\n        \n        # Metrics tracking\n        self.pattern_metrics = {\n            \"patterns_identified\": 0,\n            \"high_confidence_patterns\": 0,\n            \"pattern_preservation_score\": 0.0,\n            \"pattern_distribution\": {\n                \"strong_emotion\": 0,\n                \"mixed_emotion\": 0,\n                \"neutral_emotion\": 0\n            }\n        }\n\n    def _calculate_emotional_metrics(self, "
        },
        "_calculate_emotional_metrics": {
          "start_line": 63,
          "end_line": 90,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "emotion_logits"
            }
          ],
          "return_type": "complex_type",
          "calls": [
            {
              "name": "torch.sort",
              "line": 70
            },
            {
              "name": "float",
              "line": 72
            },
            {
              "name": "float",
              "line": 73
            },
            {
              "name": "np.log",
              "line": 76
            },
            {
              "name": "torch.softmax",
              "line": 68
            },
            {
              "name": "....item",
              "line": 74
            },
            {
              "name": "....item",
              "line": 87
            },
            {
              "name": "torch.sum",
              "line": 74
            },
            {
              "name": "torch.sum",
              "line": 87
            },
            {
              "name": "....item",
              "line": 88
            },
            {
              "name": "torch.log",
              "line": 74
            },
            {
              "name": "torch.mean",
              "line": 88
            }
          ],
          "docstring": "Calculate pure emotional characteristics",
          "code_snippet": "        }\n\n    def _calculate_emotional_metrics(self, \n                                  emotion_logits: torch.Tensor) -> Dict[str, float]:\n        \"\"\"Calculate pure emotional characteristics\"\"\"\n        temperature = 2.0\n        scaled_logits = emotion_logits / temperature\n        probs = torch.softmax(scaled_logits, dim=1)[0]\n        \n        sorted_probs, indices = torch.sort(probs, descending=True)\n        \n        primary_intensity = float(sorted_probs[0])\n        secondary_intensity = float(sorted_probs[1])\n        emotional_complexity = -torch.sum(probs * torch.log(probs + 1e-10)).item()\n        \n        max_entropy = np.log(7)  # Maximum possible entropy for 7 emotions\n        normalized_complexity = emotional_complexity / max_entropy\n        \n        return {\n            \"intensity_metrics\": {\n                \"primary_emotion\": primary_intensity,\n                \"secondary_emotion\": secondary_intensity,\n                \"intensity_ratio\": secondary_intensity / primary_intensity if primary_intensity > 0 else 0\n            },\n            \"complexity_metrics\": {\n                \"emotional_entropy\": normalized_complexity,\n                \"emotion_count\": torch.sum(probs > 0.1).item(),\n                \"distribution_evenness\": 1 - (primary_intensity - torch.mean(probs).item())\n            }\n        }\n\n    def _identify_emotional_pattern(self, "
        },
        "_identify_emotional_pattern": {
          "start_line": 92,
          "end_line": 158,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "emotion_metrics"
            }
          ],
          "return_type": "complex_type",
          "calls": [
            {
              "name": "EmotionalPattern",
              "line": 107
            },
            {
              "name": "EmotionalPattern",
              "line": 126
            },
            {
              "name": "EmotionalPattern",
              "line": 146
            }
          ],
          "docstring": "Identify pure emotional patterns from metrics",
          "code_snippet": "        }\n\n    def _identify_emotional_pattern(self, \n                                  emotion_metrics: Dict[str, Any]) -> Optional[EmotionalPattern]:\n        \"\"\"Identify pure emotional patterns from metrics\"\"\"\n        intensity = emotion_metrics[\"intensity_metrics\"]\n        complexity = emotion_metrics[\"complexity_metrics\"]\n        \n        # Check for strong emotion pattern\n        if (intensity[\"primary_emotion\"] >= \n            self.emotion_patterns[\"strong_emotion\"][\"intensity_threshold\"] and\n            intensity[\"intensity_ratio\"] <= \n            self.emotion_patterns[\"strong_emotion\"][\"max_secondary_ratio\"]):\n            \n            self.pattern_metrics[\"pattern_distribution\"][\"strong_emotion\"] += 1\n            confidence = intensity[\"primary_emotion\"] * (1 - intensity[\"intensity_ratio\"])\n            \n            return EmotionalPattern(\n                pattern_type=\"strong_emotion\",\n                emotional_features={\n                    \"intensity\": intensity[\"primary_emotion\"],\n                    \"purity\": 1 - intensity[\"intensity_ratio\"],\n                    \"complexity\": complexity[\"emotional_entropy\"]\n                },\n                confidence=confidence\n            )\n        \n        # Check for mixed emotion pattern\n        elif (intensity[\"intensity_ratio\"] >= \n              self.emotion_patterns[\"mixed_emotion\"][\"secondary_ratio_min\"] and\n              intensity[\"primary_emotion\"] >= \n              self.emotion_patterns[\"mixed_emotion\"][\"intensity_threshold\"]):\n            \n            self.pattern_metrics[\"pattern_distribution\"][\"mixed_emotion\"] += 1\n            confidence = (intensity[\"primary_emotion\"] + intensity[\"secondary_emotion\"]) / 2\n            \n            return EmotionalPattern(\n                pattern_type=\"mixed_emotion\",\n                emotional_features={\n                    \"primary_intensity\": intensity[\"primary_emotion\"],\n                    \"secondary_ratio\": intensity[\"intensity_ratio\"],\n                    \"complexity\": complexity[\"emotional_entropy\"],\n                    \"emotion_count\": complexity[\"emotion_count\"]\n                },\n                confidence=confidence\n            )\n        \n        # Check for neutral emotion pattern\n        elif (intensity[\"primary_emotion\"] <= \n              self.emotion_patterns[\"neutral_emotion\"][\"max_intensity\"] and\n              complexity[\"emotional_entropy\"] >= \n              self.emotion_patterns[\"neutral_emotion\"][\"min_complexity\"]):\n            \n            self.pattern_metrics[\"pattern_distribution\"][\"neutral_emotion\"] += 1\n            confidence = 1 - intensity[\"primary_emotion\"]\n            \n            return EmotionalPattern(\n                pattern_type=\"neutral_emotion\",\n                emotional_features={\n                    \"evenness\": complexity[\"distribution_evenness\"],\n                    \"complexity\": complexity[\"emotional_entropy\"],\n                    \"max_intensity\": intensity[\"primary_emotion\"]\n                },\n                confidence=confidence\n            )\n            \n        return None\n\n    def process_text(self, text: str) -> Dict[str, Any]:\n        \"\"\"Process text and identify emotional patterns\"\"\"\n        inputs = self.tokenizer(text, return_tensors=\"pt\", "
        },
        "process_text": {
          "start_line": 158,
          "end_line": 187,
          "parameters": [
            {
              "name": "self"
            },
            {
              "name": "text",
              "type": "str"
            }
          ],
          "return_type": "complex_type",
          "calls": [
            {
              "name": "....to",
              "line": 160
            },
            {
              "name": "self._calculate_emotional_metrics",
              "line": 167
            },
            {
              "name": "self._identify_emotional_pattern",
              "line": 168
            },
            {
              "name": "torch.no_grad",
              "line": 163
            },
            {
              "name": "self.model",
              "line": 164
            },
            {
              "name": "self.tokenizer",
              "line": 160
            }
          ],
          "docstring": "Process text and identify emotional patterns",
          "code_snippet": "        return None\n\n    def process_text(self, text: str) -> Dict[str, Any]:\n        \"\"\"Process text and identify emotional patterns\"\"\"\n        inputs = self.tokenizer(text, return_tensors=\"pt\", \n                              truncation=True, max_length=512).to(self.device)\n        \n        with torch.no_grad():\n            outputs = self.model(**inputs)\n            emotion_logits = outputs.logits\n        \n        emotion_metrics = self._calculate_emotional_metrics(emotion_logits)\n        pattern = self._identify_emotional_pattern(emotion_metrics)\n        \n        if pattern:\n            self.pattern_metrics[\"patterns_identified\"] += 1\n            pattern_threshold = self.emotion_patterns[pattern.pattern_type][\"confidence_threshold\"]\n            if pattern.confidence >= pattern_threshold:\n                self.pattern_metrics[\"high_confidence_patterns\"] += 1\n        \n        if self.pattern_metrics[\"patterns_identified\"] > 0:\n            self.pattern_metrics[\"pattern_preservation_score\"] = (\n                self.pattern_metrics[\"high_confidence_patterns\"] / \n                self.pattern_metrics[\"patterns_identified\"]\n            )\n        \n        return {\n            \"semantic_pattern\": pattern,\n            \"pattern_metrics\": self.pattern_metrics,\n            \"domain\": \"emotional\"\n        }"
        }
      },
      "class_variables": [],
      "bases": [
        "BaseSpecialist"
      ]
    }
  },
  "functions": {},
  "constants": {}
}